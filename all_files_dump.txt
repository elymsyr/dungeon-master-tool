===== FILE PATH =====
./all_files_dump.txt
===== FILE CONTENT =====


===== FILE PATH =====
./config.py
===== FILE CONTENT =====
import os

import os
import sys

def get_base_path():
    """ PyInstaller ile uyumlu base path dÃ¶ner. """
    if getattr(sys, 'frozen', False):
        return sys._MEIPASS
    return os.path.dirname(os.path.abspath(__file__))

BASE_DIR = get_base_path()

BASE_DIR = get_base_path()

def get_data_root():
    """ 
    Verilerin saklanacaÄŸÄ± dizin.
    User isteÄŸi: 'exe dosyasÄ±nÄ±n bir Ã¼st dizininde tutsun'
    """
    if getattr(sys, 'frozen', False):
        # Frozen (EXE): sys.executable -> .../dist/Game.exe
        # dirname -> .../dist
        # dirname(dirname) -> .../ (Proje kÃ¶kÃ¼ veya exe'nin Ã¼st klasÃ¶rÃ¼)
        exe_path = sys.executable
        return os.path.dirname(os.path.dirname(exe_path))
    else:
        # Dev: .../root/config.py -> .../root
        return os.path.dirname(os.path.abspath(__file__))

DATA_ROOT = get_data_root()

WORLDS_DIR = os.path.join(DATA_ROOT, "worlds")
CACHE_DIR = os.path.join(DATA_ROOT, "cache")
IMAGES_DIR = os.path.join(DATA_ROOT, "assets")

# KlasÃ¶rleri oluÅŸtur
for d in [WORLDS_DIR, CACHE_DIR, IMAGES_DIR]:
    if not os.path.exists(d):
        os.makedirs(d)

API_BASE_URL = "https://www.dnd5eapi.co/api"

THEMES_DIR = os.path.join(BASE_DIR, "themes")

def load_theme(theme_name):
    """Loads a .qss theme file from the themes directory."""
    path = os.path.join(THEMES_DIR, f"{theme_name}.qss")
    if os.path.exists(path):
        with open(path, "r", encoding="utf-8") as f:
            return f.read()
    return "" # Fallback or empty

# Default stylesheet for initial load
STYLESHEET = load_theme("dark")

===== FILE PATH =====
./dump.py
===== FILE CONTENT =====
import os

ROOT_DIR = "./"   # Taranacak ana klasÃ¶r
OUTPUT_FILE = "all_files_dump.txt"  # Ã‡Ä±kÄ±ÅŸ dosyasÄ±

def is_binary(file_path):
    try:
        with open(file_path, "rb") as f:
            chunk = f.read(1024)
            return b'\0' in chunk
    except:
        return True

with open(OUTPUT_FILE, "w", encoding="utf-8") as out:
    for root, dirs, files in os.walk(ROOT_DIR):
        for file in files:
            file_path = os.path.join(root, file)

            # Binary dosyalarÄ± atla (png, exe, vs.)
            if is_binary(file_path):
                continue

            if "git" in file_path or "__pycache__" in file_path or "build" in file_path or "dist" in file_path or "worlds" in file_path or "cache" in file_path:
                continue

            try:
                with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                    content = f.read()

                out.write("===== FILE PATH =====\n")
                out.write(file_path + "\n")
                out.write("===== FILE CONTENT =====\n")
                out.write(content + "\n\n")

            except Exception as e:
                out.write("===== FILE PATH =====\n")
                out.write(file_path + "\n")
                out.write("===== FILE CONTENT =====\n")
                out.write(f"[ERROR READING FILE: {e}]\n\n")

print("Bitti. TÃ¼m dosyalar tek bir txt dosyasÄ±na yazÄ±ldÄ±.")


===== FILE PATH =====
./DungeonMasterTool.spec
===== FILE CONTENT =====
# -*- mode: python ; coding: utf-8 -*-


a = Analysis(
    ['main.py'],
    pathex=[],
    binaries=[],
    datas=[('locales', 'locales'), ('themes', 'themes')],
    hiddenimports=['PyQt6.QtWebEngineWidgets', 'PyQt6.QtWebEngineCore', 'PyQt6.QtPrintSupport', 'PyQt6.QtNetwork', 'requests', 'i18n', 'yaml', 'json'],
    hookspath=[],
    hooksconfig={},
    runtime_hooks=[],
    excludes=[],
    noarchive=False,
    optimize=0,
)
pyz = PYZ(a.pure)

exe = EXE(
    pyz,
    a.scripts,
    a.binaries,
    a.datas,
    [],
    name='DungeonMasterTool',
    debug=False,
    bootloader_ignore_signals=False,
    strip=False,
    upx=False,
    upx_exclude=[],
    runtime_tmpdir=None,
    console=False,
    disable_windowed_traceback=False,
    argv_emulation=False,
    target_arch=None,
    codesign_identity=None,
    entitlements_file=None,
)


===== FILE PATH =====
./LICENSE
===== FILE CONTENT =====
MIT License

Copyright (c) 2026 Orhun Eren YalÃ§Ä±nkaya

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.


===== FILE PATH =====
./main.py
===== FILE CONTENT =====
from os import environ
environ["QTWEBENGINE_DISABLE_SANDBOX"] = "1"
import sys
from PyQt6.QtCore import Qt
from PyQt6.QtWidgets import (QApplication, QMainWindow, QTabWidget, QVBoxLayout, 
                             QWidget, QMessageBox, QFileDialog, QHBoxLayout, 
                             QPushButton, QLabel, QComboBox)
from config import STYLESHEET, load_theme
from core.data_manager import DataManager
from ui.player_window import PlayerWindow
from ui.tabs.database_tab import DatabaseTab
from ui.tabs.map_tab import MapTab
from ui.tabs.session_tab import SessionTab
from ui.campaign_selector import CampaignSelector
from core.locales import tr
from ui.soundpad_panel import SoundpadPanel

class MainWindow(QMainWindow):
    def __init__(self, data_manager):
        super().__init__()
        self.data_manager = data_manager
        self.player_window = PlayerWindow()
        
        # --- TEMA LÄ°STESÄ° (TEK KAYNAK / SOURCE OF TRUTH) ---
        # (Dosya AdÄ±, GÃ¶rÃ¼nen Ä°sim veya Ã‡eviri AnahtarÄ±)
        self.theme_list = [
            ("dark", "THEME_DARK"),
            ("light", "THEME_LIGHT"),
            ("baldur", "Baldur's Gate"),
            ("discord", "Discord"),
            ("grim", "Grim (Dark)"),
            ("midnight", "THEME_MIDNIGHT"),
            ("emerald", "THEME_EMERALD"),
            ("parchment", "THEME_PARCHMENT"),
            ("ocean", "THEME_OCEAN"),
            ("frost", "THEME_FROST"),
            ("amethyst", "THEME_AMETHYST")
        ]
        
        self.setWindowTitle(f"DM Tool - {self.data_manager.data.get('world_name', 'Bilinmiyor')}")
        self.setGeometry(100, 100, 1400, 900)
        
        # BaÅŸlangÄ±Ã§ temasÄ±nÄ± yÃ¼kle
        self.current_stylesheet = load_theme(self.data_manager.current_theme)
        self.setStyleSheet(self.current_stylesheet)
        
        self.init_ui()

    def init_ui(self):
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QVBoxLayout(central)
        
        # --- ÃœST BAR (TOOLBAR) ---
        toolbar = QHBoxLayout()
        
        # Oyuncu EkranÄ± Butonu
        self.btn_toggle_player = QPushButton(tr("BTN_PLAYER_SCREEN"))
        self.btn_toggle_player.setCheckable(True)
        self.btn_toggle_player.setObjectName("primaryBtn") 
        self.btn_toggle_player.clicked.connect(self.toggle_player_window)
        
        # DÄ±ÅŸa Aktar Butonu
        self.btn_export_txt = QPushButton(tr("BTN_EXPORT"))
        self.btn_export_txt.setObjectName("successBtn")
        self.btn_export_txt.clicked.connect(self.export_entities_to_txt)
        
        # --- YENÄ° BUTON: SOUNDPAD ---
        self.btn_toggle_sound = QPushButton("ðŸ”Š")
        self.btn_toggle_sound.setCheckable(True) # BasÄ±lÄ± kalabilen buton (Toggle)
        self.btn_toggle_sound.setToolTip(tr("BTN_TOGGLE_SOUNDPAD"))
        self.btn_toggle_sound.clicked.connect(self.toggle_soundpad)
        # ----------------------------
        
        # DÃ¼nya Bilgisi
        self.lbl_campaign = QLabel(f"{tr('LBL_CAMPAIGN')} {self.data_manager.data.get('world_name')}")
        self.lbl_campaign.setObjectName("toolbarLabel")

        # Dil SeÃ§imi
        self.combo_lang = QComboBox()
        self.combo_lang.addItems(["English", "TÃ¼rkÃ§e"])
        
        current_lang = self.data_manager.settings.get("language", "EN")
        self.combo_lang.setCurrentIndex(1 if current_lang == "TR" else 0)
        self.combo_lang.currentIndexChanged.connect(self.change_language)
        
        # Tema SeÃ§imi
        self.lbl_theme = QLabel(tr("LBL_THEME"))
        self.lbl_theme.setObjectName("toolbarLabel")
        
        self.combo_theme = QComboBox()
        
        # TemalarÄ± listeye ekle
        for _, display_name in self.theme_list:
            if display_name.startswith("THEME_"):
                self.combo_theme.addItem(tr(display_name))
            else:
                self.combo_theme.addItem(display_name)
        
        # Mevcut temayÄ± bul ve seÃ§
        current_theme_code = self.data_manager.current_theme
        index_to_select = 0
        for i, (code, _) in enumerate(self.theme_list):
            if code == current_theme_code:
                index_to_select = i
                break
        
        self.combo_theme.setCurrentIndex(index_to_select)
        self.combo_theme.currentIndexChanged.connect(self.change_theme)
        
        # Toolbar'a ekle
        toolbar.addWidget(self.btn_toggle_player)
        toolbar.addWidget(self.btn_export_txt)
        toolbar.addWidget(self.btn_toggle_sound) # Soundpad Butonu
        toolbar.addWidget(self.lbl_campaign)
        toolbar.addStretch()
        toolbar.addWidget(self.combo_lang)
        toolbar.addWidget(self.lbl_theme)
        toolbar.addWidget(self.combo_theme)
        
        main_layout.addLayout(toolbar)
        
        # --- ORTA ALAN (Ä°Ã‡ERÄ°K + SOUNDPAD) ---
        content_layout = QHBoxLayout()
        
        # --- SEKMELER (TABS) ---
        self.tabs = QTabWidget()
        
        # Tab 1: VeritabanÄ±
        self.db_tab = DatabaseTab(self.data_manager, self.player_window)
        self.tabs.addTab(self.db_tab, tr("TAB_DB"))
        
        # Tab 2: Harita
        # self'i (MainWindow) gÃ¶nderiyoruz ki pinlere tÄ±klayÄ±nca db_tab'a geÃ§ebilsin
        self.map_tab = MapTab(self.data_manager, self.player_window, self) 
        self.tabs.addTab(self.map_tab, tr("TAB_MAP")) 
        
        # Tab 3: Session (Oyun YÃ¶netimi)
        self.session_tab = SessionTab(self.data_manager)
        self.tabs.addTab(self.session_tab, tr("TAB_SESSION"))
        
        # --- SOUNDPAD PANELÄ° (SAÄž TARAF) ---
        self.soundpad_panel = SoundpadPanel()
        self.soundpad_panel.setVisible(False) # BaÅŸlangÄ±Ã§ta gizli
        
        # Layout'a Ekleme (Sol: Sekmeler, SaÄŸ: Soundpad)
        content_layout.addWidget(self.tabs, 1) # 1 = Esnek (GeniÅŸleyen)
        content_layout.addWidget(self.soundpad_panel, 0) # 0 = Sabit GeniÅŸlik
        
        main_layout.addLayout(content_layout)
        
        self.map_tab.render_map()
        self.retranslate_ui()

    def retranslate_ui(self):
        # Ãœst Bar Ã‡evirileri
        self.btn_toggle_player.setText(tr("BTN_PLAYER_SCREEN"))
        self.btn_export_txt.setText(tr("BTN_EXPORT"))
        self.btn_toggle_sound.setToolTip(tr("BTN_TOGGLE_SOUNDPAD"))
        self.lbl_campaign.setText(f"{tr('LBL_CAMPAIGN')} {self.data_manager.data.get('world_name')}")
        
        # Sekme Ä°simleri
        self.tabs.setTabText(0, tr("TAB_DB"))
        self.tabs.setTabText(1, tr("TAB_MAP"))
        self.tabs.setTabText(2, tr("TAB_SESSION"))
        
        # Alt BileÅŸenleri Tetikle (Recursive Update)
        if hasattr(self.db_tab, "retranslate_ui"): self.db_tab.retranslate_ui()
        if hasattr(self.map_tab, "retranslate_ui"): self.map_tab.retranslate_ui()
        if hasattr(self.session_tab, "retranslate_ui"): self.session_tab.retranslate_ui()
        if hasattr(self.soundpad_panel, "retranslate_ui"): self.soundpad_panel.retranslate_ui()
        
        # Tema Ã‡evirisi
        self.lbl_theme.setText(tr("LBL_THEME"))
        
        # Tema Combobox Ä°simlerini GÃ¼ncelle
        for i, (_, display_name) in enumerate(self.theme_list):
            if display_name.startswith("THEME_"):
                self.combo_theme.setItemText(i, tr(display_name))
            else:
                self.combo_theme.setItemText(i, display_name)

    def change_language(self, index):
        code = "TR" if index == 1 else "EN"
        self.data_manager.save_settings({"language": code})
        self.retranslate_ui()

    def toggle_soundpad(self):
        is_visible = self.soundpad_panel.isVisible()
        self.soundpad_panel.setVisible(not is_visible)
        self.btn_toggle_sound.setChecked(not is_visible)

    def change_theme(self, index):
        if 0 <= index < len(self.theme_list):
            theme_name = self.theme_list[index][0] # ("baldur", "Baldur's Gate") -> "baldur"
            self.data_manager.save_settings({"theme": theme_name})
            
            # Apply theme
            self.current_stylesheet = load_theme(theme_name)
            self.setStyleSheet(self.current_stylesheet)
            
            # Propagate to player window
            if hasattr(self.player_window, "update_theme"):
                self.player_window.update_theme(self.current_stylesheet)

    def toggle_player_window(self):
        if self.player_window.isVisible():
            self.player_window.hide()
            self.btn_toggle_player.setChecked(False)
        else:
            self.player_window.show()
            self.btn_toggle_player.setChecked(True)
            # Pencere aÃ§Ä±ldÄ±ÄŸÄ±nda temayÄ± zorla (bazen ilk aÃ§Ä±lÄ±ÅŸta almayabiliyor)
            self.player_window.update_theme(self.current_stylesheet)

    def export_entities_to_txt(self):
        # KayÄ±t yeri sor
        path, _ = QFileDialog.getSaveFileName(self, tr("TITLE_EXPORT"), "export.txt", tr("FILE_FILTER_TXT"))
        if not path: return
        
        try:
            with open(path, "w", encoding="utf-8") as f:
                f.write(f"{tr('TXT_EXPORT_HEADER')}\n")
                f.write(f"{tr('TXT_EXPORT_WORLD')}{self.data_manager.data.get('world_name')}\n")
                f.write("="*50 + "\n\n")
                
                entities = self.data_manager.data.get("entities", {})
                if not entities:
                    f.write(f"{tr('TXT_EXPORT_NO_DATA')}\n")
                
                # SÄ±ralayarak yazalÄ±m
                sorted_keys = sorted(entities.keys(), key=lambda k: entities[k].get("name", ""))
                
                for i, eid in enumerate(sorted_keys, 1):
                    ent = entities[eid]
                    name = ent.get("name", tr("NAME_UNNAMED"))
                    type_ = ent.get("type", tr("NAME_UNKNOWN"))
                    tags = ", ".join(ent.get("tags", []))
                    desc = ent.get("description", "").replace("\n", " ")
                    if len(desc) > 100: desc = desc[:97] + "..."
                    
                    f.write(f"{i}. {name} ({type_})\n")
                    if tags: f.write(f"{tr('TXT_EXPORT_TAGS')}{tags}\n")
                    f.write(f"{tr('TXT_EXPORT_DESC')}{desc}\n")
                    
                    # StatlarÄ± da ekleyelim
                    c = ent.get("combat_stats", {})
                    if type_ in ["NPC", "Monster", "Player"] and c:
                        hp = c.get("hp", "-")
                        ac = c.get("ac", "-")
                        cr = c.get("cr", "-")
                        f.write(f"   HP: {hp} | AC: {ac} | CR: {cr}\n")
                        
                    f.write("-" * 30 + "\n")
            
            QMessageBox.information(self, tr("MSG_SUCCESS"), tr("MSG_EXPORT_SUCCESS"))
        except Exception as e:
            QMessageBox.critical(self, tr("MSG_ERROR"), tr("MSG_FILE_WRITE_ERROR", error=str(e)))

if __name__ == "__main__":
    # Enable lazy loading of QtWebEngine widgets
    QApplication.setAttribute(Qt.ApplicationAttribute.AA_ShareOpenGLContexts)
    
    app = QApplication(sys.argv)
    
    # 1. Veri YÃ¶neticisi BaÅŸlat
    dm = DataManager()
    
    # 2. SeÃ§im EkranÄ±
    selector = CampaignSelector(dm)
    if selector.exec():
        # 3. Ana Pencere
        window = MainWindow(dm)
        window.show()
        sys.exit(app.exec())
    else:
        sys.exit()

===== FILE PATH =====
./README.md
===== FILE CONTENT =====
# ðŸ‰ Dungeon Master Tool

![Status](https://img.shields.io/badge/Status-Alpha-orange)
![License](https://img.shields.io/badge/License-GPL-blue)
![Platform](https://img.shields.io/badge/Platform-Windows%20%7C%20Linux-lightgrey)

**A portable, offline-first DM tool designed for dual-monitor setups.**
Manage combat, track stats, and project maps to your players without the hassle.

[ðŸ“¥ Download Latest Release](https://github.com/elymsyr/dungeon-master-tool/releases)

> âœ¨ UI/UX Status: The user interface is now in a much better stateâ€”cleaner, more consistent, and easier to read. We are committed to continuously improving the look and feel in upcoming updates!

> Hey guys, leaving a star or a feedback would be the best motivation for me, since I work on a full-time job. I am trying to create an app for dungeon masters. Hope you'll like it :)
---

## âœ¨ Key Features

*   **Dual Screen Support:** Keep your DM notes private while projecting maps and stat blocks to a second screen.
*   **Combat Tracker:** Streamlined Initiative, HP, and Condition tracking.
*   **Lightweight VTT:** Drag & drop tokens onto maps instantly.
*   **5e Database:** Built-in API browser for Monsters, Spells, and Items.
*   **Portable:** No installation required. Runs entirely from a USB drive.

## ðŸ—ºï¸ Roadmap

### âœ… Completed
- [x] **Visual Status:** Status badges/icons on Combat Tracker & Battlemap.
- [x] **UI/UX Overhaul:** Modernized interface, new themes (Baldur, Grim, Discord), and split-view editing.
- [x] **Multi-Encounter:** Manage multiple encounters simultaneously within a session.
- [x] **System Upgrades:** Advanced Entity Cards, Multi-Add, and Status Effect systems.

### ðŸš§ In Progress / Planned

- [ ] **More Sources and Prebuild Worlds:** We're planning to add more entities from other sources like 5E 2024, Forgotten Realms and else... Also adding custom design prebuild worlds to help newbies.
- [ ] **Soundpad:** Support for custom music and sound effects.
- [ ] **Fog of War:** Interactive masking/revealing areas on the Battle Map.
- [ ] **Campaign Notes:** Rich text editor, linking, and better folder organization for DM notes.
- [ ] **Integrations:** Support for D&D Beyond, Obsidian, and other tools.
- [ ] **Multi-Window:** Advanced support for projecting to specific/multiple player screens.

## ðŸ“ Additional Plan Notes
- [ ] Save folder path change
- [ ] Adding battlemaps as entities and into location entities and load
- [ ] Split DM note area to control the battlemap fog and pawns
- [ ] Add API import with image support
- [ ] A better World control, bulk export entities from one world to another 
- [ ] Add custom entity sets

## ðŸš€ Installation

### Option 1: Executable (Recommended)
1.  Go to the **Releases** page.
2.  Download the latest `.exe`.
3.  Run it! (Data saves locally).

### Option 2: From Source
```bash
git clone https://github.com/elymsyr/dungeon-master-tool.git
cd dungeon-master-tool
pip install -r requirements.txt
python main.py
```

## âš ï¸ Disclaimer
This project is currently in Pre-Alpha. Expect bugs and frequent updates.


===== FILE PATH =====
./requirements.txt
===== FILE CONTENT =====
PyQt6
requests
PyQt6-WebEngine
python-i18n
PyYAML
pytest
pytest-qt
pytest-mock
pyinstaller

===== FILE PATH =====
./version_info.txt
===== FILE CONTENT =====
# version_info.txt
VSVersionInfo(
  ffi=FixedFileInfo(
    filevers=(0, 1, 0, 0),
    prodvers=(0, 1, 0, 0),
    mask=0x3f,
    flags=0x0,
    OS=0x40004,
    fileType=0x1,
    subtype=0x0,
    date=(0, 0)
  ),
  kids=[
    StringFileInfo(
      [
      StringTable(
        u'040904B0',
        [StringStruct(u'CompanyName', u'Dungeon Master Tool Open Source'),
        StringStruct(u'FileDescription', u'Dungeon Master Tool'),
        StringStruct(u'FileVersion', u'0.1.0'),
        StringStruct(u'InternalName', u'dmtool'),
        StringStruct(u'LegalCopyright', u'Copyright (c) 2025 Elymsyr'),
        StringStruct(u'OriginalFilename', u'DungeonMasterTool.exe'),
        StringStruct(u'ProductName', u'Dungeon Master Tool'),
        StringStruct(u'ProductVersion', u'0.1.0')])
      ]
    ),
    VarFileInfo([VarStruct(u'Translation', [1033, 1200])])
  ]
)

===== FILE PATH =====
./assets\soundpad\forest\theme.yaml
===== FILE CONTENT =====
id: "forest"
name: "Elven Forest"
states:
  normal:
    tracks:
      base: 
        - file: "ambience.wav"
          repeat: 0
      level1: 
        - file: "wind.wav"
          repeat: 0
      level2: 
        - file: "birds.wav"
          repeat: 0
          
  combat:
    tracks:
      base: 
        - file: "drums_low.wav"
          repeat: 0
      level1: 
        - file: "drums_mid.wav"
          repeat: 0
      level2: 
        - file: "orchestra_high.wav"
          repeat: 0


===== FILE PATH =====
./core\api_client.py
===== FILE CONTENT =====
===== FILE PATH =====
./core/api_client.py
===== FILE CONTENT =====
import requests
from config import API_BASE_URL
from core.locales import tr

class DndApiClient:
    def __init__(self):
        self.session = requests.Session()
        self.session.verify = False # Bypass SSL verification for reliability
        self.ENDPOINT_MAP = {
            "NPC": "monsters",
            "Monster": "monsters",
            "Spell": "spells",
            "Equipment": "equipment",
            "Class": "classes",
            "Race": "races",
            "Magic Item": "magic-items"
        }
        # The API base is .../api, but images are at the root
        self.DOMAIN_ROOT = "https://www.dnd5eapi.co"

    def get_list(self, category):
        endpoint = self.ENDPOINT_MAP.get(category)
        if not endpoint:
            if category == "Equipment":
                l1 = self._fetch_all("equipment")
                l2 = self._fetch_all("magic-items")
                return l1 + l2
            return []
        return self._fetch_all(endpoint)

    def _fetch_all(self, endpoint):
        url = f"{API_BASE_URL}/{endpoint}"
        try:
            response = self.session.get(url, timeout=10)
            if response.status_code == 200:
                return response.json().get("results", [])
            return []
        except Exception:
            return []

    def search(self, category, query):
        endpoint = self.ENDPOINT_MAP.get(category)
        if not endpoint: return None, tr("MSG_CAT_NOT_SUPPORTED")

        formatted_query = query.lower().strip().replace(" ", "-")
        url = f"{API_BASE_URL}/{endpoint}/{formatted_query}"
        
        try:
            response = self.session.get(url, timeout=10)
            if response.status_code == 200:
                return self.parse_dispatcher(category, response.json()), tr("MSG_SEARCH_SUCCESS")
            
            if category == "Equipment":
                url2 = f"{API_BASE_URL}/magic-items/{formatted_query}"
                resp2 = self.session.get(url2, timeout=10)
                if resp2.status_code == 200:
                    return self.parse_equipment(resp2.json()), tr("MSG_FOUND_MAGIC_ITEM")

            return None, tr("MSG_SEARCH_NOT_FOUND")
        except Exception as e:
            return None, str(e)

    def download_image_bytes(self, full_url):
        """Downloads image data from the full URL."""
        try:
            response = self.session.get(full_url, timeout=15)
            if response.status_code == 200:
                return response.content
            return None
        except Exception as e:
            print(f"Image download error: {e}")
            return None

    def parse_dispatcher(self, category, data):
        if category in ["Monster", "NPC"]: return self.parse_monster(data)
        elif category == "Spell": return self.parse_spell(data)
        elif category == "Equipment": return self.parse_equipment(data)
        elif category == "Class": return self.parse_class(data)
        elif category == "Race": return self.parse_race(data)
        return {}

    def parse_monster(self, data):
        """
        API'den gelen ham canavar verisini uygulamanÄ±n veri yapÄ±sÄ±na Ã§evirir.
        """
        # 1. AC Parse (ZÄ±rh SÄ±nÄ±fÄ±)
        ac_val = "10"
        raw_ac = data.get("armor_class", [])
        if isinstance(raw_ac, list) and len(raw_ac) > 0:
            ac_entry = raw_ac[0]
            ac_val = f"{ac_entry.get('value', 10)}"
            if ac_entry.get('type'): 
                ac_val += f" ({ac_entry.get('type')})"
        else:
            ac_val = str(data.get("armor_class", 10))

        # 2. HÄ±z Parse
        speed_dict = data.get("speed", {})
        speed_str = ", ".join([f"{k.capitalize()} {v}" for k, v in speed_dict.items()])

        # 3. Saves & Skills Parse
        saves = []
        skills = []
        for prof in data.get("proficiencies", []):
            name = prof.get("proficiency", {}).get("name", "")
            val = prof.get("value", 0)
            sign = "+" if val >= 0 else ""
            
            if "Saving Throw:" in name:
                stat = name.replace("Saving Throw:", "").strip()
                saves.append(f"{stat} {sign}{val}")
            elif "Skill:" in name:
                skill_name = name.replace("Skill:", "").strip()
                skills.append(f"{skill_name} {sign}{val}")

        # 4. Action/Trait Formatlama YardÄ±mcÄ±sÄ±
        def format_actions(action_list):
            formatted = []
            for action in action_list:
                name = action.get("name", "Action")
                desc = action.get("desc", "")
                formatted.append({"name": name, "desc": desc})
            return formatted

        # 5. BÃœYÃœ TESPÄ°TÄ°
        detected_spells = []
        for ability in data.get("special_abilities", []):
            if "spellcasting" in ability:
                spells_list = ability["spellcasting"].get("spells", [])
                for spell_ref in spells_list:
                    url = spell_ref.get("url")
                    if url:
                        index = url.rstrip("/").split("/")[-1]
                        detected_spells.append(index)

        # 6. RESÄ°M URL TESPÄ°TÄ°
        # API returns: "/api/images/monsters/adult-black-dragon.png"
        remote_image_url = ""
        if data.get("image"):
            remote_image_url = self.DOMAIN_ROOT + data.get("image")

        # 7. Veri SÃ¶zlÃ¼ÄŸÃ¼nÃ¼ OluÅŸtur
        return {
            "name": data.get("name"),
            "type": "Monster",
            "description": f"Size: {data.get('size')}, Type: {data.get('type')}, Alignment: {data.get('alignment')}",
            "tags": [data.get("type", ""), data.get("size", "")],
            "image_path": "", # Local path will be filled by DataManager
            
            # Temporary field for DataManager to process download
            "_remote_image_url": remote_image_url,

            # Temel Statlar
            "stats": {
                "STR": data.get("strength", 10),
                "DEX": data.get("dexterity", 10),
                "CON": data.get("constitution", 10),
                "INT": data.get("intelligence", 10),
                "WIS": data.get("wisdom", 10),
                "CHA": data.get("charisma", 10)
            },
            
            # SavaÅŸ StatlarÄ±
            "combat_stats": {
                "hp": str(data.get("hit_points", 10)),
                "max_hp": f"{data.get('hit_points', 10)} ({data.get('hit_dice', '')})",
                "ac": str(ac_val),
                "speed": speed_str,
                "cr": str(data.get("challenge_rating", 0)),
                "xp": str(data.get("xp", 0)),
                "initiative": ""
            },

            # GeliÅŸmiÅŸ Statlar
            "saving_throws": ", ".join(saves),
            "skills": ", ".join(skills),
            "damage_vulnerabilities": ", ".join(data.get("damage_vulnerabilities", [])),
            "damage_resistances": ", ".join(data.get("damage_resistances", [])),
            "damage_immunities": ", ".join(data.get("damage_immunities", [])),
            "condition_immunities": ", ".join([c["name"] if isinstance(c, dict) else c for c in data.get("condition_immunities", [])]),
            "proficiency_bonus": str(data.get("proficiency_bonus", "")),
            "passive_perception": str(data.get("senses", {}).get("passive_perception", "")),

            # Listeler
            "traits": format_actions(data.get("special_abilities", [])),
            "actions": format_actions(data.get("actions", [])),
            "reactions": format_actions(data.get("reactions", [])),
            "legendary_actions": format_actions(data.get("legendary_actions", [])),
            
            # Ek Ã–zellikler
            "attributes": {
                "LBL_CR": str(data.get("challenge_rating", 0)),
                "LBL_ATTACK_TYPE": "Melee / Ranged", 
                "LBL_SENSES": ", ".join([f"{k}: {v}" for k, v in data.get("senses", {}).items() if k != "passive_perception"]),
                "LBL_LANGUAGE": data.get("languages", "-")
            },

            # GEÃ‡Ä°CÄ° ALAN
            "_detected_spell_indices": detected_spells
        }

    # ... (Other parse methods remain the same) ...
    def parse_spell(self, data):
        # ... (Existing content) ...
        desc = "\n".join(data.get("desc", []))
        if data.get("higher_level"):
            desc += "\n\n**Higher Levels:** " + "\n".join(data.get("higher_level", []))
        
        # Components
        comps = data.get("components", [])
        comp_str = ", ".join(comps)
        if "M" in comps and data.get("material"):
            comp_str += f" ({data.get('material')})"

        # Damage
        dmg_str = ""
        dmg = data.get("damage", {})
        if dmg.get("damage_type"):
            dmg_str = f"Type: {dmg['damage_type'].get('name')}"
        
        if dmg.get("damage_at_slot_level"):
            levels = [f"Lvl {k}: {v}" for k,v in dmg["damage_at_slot_level"].items()]
            dmg_str += " | " + ", ".join(levels[:3]) + ("..." if len(levels)>3 else "")

        classes = [c["name"] for c in data.get("classes", [])]
        
        return {
            "name": data.get("name"),
            "type": "Spell",
            "description": desc,
            "tags": classes + [f"Level {data.get('level')}", data.get("school", {}).get("name", "")],
            "attributes": {
                "LBL_LEVEL": str(data.get("level")),
                "LBL_SCHOOL": data.get("school", {}).get("name", ""),
                "LBL_CASTING_TIME": data.get("casting_time", ""),
                "LBL_RANGE": data.get("range", ""),
                "LBL_COMPONENTS": comp_str,
                "LBL_DURATION": ("Concentration, " if data.get("concentration") else "") + data.get("duration", ""),
                "LBL_RITUAL": "LBL_YES" if data.get("ritual") else "LBL_NO",
                "LBL_DAMAGE": dmg_str
            }
        }
    
    def parse_equipment(self, data):
        # ... (Same as your previous file, no changes needed here) ...
        desc_list = data.get("desc", [])
        description = "\n".join(desc_list) if isinstance(desc_list, list) else str(desc_list)
        cat_main = data.get("equipment_category", {}).get("name", tr("LBL_GENERAL_CAT"))
        sub_cats = []
        if data.get("weapon_category"): sub_cats.append(data["weapon_category"])
        if data.get("armor_category"): sub_cats.append(data["armor_category"])
        if data.get("vehicle_category"): sub_cats.append(data["vehicle_category"])
        if data.get("tool_category"): sub_cats.append(data["tool_category"])
        if data.get("gear_category"): 
            gc = data["gear_category"]
            sub_cats.append(gc.get("name") if isinstance(gc, dict) else str(gc))
        if data.get("category_range"): sub_cats.append(data["category_range"])
        full_sub_cat = ", ".join([s for s in sub_cats if s])
        final_category = f"{cat_main} ({full_sub_cat})" if full_sub_cat else cat_main
        tags = [cat_main] + sub_cats
        cost_str = "-"
        if data.get("cost"):
            q = data["cost"].get("quantity", 0)
            u = data["cost"].get("unit", "gp")
            cost_str = f"{q} {u}"
        damage_dice = ""
        damage_type = ""
        if data.get("damage"):
            damage_dice = data["damage"].get("damage_dice", "")
            if data["damage"].get("damage_type"):
                damage_type = data["damage"]["damage_type"].get("name", "")
        if data.get("two_handed_damage"):
            th_dice = data["two_handed_damage"].get("damage_dice")
            if th_dice:
                damage_dice += f" (2H: {th_dice})"
        range_str = ""
        if data.get("range"):
            norm = data["range"].get("normal")
            long = data["range"].get("long")
            if norm:
                range_str = f"{norm} ft."
                if long: range_str += f" / {long} ft."
        ac_str = ""
        if data.get("armor_class"):
            ac_data = data["armor_class"]
            if isinstance(ac_data, dict):
                base = ac_data.get("base", 10)
                dex = ac_data.get("dex_bonus", False)
                max_bonus = ac_data.get("max_bonus")
                ac_str = str(base)
                if dex:
                    ac_str += " + Dex"
                    if max_bonus: ac_str += f" (max {max_bonus})"
            else:
                ac_str = str(ac_data)
        reqs = []
        if data.get("str_minimum") and int(data.get("str_minimum", 0)) > 0:
            reqs.append(f"Min Str {data['str_minimum']}")
        if data.get("stealth_disadvantage"):
            reqs.append("Stealth Disadv.")
        req_str = ", ".join(reqs)
        props = [p.get("name", "") for p in data.get("properties", [])]
        if data.get("speed"):
            s = data["speed"]
            val = f"{s.get('quantity')} {s.get('unit')}" if isinstance(s, dict) else s
            props.append(f"{tr('LBL_PROP_SPEED')}: {val}")
        if data.get("capacity"):
            props.append(f"{tr('LBL_PROP_CAPACITY')}: {data['capacity']}")
        prop_str = ", ".join(props)
        rarity = ""
        if data.get("rarity"):
            rarity = data["rarity"].get("name", "")
        attunement = tr("LBL_NO_ATTUNEMENT")
        if "requires attunement" in description.lower():
            attunement = tr("LBL_REQ_ATTUNEMENT")
        return {
            "name": data.get("name"),
            "type": "Equipment",
            "description": description,
            "tags": tags,
            "attributes": {
                "LBL_CATEGORY": final_category,
                "LBL_RARITY": rarity,
                "LBL_ATTUNEMENT": attunement,
                "LBL_COST": cost_str,
                "LBL_WEIGHT": f"{data.get('weight', 0)} lb.",
                "LBL_DAMAGE_DICE": damage_dice,
                "LBL_DAMAGE_TYPE": damage_type,
                "LBL_RANGE": range_str,
                "LBL_AC": ac_str,
                "LBL_REQUIREMENTS": req_str,
                "LBL_PROPERTIES": prop_str
            }
        }

    def parse_class(self, data):
        return {"name": data.get("name"), "type": "Class", "description": f"Hit Die: d{data.get('hit_die')}", "attributes": {"LBL_HIT_DIE": f"d{data.get('hit_die')}"}}

    def parse_race(self, data):
        return {"name": data.get("name"), "type": "Irk (Race)", "description": f"Speed: {data.get('speed')}", "attributes": {"HÄ±z": str(data.get("speed"))}}

===== FILE PATH =====
./core\data_manager.py
===== FILE CONTENT =====
===== FILE PATH =====
./core/data_manager.py
===== FILE CONTENT =====
import os
import json
import shutil
import uuid
from config import WORLDS_DIR, BASE_DIR, CACHE_DIR, load_theme
from core.models import get_default_entity_structure, SCHEMA_MAP, PROPERTY_MAP, ENTITY_SCHEMAS
from core.api_client import DndApiClient
from core.locales import set_language

LIBRARY_DIR = os.path.join(CACHE_DIR, "library")
CACHE_FILE = os.path.join(CACHE_DIR, "reference_indexes.json")

class DataManager:
    def __init__(self):
        self.settings = self.load_settings()
        set_language(self.settings.get("language", "EN"))
        self.current_theme = self.settings.get("theme", "dark")
        
        self.current_campaign_path = None
        
        self.data = {
            "world_name": "", 
            "entities": {}, 
            "map_data": {"image_path": "", "pins": []},
            "sessions": [],
            "last_active_session_id": None
        }
        self.api_client = DndApiClient()
        self.reference_cache = {}
        
        if not os.path.exists(WORLDS_DIR): os.makedirs(WORLDS_DIR)
        
        # Cache'i yÃ¼kle
        self.reload_library_cache()

    def reload_library_cache(self):
        """KÃ¼tÃ¼phane indeksini diskten tekrar okur."""
        if not os.path.exists(CACHE_DIR): os.makedirs(CACHE_DIR)
        if os.path.exists(CACHE_FILE):
            try:
                with open(CACHE_FILE, "r", encoding="utf-8") as f: 
                    self.reference_cache = json.load(f)
            except: 
                self.reference_cache = {}
        else: 
            self.reference_cache = {}

    def _save_reference_cache(self):
        if not os.path.exists(CACHE_DIR): os.makedirs(CACHE_DIR)
        with open(CACHE_FILE, "w", encoding="utf-8") as f: 
            json.dump(self.reference_cache, f, indent=4)

    # --- AYARLAR ---
    def load_settings(self):
        path = os.path.join(CACHE_DIR, "settings.json")
        if os.path.exists(path):
            try:
                with open(path, "r", encoding="utf-8") as f: return json.load(f)
            except: pass
        return {"language": "EN", "theme": "dark"}

    def save_settings(self, settings):
        path = os.path.join(CACHE_DIR, "settings.json")
        if not os.path.exists(CACHE_DIR): os.makedirs(CACHE_DIR)
        
        new_settings = self.settings.copy()
        new_settings.update(settings)
        
        with open(path, "w", encoding="utf-8") as f: json.dump(new_settings, f, indent=4)
        self.settings = new_settings
        set_language(new_settings.get("language", "EN"))
        self.current_theme = new_settings.get("theme", "dark")

    def get_api_index(self, category):
        if category in self.reference_cache: return self.reference_cache[category]
        data = self.api_client.get_list(category)
        if data:
            self.reference_cache[category] = data
            self._save_reference_cache()
            return data
        return []

    # --- KAMPANYA YÃ–NETÄ°MÄ° ---
    def get_available_campaigns(self):
        if not os.path.exists(WORLDS_DIR): return []
        return [d for d in os.listdir(WORLDS_DIR) if os.path.isdir(os.path.join(WORLDS_DIR, d))]

    def load_campaign_by_name(self, name):
        return self.load_campaign(os.path.join(WORLDS_DIR, name))

    def load_campaign(self, folder):
        path = os.path.join(folder, "data.json")
        if not os.path.exists(path): return False, "Dosya yok"
        try:
            with open(path, "r", encoding="utf-8") as f: self.data = json.load(f)
            
            if "sessions" not in self.data: self.data["sessions"] = []
            if "entities" not in self.data: self.data["entities"] = {}
            if "map_data" not in self.data: self.data["map_data"] = {"image_path": "", "pins": []}
            if "last_active_session_id" not in self.data: self.data["last_active_session_id"] = None
            
            if not self.data["sessions"]:
                new_sid = str(uuid.uuid4())
                default_session = {
                    "id": new_sid, "name": "Default Session", "date": "BugÃ¼n", 
                    "notes": "", "logs": "", "combatants": []
                }
                self.data["sessions"].append(default_session)
                self.data["last_active_session_id"] = new_sid
            
            if not self.data["last_active_session_id"] and self.data["sessions"]:
                self.data["last_active_session_id"] = self.data["sessions"][-1]["id"]

            # Migration Logic
            for eid, ent in self.data["entities"].items():
                old_type = ent.get("type", "NPC")
                if old_type in SCHEMA_MAP: ent["type"] = SCHEMA_MAP[old_type]
                
                attrs = ent.get("attributes", {})
                new_attrs = {}
                for k, v in attrs.items():
                    new_key = PROPERTY_MAP.get(k, k)
                    new_attrs[new_key] = v
                ent["attributes"] = new_attrs

                default = get_default_entity_structure(ent.get("type", "NPC"))
                for key, val in default.items():
                    if key not in ent: ent[key] = val
                
                if not ent.get("images") and ent.get("image_path"):
                    ent["images"] = [ent["image_path"]]

            self.current_campaign_path = folder
            self.save_data()
            return True, "YÃ¼klendi"
        except Exception as e: return False, str(e)

    def create_campaign(self, world_name):
        folder = os.path.join(WORLDS_DIR, world_name)
        try:
            if not os.path.exists(folder): os.makedirs(folder)
            if not os.path.exists(os.path.join(folder, "assets")): os.makedirs(os.path.join(folder, "assets"))
            
            first_sid = str(uuid.uuid4())
            self.data = {
                "world_name": world_name, "entities": {}, 
                "map_data": {"image_path": "", "pins": []},
                "sessions": [{"id": first_sid, "name": "Session 0", "date": "BugÃ¼n", "notes": "", "logs": "", "combatants": []}],
                "last_active_session_id": first_sid
            }
            self.current_campaign_path = folder
            self.save_data()
            return True, "OluÅŸturuldu"
        except Exception as e: return False, str(e)

    def save_data(self):
        if self.current_campaign_path:
            with open(os.path.join(self.current_campaign_path, "data.json"), "w", encoding="utf-8") as f:
                json.dump(self.data, f, indent=4, ensure_ascii=False)

    # --- SESSION YÃ–NETÄ°MÄ° ---
    def create_session(self, name):
        session_id = str(uuid.uuid4())
        new_session = {"id": session_id, "name": name, "date": "BugÃ¼n", "notes": "", "logs": "", "combatants": []}
        if "sessions" not in self.data: self.data["sessions"] = []
        self.data["sessions"].append(new_session)
        self.set_active_session(session_id)
        self.save_data()
        return session_id

    def get_session(self, session_id):
        if "sessions" not in self.data: return None
        for s in self.data["sessions"]:
            if s["id"] == session_id: return s
        return None

    def save_session_data(self, session_id, notes, logs, combatants):
        if "sessions" not in self.data: return
        for s in self.data["sessions"]:
            if s["id"] == session_id:
                s["notes"] = notes; s["logs"] = logs; s["combatants"] = combatants
                self.set_active_session(session_id)
                self.save_data()
                break

    def set_active_session(self, session_id):
        self.data["last_active_session_id"] = session_id
        
    def get_last_active_session_id(self):
        return self.data.get("last_active_session_id")

    # --- VARLIK YÃ–NETÄ°MÄ° ---
    def save_entity(self, eid, data):
        if not eid: eid = str(uuid.uuid4())
        if eid in self.data["entities"]: self.data["entities"][eid].update(data)
        else: self.data["entities"][eid] = data
        self.save_data()
        return eid

    def delete_entity(self, eid):
        if eid in self.data["entities"]:
            del self.data["entities"][eid]
            self.save_data()

    def fetch_from_api(self, category, query):
        for eid, ent in self.data["entities"].items():
            if ent["name"].lower() == query.lower() and ent["type"] == category:
                return True, "VeritabanÄ±nda zaten var.", eid
        
        parsed_data, msg = self.api_client.search(category, query)
        if not parsed_data: return False, msg, None
        
        if category in ["Monster", "NPC"] and isinstance(parsed_data, dict):
            parsed_data = self._resolve_dependencies(parsed_data)
            
        return True, "API'den Ã§ekildi.", parsed_data

    def fetch_details_from_api(self, category, index_name):
        folder_map = {
            "Monster": "monsters", "Spell": "spells", 
            "Equipment": "equipment", "Class": "classes", "Race": "races"
        }
        folder = folder_map.get(category)
        
        if folder:
            paths = [os.path.join(LIBRARY_DIR, folder, f"{index_name}.json")]
            if category == "EÅŸya (Equipment)" or category == "Equipment":
                paths.append(os.path.join(LIBRARY_DIR, "magic-items", f"{index_name}.json"))
            
            for local_path in paths:
                if os.path.exists(local_path):
                    try:
                        with open(local_path, "r", encoding="utf-8") as f:
                            raw = json.load(f)
                            return True, self.api_client.parse_dispatcher(category, raw)
                    except Exception as e: 
                        print(f"Cache okuma hatasÄ± ({category}/{index_name}): {e}")

        parsed_data, msg = self.api_client.search(category, index_name)
        if parsed_data: return True, parsed_data
        return False, msg

    def import_entity_with_dependencies(self, data, type_override=None):
        if type_override: data["type"] = type_override
        # Resolve dependencies also handles image downloading now
        data = self._resolve_dependencies(data)
        return self.save_entity(None, data)

    def _resolve_dependencies(self, data):
        if not isinstance(data, dict): return data
        
        # --- NEW: HANDLE IMAGE DOWNLOAD ---
        remote_url = data.pop("_remote_image_url", None)
        if remote_url and self.current_campaign_path:
            try:
                # Create a filename based on name
                safe_name = "".join([c for c in data.get("name", "image") if c.isalnum() or c in (' ','-','_')]).strip().replace(' ', '_')
                filename = f"{safe_name}_{uuid.uuid4().hex[:6]}.png" # Assume PNG or check ext
                
                # Check for extension in URL
                if remote_url.lower().endswith(".jpg"): filename = filename.replace(".png", ".jpg")
                elif remote_url.lower().endswith(".jpeg"): filename = filename.replace(".png", ".jpeg")
                
                # Download
                img_data = self.api_client.download_image_bytes(remote_url)
                if img_data:
                    assets_dir = os.path.join(self.current_campaign_path, "assets")
                    if not os.path.exists(assets_dir): os.makedirs(assets_dir)
                    
                    full_path = os.path.join(assets_dir, filename)
                    with open(full_path, "wb") as f:
                        f.write(img_data)
                    
                    # Update Entity Data
                    rel_path = os.path.join("assets", filename)
                    data["image_path"] = rel_path
                    data["images"] = [rel_path]
            except Exception as e:
                print(f"Error downloading image: {e}")
        # ----------------------------------

        detected_spells = data.pop("_detected_spell_indices", [])
        if not detected_spells: return data
        
        linked_spell_ids = []
        for spell_index in detected_spells:
            success, spell_data = self.fetch_details_from_api("Spell", spell_index)
            if success:
                spell_name = spell_data.get("name")
                existing_id = None
                
                for eid, ent in self.data["entities"].items():
                    if ent.get("type") == "Spell" and ent.get("name") == spell_name:
                        existing_id = eid
                        break
                
                if existing_id: linked_spell_ids.append(existing_id)
                else:
                    new_id = self.save_entity(None, spell_data)
                    linked_spell_ids.append(new_id)

        if linked_spell_ids:
            if "spells" not in data: data["spells"] = []
            for sid in linked_spell_ids:
                if sid not in data["spells"]: data["spells"].append(sid)
        
        return data

    # --- HARÄ°TA & RESÄ°M ---
    def import_image(self, src):
        if not self.current_campaign_path: return None
        fname = f"{uuid.uuid4().hex}_{os.path.basename(src)}"
        dest = os.path.join(self.current_campaign_path, "assets", fname)
        shutil.copy2(src, dest)
        return os.path.join("assets", fname)

    def import_pdf(self, src):
        if not self.current_campaign_path: return None
        fname = f"{uuid.uuid4().hex}_{os.path.basename(src)}"
        dest = os.path.join(self.current_campaign_path, "assets", fname)
        shutil.copy2(src, dest)
        return os.path.join("assets", fname)

    def get_full_path(self, rel):
        return os.path.join(self.current_campaign_path, rel) if self.current_campaign_path and rel else None
    
    def set_map_image(self, rel): self.data["map_data"]["image_path"] = rel; self.save_data()
    def add_pin(self, x, y, eid): self.data["map_data"]["pins"].append({"id": str(uuid.uuid4()), "x": x, "y": y, "entity_id": eid}); self.save_data()
    def move_pin(self, pid, x, y):
        for p in self.data["map_data"]["pins"]:
             if p.get("id") == pid: p["x"]=x; p["y"]=y; break
        self.save_data()
    def remove_specific_pin(self, pid):
        self.data["map_data"]["pins"] = [p for p in self.data["map_data"]["pins"] if p.get("id") != pid]
        self.save_data()

    def search_in_library(self, category, search_text):
        results = []
        search_text = search_text.lower()
        cats = [category] if category in self.reference_cache else list(self.reference_cache.keys())
        
        for c in cats:
            for item in self.reference_cache.get(c, []):
                if len(search_text) < 2 or search_text in item["name"].lower():
                    results.append({
                        "id": f"lib_{c}_{item['index']}", 
                        "name": item["name"], 
                        "type": c, 
                        "is_library": True,
                        "index": item["index"]
                    })
        return results

===== FILE PATH =====
./core\locales.py
===== FILE CONTENT =====
import i18n
import os

# Localization Configuration
from config import BASE_DIR
LOCALES_DIR = os.path.join(BASE_DIR, "locales")

i18n.load_path.append(LOCALES_DIR)
i18n.set("file_format", "yml")
i18n.set("filename_format", "{locale}.{format}")
i18n.set("fallback", "en")

def set_language(lang_code):
    """Sets the current language."""
    if lang_code.upper() == "TR":
        i18n.set("locale", "tr")
    else:
        i18n.set("locale", "en")

def tr(key, **kwargs):
    """Returns the translated string for the given key."""
    # i18n.t expects key like 'en.BTN_SAVE' if we don't specify namespace
    # but with our setup it might just be 'BTN_SAVE' if it's in the default file
    # for the current locale.
    return i18n.t(key, **kwargs)


===== FILE PATH =====
./core\models.py
===== FILE CONTENT =====
ENTITY_SCHEMAS = {
    "NPC": [
        ("LBL_RACE", "text", None),
        ("LBL_CLASS", "text", None),
        ("LBL_LEVEL", "text", None), 
        ("LBL_ATTITUDE", "combo", ["LBL_ATTR_FRIENDLY", "LBL_ATTR_NEUTRAL", "LBL_ATTR_HOSTILE"]),
        ("LBL_ATTR_LOCATION", "text", None)
    ],
    "Monster": [
        ("LBL_CR", "text", None),
        ("LBL_ATTACK_TYPE", "text", None)
    ],
    "Spell": [
        ("LBL_LEVEL", "combo", ["Cantrip", "1", "2", "3", "4", "5", "6", "7", "8", "9"]),
        ("LBL_SCHOOL", "text", None),
        ("LBL_CASTING_TIME", "text", None),
        ("LBL_RANGE", "text", None),
        ("LBL_DURATION", "text", None),
        ("LBL_COMPONENTS", "text", None)
    ],
    "Equipment": [
        ("LBL_CATEGORY", "text", None),
        ("LBL_RARITY", "text", None),
        ("LBL_ATTUNEMENT", "text", None),
        ("LBL_COST", "text", None),
        ("LBL_WEIGHT", "text", None),
        ("LBL_DAMAGE_DICE", "text", None),
        ("LBL_DAMAGE_TYPE", "text", None),
        ("LBL_RANGE", "text", None),
        ("LBL_AC", "text", None),
        ("LBL_REQUIREMENTS", "text", None),
        ("LBL_PROPERTIES", "text", None)
    ],
    "Class": [
        ("LBL_HIT_DIE", "text", None), 
        ("LBL_MAIN_STATS", "text", None), 
        ("LBL_PROFICIENCIES", "text", None)
    ],
    "Race": [
        ("LBL_SPEED", "text", None), 
        ("LBL_SIZE", "combo", ["Small", "Medium", "Large"]), 
        ("LBL_ALIGNMENT", "text", None), 
        ("LBL_LANGUAGE", "text", None)
    ],
    "Location": [
        ("LBL_DANGER_LEVEL", "combo", ["LBL_DANGER_SAFE", "LBL_DANGER_LOW", "LBL_DANGER_MEDIUM", "LBL_DANGER_HIGH"]), 
        ("LBL_ENVIRONMENT", "text", None)
    ],
    "Player": [
        ("LBL_CLASS", "text", None), 
        ("LBL_RACE", "text", None), 
        ("LBL_LEVEL", "text", None)
    ],
    "Quest": [
        ("LBL_STATUS", "combo", ["LBL_STATUS_NOT_STARTED", "LBL_STATUS_ACTIVE", "LBL_STATUS_COMPLETED"]), 
        ("LBL_GIVER", "text", None), 
        ("LBL_REWARD", "text", None)
    ],
    "Lore": [
        ("LBL_CATEGORY", "combo", ["LBL_LORE_HISTORY", "LBL_LORE_GEOGRAPHY", "LBL_LORE_RELIGION", "LBL_LORE_CULTURE", "LBL_LORE_OTHER"]), 
        ("LBL_SECRET_INFO", "text", None)
    ],
    "Status Effect": [
        ("LBL_DURATION_TURNS", "text", None),  # Tur SÃ¼resi (Ã–rn: 3 Rounds)
        ("LBL_EFFECT_TYPE", "combo", ["LBL_TYPE_BUFF", "LBL_TYPE_DEBUFF", "LBL_TYPE_CONDITION"])
    ]
}

# Mapping for legacy data compatibility (TR -> EN)
SCHEMA_MAP = {
    "Canavar": "Monster",
    "BÃ¼yÃ¼ (Spell)": "Spell",
    "EÅŸya (Equipment)": "Equipment",
    "SÄ±nÄ±f (Class)": "Class",
    "Irk (Race)": "Race",
    "Mekan": "Location",
    "Oyuncu": "Player",
    "GÃ¶rev": "Quest",
    "Lore": "Lore",
    "Durum Etkisi": "Status Effect"
}

# Mapping for legacy property labels compatibility
PROPERTY_MAP = {
    "Irk": "LBL_RACE",
    "SÄ±nÄ±f": "LBL_CLASS",
    "Seviye": "LBL_LEVEL",
    "TavÄ±r": "LBL_ATTITUDE",
    "Konum": "LBL_ATTR_LOCATION",
    "Challenge Rating (CR)": "LBL_CR",
    "SaldÄ±rÄ± Tipi": "LBL_ATTACK_TYPE",
    "Okul (School)": "LBL_SCHOOL",
    "SÃ¼re (Casting Time)": "LBL_CASTING_TIME",
    "Menzil (Range)": "LBL_RANGE",
    "Menzil": "LBL_RANGE",
    "SÃ¼reklilik (Duration)": "LBL_DURATION",
    "BileÅŸenler (Components)": "LBL_COMPONENTS",
    "Kategori": "LBL_CATEGORY",
    "Nadirik (Rarity)": "LBL_RARITY",
    "Uyumlanma (Attunement)": "LBL_ATTUNEMENT",
    "Maliyet": "LBL_COST",
    "AÄŸÄ±rlÄ±k": "LBL_WEIGHT",
    "Hasar ZarÄ±": "LBL_DAMAGE_DICE",
    "Hasar Tipi": "LBL_DAMAGE_TYPE",
    "ZÄ±rh SÄ±nÄ±fÄ± (AC)": "LBL_AC",
    "Gereksinimler": "LBL_REQUIREMENTS",
    "Ã–zellikler": "LBL_PROPERTIES",
    "Hit Die": "LBL_HIT_DIE",
    "Ana Statlar": "LBL_MAIN_STATS",
    "ZÄ±rh/Silah Yetkinlikleri": "LBL_PROFICIENCIES",
    "HÄ±z": "LBL_SPEED",
    "Boyut": "LBL_SIZE",
    "Hizalanma EÄŸilimi": "LBL_ALIGNMENT",
    "Dil": "LBL_LANGUAGE",
    "Tehlike Seviyesi": "LBL_DANGER_LEVEL",
    "Ortam": "LBL_ENVIRONMENT",
    "Durum": "LBL_STATUS",
    "GÃ¶revi Veren": "LBL_GIVER",
    "Ã–dÃ¼l": "LBL_REWARD",
    "Gizli Bilgi": "LBL_SECRET_INFO",
    "SÃ¼re (Tur)": "LBL_DURATION_TURNS",
    "Etki Tipi": "LBL_EFFECT_TYPE"
}

def get_default_entity_structure(entity_type="NPC"):
    return {
        "name": "Yeni KayÄ±t",
        "type": entity_type,
        "description": "",
        "images": [], # YENÄ°: Ã‡oklu resim desteÄŸi
        "image_path": "", # Geriye dÃ¶nÃ¼k uyumluluk iÃ§in (varsa ilk resim buraya da yazÄ±lÄ±r)
        "tags": [],
        "attributes": {},
        "stats": {"STR": 10, "DEX": 10, "CON": 10, "INT": 10, "WIS": 10, "CHA": 10},
        "combat_stats": {"hp": "", "max_hp": "", "ac": "", "speed": "", "cr": "", "xp": "", "initiative": ""},
        
        # --- LÄ°STELER ---
        "traits": [],
        "actions": [],
        "reactions": [],
        "legendary_actions": [],
        
        # BÃ¼yÃ¼ler
        "spells": [],             # ID Listesi (Linked)
        "custom_spells": [],      # Manuel Kartlar
        
        # Envanter (YENÄ°LENEN KISIM)
        "equipment_ids": [],      # YENÄ°: ID Listesi (Linked Items)
        "inventory": [],          # Manuel Kartlar (Mevcut yapÄ±)
        
        "pdfs": [],               # PDF DosyalarÄ±
        "location_id": None,

        # --- GeliÅŸmiÅŸ Statlar (NPC/Canavar iÃ§in) ---
        "saving_throws": "",
        "damage_vulnerabilities": "",
        "damage_resistances": "",
        "damage_immunities": "",
        "condition_immunities": "",
        "proficiency_bonus": "",
        "passive_perception": "",
        "skills": ""
    }

===== FILE PATH =====
./core\audio\engine.py
===== FILE CONTENT =====
import os
from PyQt6.QtMultimedia import QMediaPlayer, QAudioOutput
from PyQt6.QtCore import QUrl, QObject, pyqtSignal, QPropertyAnimation, QEasingCurve, pyqtProperty
from typing import Dict, List
from .models import Theme, MusicState, Track

class TrackPlayer(QObject):
    """
    Tek bir izi (Track) yÃ¶neten oynatÄ±cÄ±.
    """
    loop_finished = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.player = QMediaPlayer()
        self.audio = QAudioOutput()
        self.player.setAudioOutput(self.audio)
        
        self._volume = 0.0 
        self.audio.setVolume(0.0)
        
        self.anim = QPropertyAnimation(self, b"volume")
        self.anim.setDuration(2000)
        self.anim.setEasingCurve(QEasingCurve.Type.InOutQuad)

        self.player.mediaStatusChanged.connect(self._on_media_status)

    @pyqtProperty(float)
    def volume(self): return self._volume
    
    @volume.setter
    def volume(self, val):
        self._volume = val
        self.audio.setVolume(val)

    def load_track(self, track: Track):
        if not track.sequence: return
        node = track.sequence[0]
        
        if os.path.exists(node.file_path):
            self.player.setSource(QUrl.fromLocalFile(os.path.abspath(node.file_path)))
            
            # --- LOOP STRATEJÄ°SÄ° ---
            # Pocket Bard tarzÄ± iÃ§in Infinite Loop en iyisidir.
            # Ancak 'loop_finished' sinyalini almak iÃ§in (Queue mantÄ±ÄŸÄ± iÃ§in)
            # manuel loop kontrolÃ¼ bazen daha iyi olabilir.
            # Gapless iÃ§in Infinite kullanÄ±yoruz, ancak Infinite modunda EndOfMedia sinyali GELMEZ.
            # Bu yÃ¼zden Queue mantÄ±ÄŸÄ± iÃ§in QMediaPlayer.Loops.One kullanÄ±p
            # sinyal gelince kendimiz tekrar play() diyeceÄŸiz.
            # WAV kullanÄ±lÄ±yorsa bu yÃ¶ntem de neredeyse gapless'tÄ±r.
            self.player.setLoops(QMediaPlayer.Loops.Once) 
        else:
            print(f"âš ï¸ Dosya Yok: {node.file_path}")

    def play(self):
        if self.player.source().isValid():
            self.player.play()

    def stop(self):
        self.player.stop()
    
    def fade_to(self, target, duration=1500):
        if self.anim.state() == QPropertyAnimation.State.Running:
            self.anim.stop()
        self.anim.setDuration(duration)
        self.anim.setStartValue(self._volume)
        self.anim.setEndValue(target)
        self.anim.start()

    def _on_media_status(self, status):
        if status == QMediaPlayer.MediaStatus.EndOfMedia:
            # Sinyal gÃ¶nder (Bu sinyal yukarÄ±da MusicBrain tarafÄ±ndan yakalanÄ±p geÃ§iÅŸi tetikleyecek)
            self.loop_finished.emit()
            
            # Tekrar oynat (Loop)
            self.play()

class MultiTrackDeck(QObject):
    """
    Bir 'State'i (Normal, Combat) yÃ¶netir.
    TrackPlayer'larÄ± senkronize baÅŸlatÄ±r.
    """
    loop_finished = pyqtSignal() # Ana loop bittiÄŸinde sinyal verir

    def __init__(self, parent=None):
        super().__init__(parent)
        self.players: Dict[str, TrackPlayer] = {} 
        self.master_volume = 0.0 
        self.active_levels = ["base"]

    @pyqtProperty(float)
    def deck_volume(self): return self.master_volume
    @deck_volume.setter
    def deck_volume(self, val):
        self.master_volume = val
        self.update_mix()

    def load_state(self, state: MusicState):
        for p in self.players.values():
            p.stop(); p.deleteLater()
        self.players.clear()

        for track_id, track_data in state.tracks.items():
            tp = TrackPlayer(self)
            tp.load_track(track_data)
            self.players[track_id] = tp
            
        # Sinyal BaÄŸlantÄ±sÄ±: Sadece 'base' kanalÄ±nÄ±n bitiÅŸini dinle (Senkronizasyon lideri)
        if "base" in self.players:
            self.players["base"].loop_finished.connect(self.loop_finished.emit)
        elif self.players:
            # Base yoksa herhangi birini dinle
            list(self.players.values())[0].loop_finished.connect(self.loop_finished.emit)

    def play(self):
        for p in self.players.values():
            p.volume = 0.0 
            p.play()
        self.update_mix()

    def stop(self):
        for p in self.players.values(): p.stop()

    def set_intensity_mask(self, levels: List[str]):
        self.active_levels = levels
        self.update_mix()

    def update_mix(self):
        for pid, player in self.players.items():
            is_active = pid in self.active_levels
            target = self.master_volume if is_active else 0.0
            player.fade_to(target, duration=1500)

class MusicBrain(QObject):
    """
    Ä°ki MultiTrackDeck arasÄ±nda State geÃ§iÅŸi yapar.
    """
    state_changed = pyqtSignal(str) # UI GÃ¼ncellemesi Ä°Ã§in

    def __init__(self):
        super().__init__()
        
        self._fade_ratio = 1.0 
        self.global_volume = 0.5
        
        self.deck_a = MultiTrackDeck(self)
        self.deck_b = MultiTrackDeck(self)
        
        # Sinyalleri baÄŸla (Loop bitince kontrol et)
        self.deck_a.loop_finished.connect(self._check_queue)
        self.deck_b.loop_finished.connect(self._check_queue)
        
        self.active_deck = self.deck_a
        self.inactive_deck = self.deck_b
        
        self.anim = QPropertyAnimation(self, b"fade_ratio")
        self.anim.setDuration(2000)
        
        self.current_theme: Theme = None
        self.current_state_id = None
        self.pending_state_id = None # Bekleyen geÃ§iÅŸ
        self.current_intensity_level = 0

    @pyqtProperty(float)
    def fade_ratio(self): return self._fade_ratio
    @fade_ratio.setter
    def fade_ratio(self, val):
        self._fade_ratio = val
        self.active_deck.deck_volume = self.global_volume * val
        self.inactive_deck.deck_volume = self.global_volume * (1.0 - val)

    def set_theme(self, theme: Theme):
        self.current_theme = theme
        self.pending_state_id = None
        start_state = "normal" if "normal" in theme.states else list(theme.states.keys())[0]
        self._hard_switch(start_state)

    # --- YENÄ° EKLENEN KUYRUK MANTIÄžI ---
    def queue_state(self, state_name):
        """SÄ±radaki loop bitince geÃ§ilecek."""
        if state_name == self.current_state_id: return
        self.pending_state_id = state_name
        print(f"â³ KuyruÄŸa AlÄ±ndÄ±: {state_name}")

    def force_transition(self):
        """Beklemeyi iptal et ve hemen geÃ§."""
        if self.pending_state_id:
            print(f"ðŸš€ Zorla GeÃ§iÅŸ: {self.pending_state_id}")
            self.set_state(self.pending_state_id)
            self.pending_state_id = None

    def _check_queue(self):
        """Loop bittiÄŸinde Ã§aÄŸrÄ±lÄ±r."""
        if self.pending_state_id:
            print("âœ… Loop bitti, otomatik geÃ§iÅŸ.")
            self.set_state(self.pending_state_id)
            self.pending_state_id = None
    # -----------------------------------

    def set_state(self, state_name: str):
        if not self.current_theme or state_name not in self.current_theme.states: return
        if state_name == self.current_state_id: return
        
        print(f"ðŸ”„ State Change: {state_name}")
        target_state = self.current_theme.states[state_name]
        
        # 1. HazÄ±rla
        self.inactive_deck.load_state(target_state)
        self.inactive_deck.set_intensity_mask(self._get_mask_for_level(self.current_intensity_level))
        self.inactive_deck.deck_volume = 0.0
        self.inactive_deck.play()
        
        # 2. DeÄŸiÅŸtir
        old_active = self.active_deck
        self.active_deck = self.inactive_deck
        self.inactive_deck = old_active
        self.current_state_id = state_name
        
        # 3. Cross-Fade
        self.anim.stop()
        self.anim.setStartValue(0.0)
        self.anim.setEndValue(1.0)
        self.anim.start()
        
        self.state_changed.emit(state_name)

    def set_intensity(self, level: int):
        self.current_intensity_level = level
        mask = self._get_mask_for_level(level)
        print(f"ðŸŽšï¸ Intensity: {level} -> {mask}")
        self.active_deck.set_intensity_mask(mask)
        self.inactive_deck.set_intensity_mask(mask)

    def _get_mask_for_level(self, level):
        active = ["base"]
        if level >= 1: active.append("level1")
        if level >= 2: active.append("level2")
        if level >= 3: active.append("level3")
        return active

    def _hard_switch(self, state_name):
        if not self.current_theme: return
        state = self.current_theme.states.get(state_name)
        if not state: return
        
        self.active_deck.stop()
        self.inactive_deck.stop()
        
        self.active_deck.load_state(state)
        self.active_deck.set_intensity_mask(self._get_mask_for_level(self.current_intensity_level))
        self.active_deck.deck_volume = self.global_volume
        self.active_deck.play()
        
        self._fade_ratio = 1.0
        self.current_state_id = state_name
        self.state_changed.emit(state_name)

    def set_volume(self, val):
        self.global_volume = val
        self.active_deck.deck_volume = val * self._fade_ratio
        self.inactive_deck.deck_volume = val * (1.0 - self._fade_ratio)

    def stop(self):
        self.pending_state_id = None
        self.active_deck.stop()
        self.inactive_deck.stop()

===== FILE PATH =====
./core\audio\loader.py
===== FILE CONTENT =====
import os
import yaml
from .models import Theme, MusicState, Track, LoopNode
from config import BASE_DIR

SOUNDPAD_ROOT = os.path.join(BASE_DIR, "assets", "soundpad")

def load_all_themes():
    themes = {}
    if not os.path.exists(SOUNDPAD_ROOT):
        os.makedirs(SOUNDPAD_ROOT)
        return {}

    for folder_name in os.listdir(SOUNDPAD_ROOT):
        folder_path = os.path.join(SOUNDPAD_ROOT, folder_name)
        if os.path.isdir(folder_path):
            yaml_path = os.path.join(folder_path, "theme.yaml")
            if os.path.exists(yaml_path):
                theme = _parse_theme_file(yaml_path, folder_path)
                if theme:
                    themes[theme.id] = theme
    return themes

def _parse_theme_file(yaml_path, base_folder):
    try:
        with open(yaml_path, "r", encoding="utf-8") as f:
            data = yaml.safe_load(f)
        if not data: return None

        t_id = data.get("id", os.path.basename(base_folder))
        t_name = data.get("name", t_id)
        
        theme_obj = Theme(name=t_name, id=t_id)
        
        # 'layers' yerine 'states' okuyoruz
        raw_states = data.get("states", {}) 
        
        for state_name, state_data in raw_states.items():
            state_obj = MusicState(name=state_name)
            
            raw_tracks = state_data.get("tracks", {})
            for track_id, track_seq in raw_tracks.items():
                track_obj = Track(name=track_id)
                if not isinstance(track_seq, list): track_seq = [track_seq]

                for node_data in track_seq:
                    if isinstance(node_data, str):
                        filename = node_data; repeat = 0
                    else:
                        filename = node_data.get("file"); repeat = node_data.get("repeat", 0)
                    
                    full_path = os.path.join(base_folder, filename)
                    track_obj.sequence.append(LoopNode(full_path, repeat))
                
                state_obj.tracks[track_id] = track_obj
            
            theme_obj.states[state_name] = state_obj
            
        return theme_obj
    except Exception as e:
        print(f"Error loading {yaml_path}: {e}")
        return None


===== FILE PATH =====
./core\audio\models.py
===== FILE CONTENT =====
from dataclasses import dataclass, field
from typing import List, Dict

@dataclass
class LoopNode:
    """Tek bir ses dosyasÄ± ve tekrar sayÄ±sÄ±."""
    file_path: str
    repeat_count: int = 0  # 0 = Sonsuz, 1 = Bir kere Ã§al

@dataclass
class Track:
    """
    Intensity kanalÄ± (Ã–rn: 'base', 'level1').
    Kendi iÃ§inde sÄ±ralÄ± dosya listesi (sequence) barÄ±ndÄ±rÄ±r.
    """
    name: str
    sequence: List[LoopNode] = field(default_factory=list)

@dataclass
class MusicState:
    """
    MÃ¼zik Durumu/Modu (Ã–rn: 'Normal', 'Combat', 'Victory').
    Ä°Ã§inde farklÄ± intensity seviyeleri (Track) barÄ±ndÄ±rÄ±r.
    """
    name: str
    tracks: Dict[str, Track] = field(default_factory=dict)

@dataclass
class Theme:
    """
    Ana Tema (Ã–rn: 'Forest').
    DurumlarÄ± (States) barÄ±ndÄ±rÄ±r.
    """
    name: str
    id: str = ""
    states: Dict[str, MusicState] = field(default_factory=dict)


===== FILE PATH =====
./core\audio\__init__.py
===== FILE CONTENT =====


===== FILE PATH =====
./locales\en.yml
===== FILE CONTENT =====
en:
  BTN_SAVE: "Save"
  BTN_DELETE: "Delete"
  BTN_CANCEL: "Cancel"
  BTN_ADD: "Add"
  BTN_REMOVE: "Remove"
  BTN_IMPORT: "Import"
  BTN_IMPORT_NPC: "Import as NPC"
  BTN_CLOSE: "Close"
  MSG_SUCCESS: "Success"
  MSG_ERROR: "Error"
  MSG_WARNING: "Warning"
  LBL_NAME: "Name:"
  LBL_TYPE: "Type:"
  LBL_DESC: "Description:"
  WIN_TITLE: "Dungeon Master Tool"
  BTN_PLAYER_SCREEN: "ðŸ“º Toggle Player Screen"
  BTN_EXPORT: "ðŸ“„ Export (TXT)"
  LBL_CAMPAIGN: "World: "
  TAB_DB: "Database and Characters"
  TAB_MAP: "Maps"
  TAB_SESSION: "Session"
  BTN_LOAD_MAP: "ðŸ–¼ï¸ Load Map"
  BTN_PROJECT_MAP: "ðŸŒ Project Map"
  MSG_SELECT_MAP: "Select Map Image"
  MSG_NO_PLAYER_SCREEN: "First open the Player Screen."
  MSG_ADD_PIN: "Add Pin"
  MSG_SELECT_ENTITY: "Select Entity:"
  MSG_NO_ENTITY_FOR_PIN: "No suitable entity found to pin."
  MSG_DELETE_PIN: "Remove this pin?"
  MENU_INSPECT: "Inspect"
  MENU_MOVE: "Move"
  MENU_DELETE: "Delete"
  TITLE_DOWNLOADER: "Bulk Downloader"
  LBL_SELECT_CATS: "Select Categories:"
  BTN_START_DOWNLOAD: "Start Download"
  MSG_DOWNLOAD_COMPLETE: "Download Complete!"
  TITLE_SELECT_WORLD: "Select or Create World"
  BTN_CREATE_WORLD: "Create New World"
  LBL_SELECT_WORLD: "Select World:"
  MSG_ENTER_WORLD_NAME: "Enter World Name:"
  LBL_LANGUAGE: "Language / Dil:"
  BTN_NEW_ENTITY: "âž• New Entity"
  BTN_API_BROWSER: "ðŸŒ API Browser"
  LBL_SEARCH: "Search..."
  LBL_FILTER: "Filter"
  BTN_DOWNLOAD_ALL: "â¬‡ï¸ Download All (Offline)"
  LBL_CHECK_LIBRARY: "Include Library Results"
  CAT_ALL: "All"
  TITLE_API: "DandD 5e API Browser"
  LBL_CATEGORY: "Category:"
  LBL_SEARCH_API: "Search (Eng)..."
  MSG_LOADING: "Loading..."
  MSG_IMPORTING: "Downloading Data and Spells..."
  MSG_IMPORTED: "Imported successfully."
  MSG_EXISTS: "Already exists."
  BTN_SELECT_IMG: "Select Image"
  BTN_SHOW_PLAYER: "ðŸ‘ï¸ Show to Player"
  BTN_SHOW_STATS: "ðŸ“„ Project Card"
  LBL_TAGS: "Tags:"
  LBL_LOCATION: "Location:"
  LBL_RESIDENTS: "Residents:"
  GRP_STATS: "Stats"
  GRP_SPELLS: "Spells"
  GRP_ACTIONS: "Actions"
  GRP_INVENTORY: "Inventory"
  TAB_STATS: "ðŸ“Š Stats"
  TAB_SPELLS: "âœ¨ Spells"
  TAB_ACTIONS: "âš”ï¸ Actions"
  TAB_INV: "ðŸŽ’ Inventory"
  TAB_DOCS: "ðŸ“‚ Docs and PDFs"
  Lore: "Lore"
  LBL_SAVES: "Saving Throws"
  LBL_VULN: "Damage Vuln."
  LBL_RESIST: "Damage Resist."
  LBL_DMG_IMMUNE: "Dmg. Immunities"
  LBL_COND_IMMUNE: "Cond. Immunities"
  GRP_COMBAT: "Combat"
  GRP_DEFENSE: "Defense and Traits"
  LBL_PROF_BONUS: "Proficiency Bonus"
  LBL_PASSIVE_PERC: "Passive Perception"
  LBL_INIT_BONUS: "Initiative Bonus"
  LBL_SKILLS: "Skills"
  GRP_PDF: "Attached PDF Files"
  BTN_OPEN_PDF: "Open PDF"
  BTN_NEXT_TURN: "Next Turn â–¶"
  BTN_CLEAR_COMBAT: "Clear Tracker"
  BTN_QUICK_ADD: "Quick Add"
  LBL_INIT: "Init"
  LBL_HP: "HP"
  BTN_PROJECT_PDF: "ðŸ‘ï¸ Project PDF"
  MSG_SELECT_PDF: "Select PDF File"
  MSG_CONFIRM_DELETE_PDF: "Remove this PDF file?"
  TITLE_COMBAT: "âš”ï¸ Combat and Initiative"
  GRP_DICE: "Roll Dice"
  BTN_NEW_SESSION: "ðŸ“ New Session"
  BTN_LOAD_SESSION: "Load"
  LBL_LOG: "ðŸ“œ Event Log"
  LBL_NOTES: "ðŸ•µï¸ DM Notes"
  BTN_ADD_LOG: "Add Log"
  HEADER_NAME: "Name"
  HEADER_INIT: "Init"
  HEADER_AC: "AC"
  HEADER_HP: "HP"
  HEADER_COND: "Condition"
  BTN_ROLL_INIT: "ðŸŽ² Roll Init"
  BTN_CLEAR: "ðŸ—‘ï¸ Clear"
  BTN_ADD_PLAYERS: "Add All Players"
  BTN_CLEAR_NPCS: "Clear NPCs"
  BTN_CLEAR_ALL: "Clear All"
  MENU_ADD_COND: "ðŸ©¸ Add/Remove Condition"
  MENU_REMOVE_COMBAT: "âŒ Remove from Combat"
  MSG_NO_SELECTION: "No Selection"
  MSG_LIST_EMPTY: "List is empty or API unreachable."
  MSG_IMPORTING_DATA: "Downloading Data and Spells..."
  MSG_IMPORT_SUCCESS_DETAIL: "'%{name}' imported successfully.\n(Spells added if available.)"
  TITLE_MAP_SELECTOR: "Map Selection"
  LBL_SAVED_MAPS: "Saved Maps (Assets):"
  BTN_IMPORT_NEW_MAP: "ðŸ“‚ Import New Map"
  BTN_OPEN_SELECTED_MAP: "Open Selected Map"
  MSG_SELECT_MAP_FROM_LIST: "Please select a map from the list."
  LBL_TAGS_PH: "boss, undead, merchant..."
  LBL_PROPERTIES: "Properties"
  LBL_MAX_HP: "Max HP"
  LBL_SPEED: "Speed"
  LBL_MANUAL_SPELLS: "Manual Spells"
  LBL_TRAITS: "Traits"
  LBL_ACTIONS: "Actions"
  LBL_REACTIONS: "Reactions"
  LBL_LEGENDARY_ACTIONS: "Legendary Actions"
  LBL_DB_ITEMS: "Database Items"
  LBL_TITLE_PH: "Title"
  LBL_DETAILS_PH: "Details..."
  MSG_CONFIRM_DELETE: "Are you sure?"
  MSG_PLAYER_SCREEN_CLOSED: "Player screen is closed."
  MSG_SELECT_CATEGORY: "Please select a category."
  BTN_PREVIOUS: "Previous"
  BTN_NEXT: "Next"
  MSG_ADD_ENTITY_FIRST: "Add an entity to the database first."
  LBL_EVENT_LOG_PH: "Event log..."
  MSG_ROLLED_DICE: "ðŸŽ² Rolled d%{sides}: %{result}"
  TITLE_NEW_SESSION: "New Session"
  LBL_SESSION_NAME: "Session Name:"
  MSG_SESSION_STARTED: "Session Started: %{name}"
  MSG_CREATE_SESSION_FIRST: "Please create a session first."
  MSG_SAVED: "Saved."
  TITLE_BATTLE_MAP: "Battle Map"
  LBL_TOKEN_SIZE: "Token Size:"
  TITLE_TURN_ORDER: "âš”ï¸ Turn Order"
  LBL_HP_SIDEBAR: "%{hp} HP"
  LBL_HP_UNKNOWN: "HP: ???"
  LBL_THEME: "Theme"
  THEME_DARK: "Dark"
  THEME_MIDNIGHT: "Midnight"
  THEME_LIGHT: "Light"
  THEME_EMERALD: "Emerald"
  THEME_PARCHMENT: "Parchment"
  THEME_OCEAN: "Ocean"
  THEME_FROST: "Frost"
  THEME_AMETHYST: "Amethyst"

  LBL_NO_IMAGE: "No Image"

  # Bulk Downloader
  TITLE_DOWNLOADER: "Bulk Database Downloader"
  LBL_DOWNLOADER_DESC: "<h3>ðŸ“š Bulk Database Downloader</h3><p>This process downloads all content from the DandD 5e API (Monsters, Spells, Weapons, Armor, Magic Items, Classes, Races) to your computer.</p><p style='color: #ffa500;'>âš ï¸ This process may take 5-10 minutes depending on your internet speed.</p>"
  BTN_START_DOWNLOAD: "Start Download"
  MSG_DOWNLOADING_WAIT: "Downloading... Please Wait"
  MSG_CONFIRM_CLOSE_DOWNLOAD: "Download is in progress. Do you want to close?"
  MSG_DOWNLOAD_FINISHED: "Download Finished"
  MSG_DOWNLOAD_COMPLETE: "All data has been successfully downloaded and indexed."
  LOG_STARTING: "ðŸš€ Starting full download process..."
  LOG_SCANNING: "ðŸ“‚ Scanning list: %{label}..."
  LOG_ERROR_LIST: "âŒ Error: Could not get %{label} list (Code: %{code})"
  LOG_CONN_ERROR: "âŒ Connection error (%{label}): %{error}"
  LOG_TOTAL_ITEMS: "âœ… A total of %{count} items will be downloaded with details."
  LOG_DOWNLOADING: "â¬‡ï¸ Downloading: %{label} (%{count} items)..."
  LOG_ERROR_ITEM: "âš ï¸ Could not download: %{name} (Code: %{code})"
  LOG_ERROR_GENERAL: "âš ï¸ Error: %{name} - %{error}"
  
  # Entity Categories
  CAT_NPC: "NPC"
  CAT_MONSTER: "Monster"
  CAT_SPELL: "Spell"
  CAT_EQUIPMENT: "Equipment"
  CAT_CLASS: "Class"
  CAT_RACE: "Race"
  CAT_LOCATION: "Location"
  CAT_PLAYER: "Player"
  CAT_QUEST: "Quest"
  CAT_LORE: "Lore"

  # Property Labels
  LBL_RACE: "Race"
  LBL_CLASS: "Class"
  LBL_LEVEL: "Level"
  LBL_ATTITUDE: "Attitude"
  LBL_ATTR_FRIENDLY: "Friendly"
  LBL_ATTR_NEUTRAL: "Neutral"
  LBL_ATTR_HOSTILE: "Hostile"
  LBL_ATTR_LOCATION: "Location"
  LBL_CR: "Challenge Rating (CR)"
  LBL_ATTACK_TYPE: "Attack Type"
  LBL_SCHOOL: "School"
  LBL_CASTING_TIME: "Casting Time"
  LBL_RANGE: "Range"
  LBL_DURATION: "Duration"
  LBL_COMPONENTS: "Components"
  LBL_CATEGORY: "Category"
  LBL_RARITY: "Rarity"
  LBL_ATTUNEMENT: "Attunement"
  LBL_COST: "Cost"
  LBL_WEIGHT: "Weight"
  LBL_DAMAGE_DICE: "Damage Dice"
  LBL_DAMAGE_TYPE: "Damage Type"
  LBL_AC: "Armor Class (AC)"
  LBL_REQUIREMENTS: "Requirements"
  LBL_PROF_BONUS: "Proficiency Bonus"
  LBL_PASSIVE_PERC: "Passive Perception"
  LBL_SAVES: "Saving Throws"
  LBL_SKILLS: "Skills"
  LBL_VULN: "Vulnerabilities"
  LBL_RESIST: "Resistances"
  LBL_DMG_IMMUNE: "Damage Immunities"
  LBL_COND_IMMUNE: "Condition Immunities"
  LBL_SPEED: "Speed"
  LBL_SIZE: "Size"
  LBL_ALIGNMENT: "Alignment"
  LBL_LANGUAGE: "Language"
  LBL_SENSES: "Senses"
  LBL_RITUAL: "Ritual"
  LBL_YES: "Yes"
  LBL_NO: "No"
  LBL_DAMAGE: "Damage"
  LBL_DANGER_LEVEL: "Danger Level"
  LBL_ENVIRONMENT: "Environment"
  LBL_STATUS: "Status"
  LBL_GIVER: "Giver"
  LBL_REWARD: "Reward"
  LBL_SECRET_INFO: "Secret Info"
  LBL_HIT_DIE: "Hit Die"
  LBL_MAIN_STATS: "Main Stats"
  LBL_PROFICIENCIES: "Proficiencies"
  LBL_DANGER_SAFE: "Safe"
  LBL_DANGER_LOW: "Low"
  LBL_DANGER_MEDIUM: "Medium"
  LBL_DANGER_HIGH: "High"
  LBL_STATUS_NOT_STARTED: "Not Started"
  LBL_STATUS_ACTIVE: "Active"
  LBL_STATUS_COMPLETED: "Completed"
  LBL_LORE_HISTORY: "History"
  LBL_LORE_GEOGRAPHY: "Geography"
  LBL_LORE_RELIGION: "Religion"
  LBL_LORE_CULTURE: "Culture"
  LBL_LORE_OTHER: "Other"
# --- NEW ADDITIONS ---
  TITLE_SELECT_WORLD: "Select World"
  LBL_SELECT_WORLD_TITLE: "ðŸ”® Select World"
  PH_NEW_WORLD_NAME: "New World Name..."
  BTN_LOAD: "Load"
  BTN_CREATE: "Create"
  MSG_SELECT_WORLD_WARN: "Please select a world."
  MSG_NAME_EMPTY: "Name cannot be empty."
  MSG_WORLD_EXISTS: "A world with this name already exists."
  TITLE_PLAYER_VIEW: "Player View - Second Screen"
  MSG_NOT_FOUND: "Not Found."
  MSG_ERROR_OCCURRED: "Error occurred: %{error}"
  TITLE_ADD_COMBAT: "Add Entity to Combat"
  PH_SEARCH_NAME_TAG: "Search Name or Tag..."
  LBL_TYPE_ALL: "All"
  HEADER_INIT_BONUS: "Init Bonus"
  HEADER_ID: "ID"
  LBL_ADD_COUNT: "Count to Add:"
  BTN_ADD_SELECTED: "âœ… Add Selected"
  NAME_UNKNOWN: "Unknown"
  NAME_UNNAMED: "Unnamed"
  TITLE_EDIT_HP: "Edit HP"
  LBL_NEW_HP: "New HP:"
  MENU_CTX_INSPECT: "ðŸ” Inspect"
  MENU_CTX_MOVE: "âœ‹ Move"
  MENU_CTX_DELETE: "ðŸ—‘ï¸ Delete"
  MENU_CTX_PIN: "ðŸ“ Add Pin Here"
  TITLE_EXPORT: "Save List"
  FILE_FILTER_TXT: "Text Files (*.txt)"
  MSG_EXPORT_SUCCESS: "List exported successfully."
  MSG_FILE_WRITE_ERROR: "Could not write file:\n%{error}"
  TXT_EXPORT_HEADER: "DUNGEON MASTER - ENTITY LIST"
  TXT_EXPORT_WORLD: "World: "
  TXT_EXPORT_NO_DATA: "No entities recorded yet."
  TXT_EXPORT_TAGS: "   Tags: "
  TXT_EXPORT_DESC: "   Desc: "
  CAT_MONSTERS_PL: "Monsters"
  CAT_SPELLS_PL: "Spells"
  CAT_EQUIPMENT_ALL: "All Equipment"
  CAT_MAGIC_ITEMS_ALL: "All Magic Items"
  CAT_CLASSES_PL: "Classes"
  CAT_RACES_PL: "Races"
  # --- FINAL LOCALIZATION ADDITIONS ---
  # Campaign Selector
  TITLE_SELECT_WORLD: "Select World"
  LBL_SELECT_WORLD_TITLE: "ðŸ”® Select World"
  PH_NEW_WORLD_NAME: "New World Name..."
  BTN_LOAD: "Load"
  BTN_CREATE: "Create"
  MSG_SELECT_WORLD_WARN: "Please select a world."
  MSG_NAME_EMPTY: "Name cannot be empty."
  MSG_WORLD_EXISTS: "A world with this name already exists."
  
  # Combat Tracker & Encounter
  LBL_ENCOUNTER_PREFIX: "Encounter:"
  TIP_NEW_ENC: "New Encounter"
  TIP_RENAME_ENC: "Rename Encounter"
  TIP_DEL_ENC: "Delete Encounter"
  TITLE_NEW_ENC: "New Encounter"
  LBL_ENC_NAME: "Encounter Name:"
  TITLE_RENAME_ENC: "Rename"
  LBL_NEW_NAME: "New Name:"
  TITLE_DELETE: "Delete"
  MSG_CONFIRM_ENC_DELETE: "Delete this encounter?"
  MSG_LAST_ENC_DELETE: "Cannot delete the last encounter."
  LBL_ROUND_PREFIX: "Round: "
  BTN_BATTLE_MAP: "ðŸ—ºï¸ Battle Map"
  
  # Encounter Selector Dialog
  TITLE_ADD_COMBAT: "Add Entity to Combat"
  PH_SEARCH_NAME_TAG: "Search Name or Tag..."
  LBL_TYPE_ALL: "All"
  HEADER_INIT_BONUS: "Init Bonus"
  HEADER_ID: "ID"
  LBL_ADD_COUNT: "Count to Add:"
  BTN_ADD_SELECTED: "âœ… Add Selected"
  NAME_UNKNOWN: "Unknown"
  NAME_UNNAMED: "Unnamed"
  
  # Export / Main Window
  TITLE_EXPORT: "Save List"
  FILE_FILTER_TXT: "Text Files (*.txt)"
  MSG_EXPORT_SUCCESS: "List exported successfully."
  MSG_FILE_WRITE_ERROR: "Could not write file:\n%{error}"
  TXT_EXPORT_HEADER: "DUNGEON MASTER - ENTITY LIST"
  TXT_EXPORT_WORLD: "World: "
  TXT_EXPORT_NO_DATA: "No entities recorded yet."
  TXT_EXPORT_TAGS: "   Tags: "
  TXT_EXPORT_DESC: "   Desc: "
  
  # Categories (Plurals for Dialogs)
  CAT_MONSTERS_PL: "Monsters"
  CAT_SPELLS_PL: "Spells"
  CAT_EQUIPMENT_ALL: "All Equipment"
  CAT_MAGIC_ITEMS_ALL: "All Magic Items"
  CAT_CLASSES_PL: "Classes"
  CAT_RACES_PL: "Races"
  
  # HP Editing
  TITLE_EDIT_HP: "Edit HP"
  LBL_NEW_HP: "New HP:"
  
  # Context Menus
  MENU_CTX_INSPECT: "ðŸ” Inspect"
  MENU_CTX_MOVE: "âœ‹ Move"
  MENU_CTX_DELETE: "ðŸ—‘ï¸ Delete"
  MENU_CTX_PIN: "ðŸ“ Add Pin Here"
# --- STATUS EFFECT ---
  CAT_STATUS_EFFECT: "Status Effect"
  LBL_DURATION_TURNS: "Duration (Turns)"
  LBL_EFFECT_TYPE: "Effect Type"
  LBL_TYPE_BUFF: "Buff (Positive)"
  LBL_TYPE_DEBUFF: "Debuff (Negative)"
  LBL_TYPE_CONDITION: "Condition"

  # Missing Error Messages
  MSG_NO_IMAGE_IN_ENTITY: "No image found in this entity."
  MSG_FILE_NOT_FOUND_DISK: "File not found on disk."
  MSG_SELECT_PDF_FIRST: "Please select a PDF first."
  MSG_REMOVE_PDF_CONFIRM: "Remove this PDF from the entity?"
  MSG_CAT_NOT_SUPPORTED: "Category not supported."
  MSG_FOUND_MAGIC_ITEM: "Magic Item found."
  MSG_SEARCH_SUCCESS: "Success."
  MSG_SEARCH_NOT_FOUND: "Not found."
  
  # Combat Tracker Context Menu
  MENU_STD_CONDITIONS: "Standard Conditions"
  MENU_SAVED_EFFECTS: "--- Saved Effects ---"
  MSG_NO_SAVED_EFFECTS: "(No Saved Effects)"
  LBL_DURATION_PROMPT_TITLE: "Duration"
  LBL_DURATION_PROMPT_MSG: "%{name} duration (0=Infinite)?"
  
  # API / Item Parsing
  LBL_PROP_SPEED: "Speed"
  LBL_PROP_CAPACITY: "Capacity"
  LBL_REQ_ATTUNEMENT: "Required"
  LBL_NO_ATTUNEMENT: "Not Required"
  LBL_GENERAL_CAT: "General"
  
  # Missing Categories used in logic
  CAT_STATUS_EFFECT: "Status Effect"
  CAT_LORE: "Lore"
  CAT_QUEST: "Quest"
  CAT_LOCATION: "Location"

  BTN_TOGGLE_SOUNDPAD: "Toggle Soundpad"
  TITLE_SOUNDPAD: "Soundpad"
  MSG_SOUNDPAD_COMING_SOON: "Music and FX controls will appear here."

===== FILE PATH =====
./locales\tr.yml
===== FILE CONTENT =====
tr:
  BTN_SAVE: "Kaydet"
  BTN_DELETE: "Sil"
  BTN_CANCEL: "Ä°ptal"
  BTN_ADD: "Ekle"
  BTN_REMOVE: "KaldÄ±r"
  BTN_IMPORT: "Ä°Ã§e Aktar"
  BTN_IMPORT_NPC: "NPC Olarak Ä°Ã§e Aktar"
  BTN_CLOSE: "Kapat"
  MSG_SUCCESS: "BaÅŸarÄ±lÄ±"
  MSG_ERROR: "Hata"
  MSG_WARNING: "UyarÄ±"
  LBL_NAME: "Ä°sim:"
  LBL_TYPE: "Tip:"
  LBL_DESC: "AÃ§Ä±klama:"
  WIN_TITLE: "Zindan Efendisi AracÄ±"
  BTN_PLAYER_SCREEN: "ðŸ“º Oyuncu EkranÄ±nÄ± AÃ§/Kapat"
  BTN_EXPORT: "ðŸ“„ DÄ±ÅŸa Aktar (TXT)"
  LBL_CAMPAIGN: "DÃ¼nya: "
  TAB_DB: "VeritabanÄ± ve Karakterler"
  TAB_MAP: "Haritalar"
  TAB_SESSION: "Oturum"
  BTN_LOAD_MAP: "ðŸ–¼ï¸ Harita YÃ¼kle"
  BTN_PROJECT_MAP: "ðŸŒ HaritayÄ± YansÄ±t"
  MSG_SELECT_MAP: "Harita SeÃ§"
  MSG_NO_PLAYER_SCREEN: "Ã–nce Oyuncu EkranÄ±nÄ± aÃ§Ä±n."
  MSG_ADD_PIN: "Pin Ekle"
  MSG_SELECT_ENTITY: "VarlÄ±k SeÃ§:"
  MSG_NO_ENTITY_FOR_PIN: "Haritaya eklenebilecek uygun bir varlÄ±k bulunamadÄ±."
  MSG_DELETE_PIN: "Bu pini kaldÄ±rmak istiyor musun?"
  MENU_INSPECT: "Ä°ncele"
  MENU_MOVE: "TaÅŸÄ±"
  MENU_DELETE: "Sil"
  TITLE_DOWNLOADER: "Toplu Ä°ndirici"
  LBL_SELECT_CATS: "Kategorileri SeÃ§:"
  BTN_START_DOWNLOAD: "Ä°ndirmeyi BaÅŸlat"
  MSG_DOWNLOAD_COMPLETE: "Ä°ndirme TamamlandÄ±!"
  TITLE_SELECT_WORLD: "DÃ¼nya SeÃ§ veya OluÅŸtur"
  BTN_CREATE_WORLD: "Yeni DÃ¼nya OluÅŸtur"
  LBL_SELECT_WORLD: "DÃ¼nya SeÃ§iniz:"
  MSG_ENTER_WORLD_NAME: "DÃ¼nya AdÄ± Giriniz:"
  LBL_LANGUAGE: "Language / Dil:"
  BTN_NEW_ENTITY: "âž• Yeni VarlÄ±k"
  BTN_API_BROWSER: "ðŸŒ API TarayÄ±cÄ±"
  LBL_SEARCH: "Ara..."
  LBL_FILTER: "Filtre"
  BTN_DOWNLOAD_ALL: "â¬‡ï¸ TÃ¼m VeritabanÄ±nÄ± Ä°ndir (Offline)"
  LBL_CHECK_LIBRARY: "KÃ¼tÃ¼phane sonuÃ§larÄ±nÄ± dahil et"
  CAT_ALL: "TÃ¼mÃ¼"
  TITLE_API: "DveD 5e API TarayÄ±cÄ±"
  LBL_CATEGORY: "Kategori:"
  LBL_SEARCH_API: "Ara (Ä°ng)..."
  MSG_LOADING: "YÃ¼kleniyor..."
  MSG_IMPORTING: "Veriler ve BÃ¼yÃ¼ler Ä°ndiriliyor..."
  MSG_IMPORTED: "BaÅŸarÄ±yla iÃ§e aktarÄ±ldÄ±."
  MSG_EXISTS: "Zaten mevcut."
  BTN_SELECT_IMG: "Resim SeÃ§"
  BTN_SHOW_PLAYER: "ðŸ‘ï¸ Oyuncuya GÃ¶ster"
  BTN_SHOW_STATS: "ðŸ“„ KartÄ± YansÄ±t"
  LBL_TAGS: "Etiketler:"
  LBL_LOCATION: "Konum:"
  LBL_RESIDENTS: "Sakinler:"
  GRP_STATS: "Ä°statistikler"
  GRP_SPELLS: "BÃ¼yÃ¼ler"
  GRP_ACTIONS: "Eylemler"
  GRP_INVENTORY: "Envanter"
  TAB_STATS: "ðŸ“Š Ä°statistikler"
  TAB_SPELLS: "âœ¨ BÃ¼yÃ¼ler"
  TAB_ACTIONS: "âš”ï¸ Eylemler"
  TAB_INV: "ðŸŽ’ Envanter"
  TAB_DOCS: "ðŸ“‚ Belgeler ve PDF"
  LBL_SAVES: "Kurtarma ZarlarÄ±"
  LBL_VULN: "Hasar Zaafiyetleri"
  LBL_RESIST: "Hasar DirenÃ§leri"
  LBL_DMG_IMMUNE: "Hasar BaÄŸÄ±ÅŸÄ±klÄ±klarÄ±"
  LBL_COND_IMMUNE: "Durum BaÄŸÄ±ÅŸÄ±klÄ±klarÄ±"
  GRP_COMBAT: "SavaÅŸ Ã–zellikleri"
  GRP_DEFENSE: "Savunma Nitelikleri"
  LBL_PROF_BONUS: "UstalÄ±k Bonusu"
  LBL_PASSIVE_PERC: "Pasif AlgÄ±"
  LBL_INIT_BONUS: "Ä°nisiyatif Bonusu"
  LBL_SKILLS: "Yetenekler (Skills)"
  GRP_PDF: "Ekli PDF DosyalarÄ±"
  BTN_OPEN_PDF: "PDF AÃ§"
  BTN_NEXT_TURN: "SÄ±radaki â–¶"
  BTN_CLEAR_COMBAT: "Temizle"
  BTN_QUICK_ADD: "HÄ±zlÄ± Ekle"
  LBL_INIT: "Ä°nisiyatif"
  LBL_HP: "CP"
  BTN_PROJECT_PDF: "ðŸ‘ï¸ PDF YansÄ±t"
  MSG_SELECT_PDF: "PDF DosyasÄ± SeÃ§"
  MSG_CONFIRM_DELETE_PDF: "Bu PDF dosyasÄ±nÄ± silmek istiyor musun?"
  TITLE_COMBAT: "âš”ï¸ SavaÅŸ ve Ä°nisiyatif"
  GRP_DICE: "Zar At"
  BTN_NEW_SESSION: "ðŸ“ Yeni Oturum"
  BTN_LOAD_SESSION: "YÃ¼kle"
  LBL_LOG: "ðŸ“œ Olay GÃ¼nlÃ¼ÄŸÃ¼"
  LBL_NOTES: "ðŸ•µï¸ DM NotlarÄ±"
  BTN_ADD_LOG: "Log Ekle"
  HEADER_NAME: "Ä°sim"
  HEADER_INIT: "Ä°nisiyatif"
  HEADER_AC: "ZS (AC)"
  HEADER_HP: "CY (HP)"
  HEADER_COND: "Durum"
  BTN_ROLL_INIT: "ðŸŽ² Ä°nisiyatif At"
  BTN_CLEAR: "ðŸ—‘ï¸ Temizle"
  BTN_ADD_PLAYERS: "TÃ¼m OyuncularÄ± Ekle"
  BTN_CLEAR_NPCS: "NPC'leri Temizle"
  BTN_CLEAR_ALL: "TÃ¼mÃ¼nÃ¼ Temizle"
  MENU_ADD_COND: "ðŸ©¸ Durum Ekle/KaldÄ±r"
  MENU_REMOVE_COMBAT: "âŒ SavaÅŸtan Ã‡Ä±kar"
  MSG_NO_SELECTION: "SeÃ§im Yok"
  MSG_LIST_EMPTY: "Liste boÅŸ veya API'ye eriÅŸilemedi."
  MSG_IMPORTING_DATA: "Veriler ve BÃ¼yÃ¼ler Ä°ndiriliyor..."
  MSG_IMPORT_SUCCESS_DETAIL: "'%{name}' baÅŸarÄ±yla aktarÄ±ldÄ±.\n(Varsa bÃ¼yÃ¼leri de eklendi.)"
  TITLE_MAP_SELECTOR: "Harita SeÃ§imi"
  LBL_SAVED_MAPS: "KayÄ±tlÄ± Haritalar (Assets):"
  BTN_IMPORT_NEW_MAP: "ðŸ“‚ Yeni Harita YÃ¼kle"
  BTN_OPEN_SELECTED_MAP: "SeÃ§ili HaritayÄ± AÃ§"
  MSG_SELECT_MAP_FROM_LIST: "LÃ¼tfen listeden bir harita seÃ§in."
  LBL_TAGS_PH: "patron, hortlak, tÃ¼ccar..."
  LBL_PROPERTIES: "Ã–zellikler"
  LBL_MAX_HP: "Maks. CP"
  LBL_SPEED: "HÄ±z"
  LBL_MANUAL_SPELLS: "Manuel BÃ¼yÃ¼ler"
  LBL_TRAITS: "Nitelikler"
  LBL_ACTIONS: "Eylemler"
  LBL_REACTIONS: "Tepkiler"
  LBL_LEGENDARY_ACTIONS: "Efsanevi Eylemler"
  LBL_DB_ITEMS: "VeritabanÄ± EÅŸyalarÄ±"
  LBL_TITLE_PH: "BaÅŸlÄ±k"
  LBL_DETAILS_PH: "Detaylar..."
  MSG_CONFIRM_DELETE: "Emin misiniz?"
  MSG_PLAYER_SCREEN_CLOSED: "Oyuncu ekranÄ± kapalÄ±."
  MSG_SELECT_CATEGORY: "LÃ¼tfen bir kategori seÃ§in."
  BTN_PREVIOUS: "Geri"
  BTN_NEXT: "Ä°leri"
  MSG_ADD_ENTITY_FIRST: "Ã–nce veritabanÄ±na bir varlÄ±k ekleyin."
  LBL_EVENT_LOG_PH: "Olay gÃ¼nlÃ¼ÄŸÃ¼..."
  MSG_ROLLED_DICE: "ðŸŽ² d%{sides} atÄ±ldÄ±: %{result}"
  TITLE_NEW_SESSION: "Yeni Oturum"
  LBL_SESSION_NAME: "Oturum AdÄ±:"
  MSG_SESSION_STARTED: "Oturum BaÅŸladÄ±: %{name}"
  MSG_CREATE_SESSION_FIRST: "Ã–nce bir oturum oluÅŸturun."
  MSG_SAVED: "Kaydedildi."
  TITLE_BATTLE_MAP: "SavaÅŸ MasasÄ±"
  LBL_TOKEN_SIZE: "Token Boyutu:"
  TITLE_TURN_ORDER: "âš”ï¸ SavaÅŸ SÄ±rasÄ±"
  LBL_HP_SIDEBAR: "%{hp} CP"
  LBL_HP_UNKNOWN: "CP: ???"
  LBL_THEME: "Tema"
  THEME_DARK: "KaranlÄ±k"
  THEME_MIDNIGHT: "Gece"
  THEME_LIGHT: "AydÄ±nlÄ±k"
  THEME_EMERALD: "ZÃ¼mrÃ¼t"
  THEME_PARCHMENT: "ParÅŸÃ¶men"
  THEME_OCEAN: "Okyanus"
  THEME_FROST: "Buz"
  THEME_AMETHYST: "Ametist"

  LBL_NO_IMAGE: "Resim Yok"

  # Bulk Downloader
  TITLE_DOWNLOADER: "Toplu VeritabanÄ± Ä°ndirici"
  LBL_DOWNLOADER_DESC: "<h3>ðŸ“š Toplu VeritabanÄ± Ä°ndirici</h3><p>Bu iÅŸlem DveD 5e API Ã¼zerindeki tÃ¼m iÃ§eriÄŸi (Canavarlar, BÃ¼yÃ¼ler, Silahlar, ZÄ±rhlar, BÃ¼yÃ¼lÃ¼ EÅŸyalar, SÄ±nÄ±flar, Irklar) bilgisayarÄ±nÄ±za indirir.</p><p style='color: #ffa500;'>âš ï¸ Bu iÅŸlem internet hÄ±zÄ±nÄ±za baÄŸlÄ± olarak 5-10 dakika sÃ¼rebilir.</p>"
  BTN_START_DOWNLOAD: "Ä°ndirmeyi BaÅŸlat"
  MSG_DOWNLOADING_WAIT: "Ä°ndiriliyor... LÃ¼tfen Bekleyin"
  MSG_CONFIRM_CLOSE_DOWNLOAD: "Ä°ndirme iÅŸlemi devam ediyor. Kapatmak istiyor musunuz?"
  MSG_DOWNLOAD_FINISHED: "Ä°ndirme TamamlandÄ±"
  MSG_DOWNLOAD_COMPLETE: "TÃ¼m veriler baÅŸarÄ±yla indirildi ve indekslendi."
  LOG_STARTING: "ðŸš€ KapsamlÄ± indirme iÅŸlemi baÅŸlatÄ±lÄ±yor..."
  LOG_SCANNING: "ðŸ“‚ Liste taranÄ±yor: %{label}..."
  LOG_ERROR_LIST: "âŒ Hata: %{label} listesi alÄ±namadÄ± (Kod: %{code})"
  LOG_CONN_ERROR: "âŒ BaÄŸlantÄ± hatasÄ± (%{label}): %{error}"
  LOG_TOTAL_ITEMS: "âœ… Toplam %{count} veri detaylarÄ±yla indirilecek."
  LOG_DOWNLOADING: "â¬‡ï¸ Ä°ndiriliyor: %{label} (%{count} adet)..."
  LOG_ERROR_ITEM: "âš ï¸ Ä°ndirilemedi: %{name} (Kod: %{code})"
  LOG_ERROR_GENERAL: "âš ï¸ Hata: %{name} - %{error}"

  # Entity Categories
  CAT_NPC: "NPC"
  CAT_MONSTER: "Canavar"
  CAT_SPELL: "BÃ¼yÃ¼ (Spell)"
  CAT_EQUIPMENT: "EÅŸya (Equipment)"
  CAT_CLASS: "SÄ±nÄ±f (Class)"
  CAT_RACE: "Irk (Race)"
  CAT_LOCATION: "Mekan"
  CAT_PLAYER: "Oyuncu"
  CAT_QUEST: "GÃ¶rev"
  CAT_LORE: "Lore"

  # Property Labels
  LBL_RACE: "Irk"
  LBL_CLASS: "SÄ±nÄ±f"
  LBL_LEVEL: "Seviye"
  LBL_ATTITUDE: "TavÄ±r"
  LBL_ATTR_FRIENDLY: "Dost"
  LBL_ATTR_NEUTRAL: "NÃ¶tr"
  LBL_ATTR_HOSTILE: "DÃ¼ÅŸman"
  LBL_ATTR_LOCATION: "Konum"
  LBL_CR: "Challenge Rating (CR)"
  LBL_ATTACK_TYPE: "SaldÄ±rÄ± Tipi"
  LBL_SCHOOL: "Okul (School)"
  LBL_CASTING_TIME: "SÃ¼re (Casting Time)"
  LBL_RANGE: "Menzil (Range)"
  LBL_DURATION: "SÃ¼reklilik (Duration)"
  LBL_COMPONENTS: "BileÅŸenler (Components)"
  LBL_CATEGORY: "Kategori"
  LBL_RARITY: "Nadirik (Rarity)"
  LBL_ATTUNEMENT: "Uyumlanma (Attunement)"
  LBL_COST: "Maliyet"
  LBL_WEIGHT: "AÄŸÄ±rlÄ±k"
  LBL_DAMAGE_DICE: "Hasar ZarÄ±"
  LBL_DAMAGE_TYPE: "Hasar Tipi"
  LBL_AC: "ZÄ±rh SÄ±nÄ±fÄ± (AC)"
  LBL_REQUIREMENTS: "Gereksinimler"
  LBL_PROF_BONUS: "Yetkinlik Bonusu"
  LBL_PASSIVE_PERC: "Pasif AlgÄ±"
  LBL_SAVES: "Kurtarma AtÄ±ÅŸlarÄ±"
  LBL_SKILLS: "Beceriler"
  LBL_VULN: "ZayÄ±flÄ±klar"
  LBL_RESIST: "DirenÃ§ler"
  LBL_DMG_IMMUNE: "Hasar BaÄŸÄ±ÅŸÄ±klÄ±klarÄ±"
  LBL_COND_IMMUNE: "Durum BaÄŸÄ±ÅŸÄ±klÄ±klarÄ±"
  LBL_SPEED: "HÄ±z"
  LBL_SIZE: "Boyut"
  LBL_ALIGNMENT: "Hizalanma EÄŸilimi"
  LBL_LANGUAGE: "Dil"
  LBL_SENSES: "Duyular"
  LBL_RITUAL: "RitÃ¼el"
  LBL_YES: "Evet"
  LBL_NO: "HayÄ±r"
  LBL_DAMAGE: "Hasar"
  LBL_DANGER_LEVEL: "Tehlike Seviyesi"
  LBL_ENVIRONMENT: "Ortam"
  LBL_STATUS: "Durum"
  LBL_GIVER: "GÃ¶revi Veren"
  LBL_REWARD: "Ã–dÃ¼l"
  LBL_SECRET_INFO: "Gizli Bilgi"
  LBL_HIT_DIE: "Hit Die"
  LBL_MAIN_STATS: "Ana Statlar"
  LBL_PROFICIENCIES: "ZÄ±rh/Silah Yetkinlikleri"
  LBL_DANGER_SAFE: "GÃ¼venli"
  LBL_DANGER_LOW: "DÃ¼ÅŸÃ¼k"
  LBL_DANGER_MEDIUM: "Orta"
  LBL_DANGER_HIGH: "YÃ¼ksek"
  LBL_STATUS_NOT_STARTED: "BaÅŸlamadÄ±"
  LBL_STATUS_ACTIVE: "Aktif"
  LBL_STATUS_COMPLETED: "TamamlandÄ±"
  LBL_LORE_HISTORY: "Tarih"
  LBL_LORE_GEOGRAPHY: "CoÄŸrafya"
  LBL_LORE_RELIGION: "Din"
  LBL_LORE_CULTURE: "KÃ¼ltÃ¼r"
  LBL_LORE_OTHER: "DiÄŸer"
# --- YENÄ° EKLENENLER ---
  TITLE_SELECT_WORLD: "DÃ¼nya SeÃ§"
  LBL_SELECT_WORLD_TITLE: "ðŸ”® DÃ¼nya SeÃ§imi"
  PH_NEW_WORLD_NAME: "Yeni DÃ¼nya AdÄ±..."
  BTN_LOAD: "YÃ¼kle"
  BTN_CREATE: "OluÅŸtur"
  MSG_SELECT_WORLD_WARN: "LÃ¼tfen bir dÃ¼nya seÃ§in."
  MSG_NAME_EMPTY: "Ä°sim boÅŸ olamaz."
  MSG_WORLD_EXISTS: "Bu isimde bir dÃ¼nya zaten var."
  TITLE_PLAYER_VIEW: "Oyuncu EkranÄ± - Ä°kinci Ekran"
  MSG_NOT_FOUND: "BulunamadÄ±."
  MSG_ERROR_OCCURRED: "Hata oluÅŸtu: %{error}"
  TITLE_ADD_COMBAT: "SavaÅŸa VarlÄ±k Ekle"
  PH_SEARCH_NAME_TAG: "Ä°sim veya Etiket Ara..."
  LBL_TYPE_ALL: "TÃ¼mÃ¼"
  HEADER_INIT_BONUS: "Ä°nisiyatif Bonusu"
  HEADER_ID: "ID"
  LBL_ADD_COUNT: "Eklenecek Adet:"
  BTN_ADD_SELECTED: "âœ… SeÃ§ilenleri Ekle"
  NAME_UNKNOWN: "Bilinmeyen"
  NAME_UNNAMED: "Ä°simsiz"
  TITLE_EDIT_HP: "Can DÃ¼zenle"
  LBL_NEW_HP: "Yeni Can (HP):"
  MENU_CTX_INSPECT: "ðŸ” Ä°ncele"
  MENU_CTX_MOVE: "âœ‹ TaÅŸÄ±"
  MENU_CTX_DELETE: "ðŸ—‘ï¸ Sil"
  MENU_CTX_PIN: "ðŸ“ Buraya Pin Ekle"
  TITLE_EXPORT: "Listeyi Kaydet"
  FILE_FILTER_TXT: "Metin DosyalarÄ± (*.txt)"
  MSG_EXPORT_SUCCESS: "Liste baÅŸarÄ±yla dÄ±ÅŸa aktarÄ±ldÄ±."
  MSG_FILE_WRITE_ERROR: "Dosya yazÄ±lamadÄ±:\n%{error}"
  TXT_EXPORT_HEADER: "ZÄ°NDAN EFENDÄ°SÄ° - VARLIK LÄ°STESÄ°"
  TXT_EXPORT_WORLD: "DÃ¼nya: "
  TXT_EXPORT_NO_DATA: "HenÃ¼z kaydedilmiÅŸ varlÄ±k yok."
  TXT_EXPORT_TAGS: "   Etiketler: "
  TXT_EXPORT_DESC: "   AÃ§Ä±klama: "
  CAT_MONSTERS_PL: "Canavarlar"
  CAT_SPELLS_PL: "BÃ¼yÃ¼ler"
  CAT_EQUIPMENT_ALL: "TÃ¼m TeÃ§hizat"
  CAT_MAGIC_ITEMS_ALL: "TÃ¼m BÃ¼yÃ¼lÃ¼ EÅŸyalar"
  CAT_CLASSES_PL: "SÄ±nÄ±flar"
  CAT_RACES_PL: "Irklar"
  # --- SON LOKALÄ°ZASYON EKLEMELERÄ° ---
  # Campaign Selector
  TITLE_SELECT_WORLD: "DÃ¼nya SeÃ§"
  LBL_SELECT_WORLD_TITLE: "ðŸ”® DÃ¼nya SeÃ§imi"
  PH_NEW_WORLD_NAME: "Yeni DÃ¼nya AdÄ±..."
  BTN_LOAD: "YÃ¼kle"
  BTN_CREATE: "OluÅŸtur"
  MSG_SELECT_WORLD_WARN: "LÃ¼tfen bir dÃ¼nya seÃ§in."
  MSG_NAME_EMPTY: "Ä°sim boÅŸ olamaz."
  MSG_WORLD_EXISTS: "Bu isimde bir dÃ¼nya zaten var."
  
  # Combat Tracker & Encounter
  LBL_ENCOUNTER_PREFIX: "KarÅŸÄ±laÅŸma:"
  TIP_NEW_ENC: "Yeni KarÅŸÄ±laÅŸma"
  TIP_RENAME_ENC: "Ä°sim DeÄŸiÅŸtir"
  TIP_DEL_ENC: "KarÅŸÄ±laÅŸmayÄ± Sil"
  TITLE_NEW_ENC: "Yeni KarÅŸÄ±laÅŸma"
  LBL_ENC_NAME: "KarÅŸÄ±laÅŸma AdÄ±:"
  TITLE_RENAME_ENC: "Yeniden AdlandÄ±r"
  LBL_NEW_NAME: "Yeni Ad:"
  TITLE_DELETE: "Sil"
  MSG_CONFIRM_ENC_DELETE: "Bu karÅŸÄ±laÅŸma silinsin mi?"
  MSG_LAST_ENC_DELETE: "Son karÅŸÄ±laÅŸma silinemez."
  LBL_ROUND_PREFIX: "Tur: "
  BTN_BATTLE_MAP: "ðŸ—ºï¸ SavaÅŸ HaritasÄ±"
  
  # Encounter Selector Dialog
  TITLE_ADD_COMBAT: "SavaÅŸa VarlÄ±k Ekle"
  PH_SEARCH_NAME_TAG: "Ä°sim veya Etiket Ara..."
  LBL_TYPE_ALL: "TÃ¼mÃ¼"
  HEADER_INIT_BONUS: "Ä°nisiyatif Bonusu"
  HEADER_ID: "ID"
  LBL_ADD_COUNT: "Eklenecek Adet:"
  BTN_ADD_SELECTED: "âœ… SeÃ§ilenleri Ekle"
  NAME_UNKNOWN: "Bilinmeyen"
  NAME_UNNAMED: "Ä°simsiz"
  
  # Export / Main Window
  TITLE_EXPORT: "Listeyi Kaydet"
  FILE_FILTER_TXT: "Metin DosyalarÄ± (*.txt)"
  MSG_EXPORT_SUCCESS: "Liste baÅŸarÄ±yla dÄ±ÅŸa aktarÄ±ldÄ±."
  MSG_FILE_WRITE_ERROR: "Dosya yazÄ±lamadÄ±:\n%{error}"
  TXT_EXPORT_HEADER: "ZÄ°NDAN EFENDÄ°SÄ° - VARLIK LÄ°STESÄ°"
  TXT_EXPORT_WORLD: "DÃ¼nya: "
  TXT_EXPORT_NO_DATA: "HenÃ¼z kaydedilmiÅŸ varlÄ±k yok."
  TXT_EXPORT_TAGS: "   Etiketler: "
  TXT_EXPORT_DESC: "   AÃ§Ä±klama: "
  
  # Categories (Plurals for Dialogs)
  CAT_MONSTERS_PL: "Canavarlar"
  CAT_SPELLS_PL: "BÃ¼yÃ¼ler"
  CAT_EQUIPMENT_ALL: "TÃ¼m TeÃ§hizat"
  CAT_MAGIC_ITEMS_ALL: "TÃ¼m BÃ¼yÃ¼lÃ¼ EÅŸyalar"
  CAT_CLASSES_PL: "SÄ±nÄ±flar"
  CAT_RACES_PL: "Irklar"
  
  # HP Editing
  TITLE_EDIT_HP: "Can DÃ¼zenle"
  LBL_NEW_HP: "Yeni Can (HP):"
  
  # Context Menus
  MENU_CTX_INSPECT: "ðŸ” Ä°ncele"
  MENU_CTX_MOVE: "âœ‹ TaÅŸÄ±"
  MENU_CTX_DELETE: "ðŸ—‘ï¸ Sil"
  MENU_CTX_PIN: "ðŸ“ Buraya Pin Ekle"
  # --- DURUM ETKÄ°SÄ° ---
  CAT_STATUS_EFFECT: "Durum Etkisi"
  LBL_DURATION_TURNS: "SÃ¼re (Tur)"
  LBL_EFFECT_TYPE: "Etki Tipi"
  LBL_TYPE_BUFF: "GÃ¼Ã§lendirme (Buff)"
  LBL_TYPE_DEBUFF: "ZayÄ±flatma (Debuff)"
  LBL_TYPE_CONDITION: "Durum (Condition)"

  # Eksik Hata MesajlarÄ±
  MSG_NO_IMAGE_IN_ENTITY: "Bu varlÄ±kta gÃ¶sterilecek resim yok."
  MSG_FILE_NOT_FOUND_DISK: "Dosya diskte bulunamadÄ±."
  MSG_SELECT_PDF_FIRST: "LÃ¼tfen Ã¶nce bir PDF seÃ§in."
  MSG_REMOVE_PDF_CONFIRM: "Bu PDF dosyasÄ± varlÄ±ktan kaldÄ±rÄ±lsÄ±n mÄ±?"
  MSG_CAT_NOT_SUPPORTED: "Kategori desteklenmiyor."
  MSG_FOUND_MAGIC_ITEM: "BÃ¼yÃ¼lÃ¼ EÅŸya bulundu."
  MSG_SEARCH_SUCCESS: "BaÅŸarÄ±lÄ±."
  MSG_SEARCH_NOT_FOUND: "BulunamadÄ±."

  # Combat Tracker SaÄŸ TÄ±k MenÃ¼sÃ¼
  MENU_STD_CONDITIONS: "Standart Durumlar"
  MENU_SAVED_EFFECTS: "--- KayÄ±tlÄ± Etkiler ---"
  MSG_NO_SAVED_EFFECTS: "(KayÄ±tlÄ± Etki Yok)"
  LBL_DURATION_PROMPT_TITLE: "SÃ¼re"
  LBL_DURATION_PROMPT_MSG: "%{name} sÃ¼resi (0=Sonsuz)?"

  # API / EÅŸya AyrÄ±ÅŸtÄ±rma
  LBL_PROP_SPEED: "HÄ±z"
  LBL_PROP_CAPACITY: "Kapasite"
  LBL_REQ_ATTUNEMENT: "Gerekli"
  LBL_NO_ATTUNEMENT: "Gerekli DeÄŸil"
  LBL_GENERAL_CAT: "Genel"

  # MantÄ±ksal Olarak KullanÄ±lan Eksik Kategoriler
  CAT_STATUS_EFFECT: "Durum Etkisi"
  CAT_LORE: "Lore"
  CAT_QUEST: "GÃ¶rev"
  CAT_LOCATION: "Mekan"

  BTN_TOGGLE_SOUNDPAD: "Soundpad'i AÃ§/Kapat"
  TITLE_SOUNDPAD: "Soundpad"
  MSG_SOUNDPAD_COMING_SOON: "MÃ¼zik ve Efekt kontrolleri buraya gelecek."

===== FILE PATH =====
./tests\conftest.py
===== FILE CONTENT =====
import os
import pytest
from core.data_manager import DataManager

@pytest.fixture
def temp_campaign_dir(tmp_path):
    """Provides a temporary campaign directory."""
    d = tmp_path / "test_campaign"
    d.mkdir()
    return str(d)

@pytest.fixture
def data_manager(temp_campaign_dir):
    """Provides a DataManager instance with a temp directory."""
    dm = DataManager()
    dm.current_campaign_path = temp_campaign_dir
    # Ensure folders exist
    os.makedirs(os.path.join(temp_campaign_dir, "assets"), exist_ok=True)
    os.makedirs(os.path.join(temp_campaign_dir, "entities"), exist_ok=True)
    os.makedirs(os.path.join(temp_campaign_dir, "maps"), exist_ok=True)
    return dm


===== FILE PATH =====
./tests\test_core\test_api_client.py
===== FILE CONTENT =====
import pytest
from core.api_client import DndApiClient

@pytest.fixture
def api_client():
    return DndApiClient()

def test_api_endpoint_map(api_client):
    """Test if Endpoint Map uses standardized English keys."""
    assert api_client.ENDPOINT_MAP["Monster"] == "monsters"
    assert api_client.ENDPOINT_MAP["Spell"] == "spells"

def test_parse_monster(api_client, mocker):
    """Test parsing a monster from API response."""
    mock_data = {
        "name": "Aboleth",
        "size": "Large",
        "type": "aberration",
        "alignment": "lawful evil",
        "armor_class": [{"value": 17, "type": "natural armor"}],
        "hit_points": 135,
        "challenge_rating": 10,
        "strength": 21,
        "senses": {"passive_perception": 20, "darkvision": "120 ft."},
        "languages": "Deep Speech, telepathy 120 ft."
    }
    
    parsed = api_client.parse_monster(mock_data)
    
    assert parsed["name"] == "Aboleth"
    assert parsed["type"] == "Monster"
    assert parsed["combat_stats"]["ac"] == "17 (natural armor)"
    assert parsed["combat_stats"]["cr"] == "10"
    assert parsed["attributes"]["LBL_SENSES"] == "darkvision: 120 ft."
    assert parsed["attributes"]["LBL_LANGUAGE"] == "Deep Speech, telepathy 120 ft."

def test_parse_spell(api_client):
    """Test parsing a spell from API response."""
    mock_data = {
        "name": "Fireball",
        "level": 3,
        "school": {"name": "Evocation"},
        "casting_time": "1 action",
        "range": "150 feet",
        "components": ["V", "S", "M"],
        "duration": "Instantaneous",
        "concentration": False,
        "desc": ["A bright streak flashes from your pointing finger..."]
    }
    
    parsed = api_client.parse_spell(mock_data)
    
    assert parsed["name"] == "Fireball"
    assert parsed["type"] == "Spell"
    assert parsed["attributes"]["LBL_LEVEL"] == "3"
    assert parsed["attributes"]["LBL_SCHOOL"] == "Evocation"
    assert parsed["attributes"]["LBL_COMPONENTS"] == "V, S, M"


===== FILE PATH =====
./tests\test_core\test_data_manager.py
===== FILE CONTENT =====
import os
import json
from core.data_manager import DataManager

def test_campaign_initialization(temp_campaign_dir):
    """Test if a new campaign is correctly initialized."""
    dm = DataManager()
    # It was create_campaign, not new_campaign
    success, msg = dm.create_campaign("Test World") 
    # Wait, create_campaign uses WORLDS_DIR from config. 
    # My data_manager fixture manually sets current_campaign_path.
    # Let's use a more controlled approach for testing initialization.
    assert success is True
    assert dm.data["world_name"] == "Test World"

def test_data_persistence(data_manager):
    """Test saving and loading campaign data."""
    data_manager.data["notes"] = "Some test notes"
    data_manager.save_data() # It was save_data, not save_campaign
    
    # Reload
    dm2 = DataManager()
    success, msg = dm2.load_campaign(data_manager.current_campaign_path)
    assert success is True
    assert dm2.data["notes"] == "Some test notes"

def test_migration_logic(temp_campaign_dir):
    """Test migration of legacy Turkish keys to standardized English keys."""
    # Create legacy data using 'data.json'
    os.makedirs(temp_campaign_dir, exist_ok=True)
    legacy_data = {
        "world_name": "Legacy World",
        "entities": {
            "e1": {
                "name": "Legacy Monster",
                "type": "Canavar",
                "attributes": {
                    "Irk": "Orc",
                    "SÄ±nÄ±f": "Warrior"
                }
            }
        }
    }
    with open(os.path.join(temp_campaign_dir, "data.json"), "w", encoding="utf-8") as f:
        json.dump(legacy_data, f)
        
    dm = DataManager()
    success, msg = dm.load_campaign(temp_campaign_dir)
    assert success is True
    
    entity = dm.data["entities"]["e1"]
    assert entity["type"] == "Monster"
    assert "LBL_RACE" in entity["attributes"]
    assert "LBL_CLASS" in entity["attributes"]
    assert entity["attributes"]["LBL_RACE"] == "Orc"


===== FILE PATH =====
./tests\test_core\test_locales.py
===== FILE CONTENT =====
from core.locales import tr
import i18n
import pytest

def test_tr_basic_translation():
    """Test if tr() returns correct strings for default language (EN)."""
    i18n.set("locale", "en")
    assert tr("CAT_MONSTER") == "Monster"
    assert tr("BTN_SAVE") == "Save"

def test_tr_turkish_translation():
    """Test if tr() returns correct strings for Turkish."""
    i18n.set("locale", "tr")
    assert tr("CAT_MONSTER") == "Canavar"
    assert tr("BTN_SAVE") == "Kaydet"

def test_tr_missing_key():
    """Test behavior when a key is missing."""
    i18n.set("locale", "en")
    # i18n usually returns the key itself if missing
    assert tr("NON_EXISTENT_KEY") == "NON_EXISTENT_KEY"


===== FILE PATH =====
./tests\test_ui\test_main_window.py
===== FILE CONTENT =====
import pytest
from PyQt6.QtWidgets import QApplication
from main import MainWindow
from core.data_manager import DataManager
import os

@pytest.fixture
def initialized_data_manager(temp_campaign_dir):
    """Provides a DataManager with a campaign already created/loaded."""
    dm = DataManager()
    dm.create_campaign("UI Test World")
    # create_campaign creates it in WORLDS_DIR. 
    # For UI tests, we might want to ensure it's fully isolated.
    # But since DataManager.create_campaign is hardcoded to WORLDS_DIR, 
    # we'll just use it and rely on cleanup if needed.
    return dm

def test_main_window_init(qtbot, initialized_data_manager):
    """Test if MainWindow initializes and shows tabs."""
    window = MainWindow(initialized_data_manager)
    qtbot.addWidget(window)
    
    assert window.windowTitle().startswith("DM Tool - UI Test World")
    assert window.tabs.count() >= 3
    assert window.db_tab is not None
    assert window.map_tab is not None
    assert window.session_tab is not None

def test_tab_switching(qtbot, initialized_data_manager):
    """Test switching between tabs."""
    window = MainWindow(initialized_data_manager)
    qtbot.addWidget(window)
    
    # Switch to Map Tab (index 1)
    window.tabs.setCurrentIndex(1)
    assert window.tabs.currentIndex() == 1
    
    # Switch to Session Tab (index 2)
    window.tabs.setCurrentIndex(2)
    assert window.tabs.currentIndex() == 2

def test_language_switch_ui(qtbot, initialized_data_manager):
    """Test if language switch Updates UI text (Smoke Test)."""
    window = MainWindow(initialized_data_manager)
    qtbot.addWidget(window)
    
    # Switch to Turkish
    # combo_lang index 1 is TÃ¼rkÃ§e
    qtbot.keyClicks(window.combo_lang, "T") # Simple way to trigger or just set index
    window.combo_lang.setCurrentIndex(1)
    
    # Check if a tab text changed (Smoke)
    # TAB_DB in TR is "VeritabanÄ± ve Karakterler"
    assert "VeritabanÄ±" in window.tabs.tabText(0)


===== FILE PATH =====
./themes\amethyst.qss
===== FILE CONTENT =====
/* === AMETHYST THEME (FIXED) === */
QWidget { background-color: #211a26; color: #f3e5f5; font-family: 'Segoe UI', sans-serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #211a26; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #2d2436; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #18121c; color: #e1bee7; border: 1px solid #7b1fa2; border-radius: 4px; padding: 6px;
}

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #18121c; border: 1px solid #4a148c; border-left: 4px solid #ba68c8; border-radius: 4px; margin-bottom: 8px;
}
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #f3e5f5;
}

QFrame[class="combatCard"] { background-color: #18121c; border: 1px solid #4a148c; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #f3e5f5; }
QFrame[class="combatCard"][active="true"] { background-color: #38006b; border: 1px solid #ea80fc; }

QListWidget, QTableWidget { background-color: #18121c; color: #f3e5f5; border: 1px solid #4a148c; }
QListWidget::item:selected { background-color: #8e24aa; color: white; }
/* --- BUTONLAR (AMETHYST) --- */
QPushButton {
    background-color: #4a148c;
    color: #f3e5f5;
    border: 1px solid #6a1b9a;
    border-radius: 4px;
    padding: 6px 12px;
}
QPushButton:hover { background-color: #6a1b9a; }

QPushButton#primaryBtn {
    background-color: #ab47bc; /* AÃ§Ä±k Mor */
    color: black;
    border: none;
    font-weight: bold;
}
QPushButton#primaryBtn:hover { background-color: #ba68c8; }

QPushButton#successBtn {
    background-color: #66bb6a;
    color: black;
    border: none;
}
QPushButton#successBtn:hover { background-color: #81c784; }

QPushButton#dangerBtn {
    background-color: #c62828;
    color: white;
    border: none;
}
QPushButton#dangerBtn:hover { background-color: #e53935; }

QPushButton#actionBtn {
    background-color: #ffa726; /* Turuncu */
    color: black;
    border: none;
}
QPushButton#actionBtn:hover { background-color: #ffb74d; }

QGroupBox { background-color: transparent; border: 1px solid #4a148c; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #ce93d8; }
QTabWidget::pane { border: 1px solid #4a148c; background-color: #2d2436; }
QTabBar::tab { background-color: #38006b; color: #b39ddb; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #2d2436; color: #e1bee7; border-top: 3px solid #ba68c8; }
QLabel#headerLabel { color: #ce93d8; font-weight: bold; } QLabel#toolbarLabel { color: #f3e5f5; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\baldur.qss
===== FILE CONTENT =====
/* === BALDUR THEME (FIXED) === */
QWidget { background-color: #110b09; color: #c8b696; font-family: 'Segoe UI', serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #110b09; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #1a120b; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #0d0806; color: #e0d8c8; border: 1px solid #4a3b2a; border-radius: 2px; padding: 6px;
}
QLineEdit:focus, QTextEdit:focus { border: 1px solid #b88e4a; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #241b14; border: 1px solid #3d2e22; border-left: 3px solid #b88e4a; border-radius: 2px; margin-bottom: 8px;
}
/* KART Ä°Ã‡Ä° TEXTBOX: ÅžEFFAF */
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #c8b696;
}

QFrame[class="combatCard"] { background-color: #241b14; border: 1px solid #3d2e22; border-radius: 4px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #c8b696; }
QFrame[class="combatCard"][active="true"] { background-color: #2d2218; border: 1px solid #ffd700; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 5px solid #558b2f; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 5px solid #c62828; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 5px solid #8d6e63; }
QFrame[class="combatCard"][type="Player"] { border-left: 5px solid #1565c0; }

QListWidget, QTableWidget { background-color: #1a120b; color: #c8b696; border: 1px solid #4a3b2a; }
QListWidget::item:selected { background-color: #3e2723; color: #ffd700; border: 1px solid #b88e4a; }
/* --- BUTONLAR (BALDUR - BRONZE & WOOD) --- */
QPushButton {
    background-color: #2d241b; /* Koyu AhÅŸap */
    color: #c8b696; /* Kemik Rengi */
    border: 1px solid #4a3b2a; /* Bronz Ã‡erÃ§eve */
    border-radius: 2px; /* Keskin */
    padding: 6px 12px;
    font-family: serif;
    font-weight: bold;
}
QPushButton:hover {
    background-color: #3e3226;
    border-color: #b88e4a; /* Parlayan bronz */
}

QPushButton#primaryBtn {
    background-color: #5d4037;
    color: #ffd700; /* AltÄ±n YazÄ± */
    border: 1px solid #b88e4a;
}
QPushButton#primaryBtn:hover { background-color: #6d4c41; }

QPushButton#successBtn {
    background-color: #33691e; /* Koyu Yaprak */
    color: #f1f8e9;
    border: 1px solid #558b2f;
}
QPushButton#successBtn:hover { background-color: #558b2f; }

QPushButton#dangerBtn {
    background-color: #8c2323; /* Kan Rengi */
    color: #ffebee;
    border: 1px solid #b71c1c;
}
QPushButton#dangerBtn:hover { background-color: #a52a2a; }

QPushButton#actionBtn {
    background-color: #b88e4a; /* Bronz/AltÄ±n */
    color: #1a120b; /* Siyah yazÄ± */
    border: 1px solid #8d6e63;
}
QPushButton#actionBtn:hover { background-color: #d4a017; }

QGroupBox { background-color: transparent; border: 1px solid #4a3b2a; border-radius: 4px; margin-top: 20px; padding-top: 15px; color: #b88e4a; }
QTabWidget::pane { border: 1px solid #4a3b2a; background-color: #1a120b; }
QTabBar::tab { background-color: #110b09; color: #8d6e63; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #1a120b; color: #b88e4a; border-top: 2px solid #b88e4a; }
QLabel#headerLabel { color: #b88e4a; font-weight: bold; font-family: serif; } QLabel#toolbarLabel { color: #b88e4a; font-weight: bold; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\dark.qss
===== FILE CONTENT =====
/* === DARK THEME (FIXED) === */
QWidget { background-color: #2b2b2b; color: #e0e0e0; font-family: 'Segoe UI', sans-serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #2b2b2b; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #2b2b2b; }

/* Inputlar (Genel) */
QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #1e1e1e; color: #ffffff; border: 1px solid #444; border-radius: 4px; padding: 6px; selection-background-color: #0d47a1;
}
QLineEdit:focus, QTextEdit:focus { border: 1px solid #42a5f5; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #1e1e1e; border: 1px solid #3e3e3e; border-left: 4px solid #42a5f5; border-radius: 4px; margin-bottom: 8px;
}
/* KART Ä°Ã‡Ä° TEXTBOX: ÅžEFFAF */
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #ffffff;
}

QFrame[class="combatCard"] { background-color: #1e1e1e; border: 1px solid #444; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #e0e0e0; }
QFrame[class="combatCard"][active="true"] { background-color: #152535; border: 1px solid #42a5f5; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 5px solid #4caf50; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 5px solid #ef5350; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 5px solid #bdbdbd; }
QFrame[class="combatCard"][type="Player"] { border-left: 5px solid #42a5f5; }

QListWidget, QTableWidget { background-color: #1e1e1e; color: #e0e0e0; border: 1px solid #444; }
QListWidget::item:selected { background-color: #0d47a1; color: white; }

/* --- BUTONLAR (DARK - SOFT) --- */
QPushButton {
    background-color: #3c3f41; /* YumuÅŸak Koyu Gri */
    color: #e0e0e0;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 6px 12px;
    font-weight: 600;
}
QPushButton:hover { background-color: #4e5254; border-color: #777; }
QPushButton:pressed { background-color: #2b2b2b; }

QPushButton#primaryBtn {
    background-color: #1565c0; /* Mat Mavi */
    color: white;
    border: 1px solid #0d47a1;
}
QPushButton#primaryBtn:hover { background-color: #1976d2; }

QPushButton#successBtn {
    background-color: #2e7d32; /* Mat Orman YeÅŸili */
    color: white;
    border: 1px solid #1b5e20;
}
QPushButton#successBtn:hover { background-color: #388e3c; }

QPushButton#dangerBtn {
    background-color: #c62828; /* Mat KÄ±rmÄ±zÄ± */
    color: white;
    border: 1px solid #b71c1c;
}
QPushButton#dangerBtn:hover { background-color: #d32f2f; }

QPushButton#actionBtn {
    background-color: #f9a825; /* Mat Hardal SarÄ±sÄ± */
    color: #1c1c1c; /* Koyu yazÄ± */
    border: 1px solid #f57f17;
}
QPushButton#actionBtn:hover { background-color: #fbc02d; }

QGroupBox { background-color: transparent; border: 1px solid #444; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #42a5f5; font-weight: bold; }
QTabWidget::pane { border: 1px solid #444; background-color: #2b2b2b; }
QTabBar::tab { background-color: #1e1e1e; color: #aaa; padding: 8px 15px; margin-right: 2px; }
QTabBar::tab:selected { background-color: #2b2b2b; color: white; border-top: 3px solid #42a5f5; }
QLabel#headerLabel { color: #42a5f5; font-weight: bold; } QLabel#toolbarLabel { color: #e0e0e0; font-weight: bold; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\discord.qss
===== FILE CONTENT =====
/* === DISCORD THEME (FIXED) === */
QWidget { background-color: #202225; color: #dcddde; font-family: 'Verdana', sans-serif; font-size: 13px; }
QMainWindow, QDialog, QScrollArea { background-color: #202225; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #36393f; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #40444b; color: #ffffff; border: none; border-radius: 4px; padding: 8px; selection-background-color: #5865f2;
}
QLineEdit:focus, QTextEdit:focus { background-color: #202225; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #2f3136; border: none; border-left: 4px solid #5865f2; border-radius: 8px; margin-bottom: 8px;
}
/* KART Ä°Ã‡Ä° TEXTBOX: ÅžEFFAF */
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #ffffff;
}

QFrame[class="combatCard"] { background-color: #2f3136; border: none; border-radius: 8px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #dcddde; }
QFrame[class="combatCard"][active="true"] { background-color: #40444b; border-left: 4px solid #faa61a; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 4px solid #3ba55c; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 4px solid #ed4245; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 4px solid #747f8d; }
QFrame[class="combatCard"][type="Player"] { border-left: 4px solid #5865f2; }

QListWidget, QTableWidget { background-color: #2f3136; color: #dcddde; border: none; border-radius: 8px; }
QListWidget::item:selected { background-color: #3ba55c; color: white; border-radius: 4px; }
/* --- BUTONLAR (DISCORD - FLAT) --- */
QPushButton {
    background-color: #4f545c; /* Gri */
    color: #ffffff;
    border: none;
    border-radius: 4px;
    padding: 8px 16px;
    font-weight: bold;
}
QPushButton:hover { background-color: #686d73; }
QPushButton:pressed { background-color: #40444b; }

QPushButton#primaryBtn {
    background-color: #5865f2; /* Blurple */
    color: white;
}
QPushButton#primaryBtn:hover { background-color: #4752c4; }

QPushButton#successBtn {
    background-color: #3ba55c; /* YeÅŸil */
    color: white;
}
QPushButton#successBtn:hover { background-color: #2d7d46; }

QPushButton#dangerBtn {
    background-color: #ed4245; /* KÄ±rmÄ±zÄ± */
    color: white;
}
QPushButton#dangerBtn:hover { background-color: #c03537; }

QPushButton#actionBtn {
    background-color: #faa61a; /* SarÄ± */
    color: #202225;
}
QPushButton#actionBtn:hover { background-color: #de9317; }

QGroupBox { background-color: transparent; border: 1px solid #202225; border-radius: 8px; margin-top: 20px; padding-top: 15px; color: #dcddde; }
QTabWidget::pane { border: none; background-color: #36393f; }
QTabBar::tab { background-color: #202225; color: #72767d; padding: 10px 15px; border-radius: 4px; margin-right: 4px; }
QTabBar::tab:selected { background-color: #36393f; color: #ffffff; }
QLabel#headerLabel { color: #ffffff; font-weight: bold; } QLabel#toolbarLabel { color: #b9bbbe; font-weight: bold; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\emerald.qss
===== FILE CONTENT =====
/* === EMERALD THEME (FIXED) === */
QWidget { background-color: #051e12; color: #e8f5e9; font-family: 'Segoe UI', sans-serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #051e12; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #0a2718; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #00150a; color: #a5d6a7; border: 1px solid #2e7d32; border-radius: 4px; padding: 6px;
}

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #00150a; border: 1px solid #1b5e20; border-left: 4px solid #00e676; border-radius: 4px; margin-bottom: 8px;
}
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #e8f5e9;
}

QFrame[class="combatCard"] { background-color: #00150a; border: 1px solid #1b5e20; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #e8f5e9; }
QFrame[class="combatCard"][active="true"] { background-color: #0f2b1d; border: 1px solid #00e676; }

QListWidget, QTableWidget { background-color: #00150a; color: #e8f5e9; border: 1px solid #1b5e20; }
QListWidget::item:selected { background-color: #00c853; color: black; }
/* --- BUTONLAR (EMERALD - GREEN) --- */
QPushButton {
    background-color: #1b5e20;
    color: #e8f5e9;
    border: 1px solid #2e7d32;
    border-radius: 4px;
    padding: 6px 12px;
}
QPushButton:hover { background-color: #2e7d32; }

QPushButton#primaryBtn {
    background-color: #00c853; /* Parlak YeÅŸil */
    color: #000000;
    border: none;
    font-weight: bold;
}
QPushButton#primaryBtn:hover { background-color: #00e676; }

QPushButton#successBtn {
    background-color: #2e7d32;
    color: white;
    border: 1px solid #66bb6a;
}
QPushButton#successBtn:hover { background-color: #388e3c; }

QPushButton#dangerBtn {
    background-color: #c62828;
    color: white;
    border: none;
}
QPushButton#dangerBtn:hover { background-color: #d32f2f; }

QPushButton#actionBtn {
    background-color: #ff9100; /* Turuncu (ZÄ±t renk) */
    color: black;
    border: none;
}
QPushButton#actionBtn:hover { background-color: #ffab40; }

QGroupBox { background-color: transparent; border: 1px solid #1b5e20; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #66bb6a; }
QTabWidget::pane { border: 1px solid #1b5e20; background-color: #0a2718; }
QTabBar::tab { background-color: #0f2b1d; color: #81c784; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #0a2718; color: #00e676; border-top: 3px solid #00e676; }
QLabel#headerLabel { color: #00e676; font-weight: bold; } QLabel#toolbarLabel { color: #e8f5e9; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\frost.qss
===== FILE CONTENT =====
/* === FROST THEME (FIXED) === */
QWidget { background-color: #e6fffa; color: #1a365d; font-family: 'Segoe UI', sans-serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #e6fffa; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #f0fff4; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #ffffff; color: #1a365d; border: 1px solid #81e6d9; border-radius: 4px; padding: 6px; selection-background-color: #319795; selection-color: #ffffff;
}
QLineEdit:focus, QTextEdit:focus { border: 1px solid #319795; background-color: #f0fdff; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #ffffff; border: 1px solid #b2f5ea; border-left: 4px solid #319795; border-radius: 4px; margin-bottom: 8px;
}
/* KART Ä°Ã‡Ä° TEXTBOX: ÅžEFFAF */
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #1a365d;
}

QFrame[class="combatCard"] { background-color: #ffffff; border: 1px solid #b2f5ea; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #1a365d; }
QFrame[class="combatCard"][active="true"] { background-color: #e6fffa; border: 1px solid #319795; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 5px solid #38b2ac; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 5px solid #e53e3e; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 5px solid #a0aec0; }
QFrame[class="combatCard"][type="Player"] { border-left: 5px solid #3182ce; }

QListWidget, QTableWidget { background-color: #ffffff; color: #1a365d; border: 1px solid #81e6d9; }
QListWidget::item:selected { background-color: #319795; color: #ffffff; }
/* --- BUTONLAR (FROST - COLD) --- */
QPushButton {
    background-color: #ffffff;
    color: #234e52; /* Koyu Teal */
    border: 1px solid #81e6d9;
    border-radius: 4px;
    padding: 6px 12px;
    font-weight: 600;
}
QPushButton:hover { background-color: #e6fffa; }

QPushButton#primaryBtn {
    background-color: #319795; /* Teal */
    color: white;
    border: none;
}
QPushButton#primaryBtn:hover { background-color: #2c7a7b; }

QPushButton#successBtn {
    background-color: #38b2ac; /* AÃ§Ä±k Teal */
    color: white;
    border: none;
}
QPushButton#successBtn:hover { background-color: #319795; }

QPushButton#dangerBtn {
    background-color: #e53e3e; /* KÄ±rmÄ±zÄ± */
    color: white;
    border: none;
}
QPushButton#dangerBtn:hover { background-color: #c53030; }

QPushButton#actionBtn {
    background-color: #dd6b20; /* Turuncu (Kontrast iÃ§in) */
    color: white;
    border: none;
}
QPushButton#actionBtn:hover { background-color: #c05621; }

QGroupBox { background-color: transparent; border: 1px solid #81e6d9; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #285e61; font-weight: bold; }
QTabWidget::pane { border: 1px solid #81e6d9; background-color: #ffffff; }
QTabBar::tab { background-color: #e6fffa; color: #2c7a7b; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #ffffff; color: #234e52; border-top: 3px solid #319795; font-weight: bold; }
QLabel#headerLabel { color: #285e61; font-weight: bold; } QLabel#toolbarLabel { color: #234e52; font-weight: bold; }
/* --- ENTITY LIST ITEM DÃœZELTMESÄ° (AÃ‡IK) --- */
QWidget#entityItem {
    background-color: transparent;
}

QLabel#entityName {
    color: #000000; /* Koyu yazÄ± */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #555555; /* Gri yazÄ± */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\grim.qss
===== FILE CONTENT =====
/* === GRIM THEME (FIXED) === */
QWidget { background-color: #1c1c1c; color: #d7d7d7; font-family: 'Georgia', serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #1c1c1c; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #262626; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #333333; color: #e6e6e6; border: 1px solid #555; border-radius: 0px; padding: 6px;
}
QLineEdit:focus { border: 1px solid #a63a28; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #3e3b36; border: 1px solid #111; border-left: 4px solid #a63a28; border-radius: 0px; margin-bottom: 8px;
}
/* KART Ä°Ã‡Ä° TEXTBOX: ÅžEFFAF */
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #f0f0f0;
}

QFrame[class="combatCard"] { background-color: #3e3b36; border: 1px solid #111; border-radius: 0px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #f0f0f0; }
QFrame[class="combatCard"][active="true"] { background-color: #4e4b46; border: 1px solid #d45d00; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 5px solid #5e7d58; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 5px solid #8a2be2; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 5px solid #777; }
QFrame[class="combatCard"][type="Player"] { border-left: 5px solid #a63a28; }

QListWidget, QTableWidget { background-color: #262626; color: #d7d7d7; border: 1px solid #444; }
QListWidget::item:selected { background-color: #a63a28; color: white; }
/* --- BUTONLAR (GRIM - RUST) --- */
QPushButton {
    background-color: #333;
    color: #ccc;
    border: 1px solid #555;
    border-radius: 2px;
    padding: 6px 12px;
    text-transform: uppercase;
    font-weight: bold;
    letter-spacing: 1px;
}
QPushButton:hover { background-color: #444; border-color: #a63a28; }

QPushButton#primaryBtn {
    background-color: #7f2a1e; /* PÄ±htÄ± KÄ±rmÄ±zÄ±sÄ± */
    color: #fff;
    border: 1px solid #a63a28;
}
QPushButton#primaryBtn:hover { background-color: #8f3a2e; }

QPushButton#successBtn {
    background-color: #3d5c38; /* Soluk YeÅŸil */
    color: #dcedc8;
    border: 1px solid #558b2f;
}
QPushButton#successBtn:hover { background-color: #4b7043; }

QPushButton#dangerBtn {
    background-color: #5c2b2b; /* Koyu Bordo */
    color: #ffcdd2;
    border: 1px solid #8c2323;
}
QPushButton#dangerBtn:hover { background-color: #6d3b3b; }

QPushButton#actionBtn {
    background-color: #a63a28; /* Pas Rengi */
    color: #1c1c1c;
    border: 1px solid #bf360c;
}
QPushButton#actionBtn:hover { background-color: #bf4330; }

QGroupBox { background-color: transparent; border: 1px solid #555; margin-top: 20px; padding-top: 15px; color: #a63a28; font-family: serif; }
QTabWidget::pane { border: 1px solid #555; background-color: #262626; }
QTabBar::tab { background-color: #1c1c1c; color: #777; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #262626; color: #a63a28; border-top: 2px solid #a63a28; }
QLabel#headerLabel { color: #a63a28; font-weight: bold; font-family: serif; font-size: 18px; } QLabel#toolbarLabel { color: #d7d7d7; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\light.qss
===== FILE CONTENT =====
/* === LIGHT THEME (FIXED) === */
QWidget { background-color: #f5f7fa; color: #212121; font-family: 'Segoe UI', sans-serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #f5f7fa; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #ffffff; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #ffffff; color: #000000; border: 1px solid #cbd5e0; border-radius: 4px; padding: 6px; selection-background-color: #3182ce; selection-color: #ffffff;
}
QLineEdit:focus, QTextEdit:focus { border: 1px solid #3182ce; background-color: #ffffff; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #f8f9fa; border: 1px solid #e2e8f0; border-left: 4px solid #3182ce; border-radius: 6px; margin-bottom: 8px;
}
/* KART Ä°Ã‡Ä° TEXTBOX: ÅžEFFAF */
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #000000;
}

QFrame[class="combatCard"] { background-color: #ffffff; border: 1px solid #e2e8f0; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #000000; }
QFrame[class="combatCard"][active="true"] { background-color: #ebf8ff; border: 1px solid #3182ce; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 5px solid #38a169; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 5px solid #e53e3e; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 5px solid #a0aec0; }
QFrame[class="combatCard"][type="Player"] { border-left: 5px solid #3182ce; }

QListWidget, QTableWidget { background-color: #ffffff; color: #212121; border: 1px solid #cbd5e0; }
QListWidget::item:selected { background-color: #3182ce; color: #ffffff; }
/* --- BUTONLAR (LIGHT - SOFT) --- */
QPushButton {
    background-color: #ffffff;
    color: #24292e;
    border: 1px solid #d1d5da;
    border-radius: 4px;
    padding: 6px 12px;
    font-weight: 600;
}
QPushButton:hover {
    background-color: #f3f4f6; /* Ã‡ok hafif gri hover */
    border-color: #959da5;
}
QPushButton:pressed { background-color: #e1e4e8; }

QPushButton#primaryBtn {
    background-color: #2188ff; /* GitHub Mavisi */
    color: white;
    border: 1px solid #0366d6;
}
QPushButton#primaryBtn:hover { background-color: #0366d6; }

QPushButton#successBtn {
    background-color: #2ea44f; /* YumuÅŸak YeÅŸil */
    color: white;
    border: 1px solid #22863a;
}
QPushButton#successBtn:hover { background-color: #2c974b; }

QPushButton#dangerBtn {
    background-color: #d73a49; /* YumuÅŸak KÄ±rmÄ±zÄ± */
    color: white;
    border: 1px solid #b60205;
}
QPushButton#dangerBtn:hover { background-color: #cb2431; }

QPushButton#actionBtn {
    background-color: #ffb300; /* Amber */
    color: #24292e;
    border: 1px solid #e6a200;
}
QPushButton#actionBtn:hover { background-color: #ffca28; }

QGroupBox { background-color: transparent; border: 1px solid #cbd5e0; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #2b6cb0; font-weight: bold; }
QTabWidget::pane { border: 1px solid #cbd5e0; background-color: #ffffff; }
QTabBar::tab { background-color: #e2e8f0; color: #4a5568; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #ffffff; color: #2b6cb0; border-top: 3px solid #3182ce; font-weight: bold; }
QLabel#headerLabel { color: #2b6cb0; font-weight: bold; } QLabel#toolbarLabel { color: #1a202c; font-weight: bold; }
/* --- ENTITY LIST ITEM DÃœZELTMESÄ° (AÃ‡IK) --- */
QWidget#entityItem {
    background-color: transparent;
}

QLabel#entityName {
    color: #000000; /* Koyu yazÄ± */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #555555; /* Gri yazÄ± */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\midnight.qss
===== FILE CONTENT =====
/* === MIDNIGHT THEME (FIXED) === */
QWidget { background-color: #121212; color: #b0bec5; font-family: 'Segoe UI', sans-serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #121212; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #000000; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #000000; color: #ffffff; border: 1px solid #333; border-radius: 4px; padding: 6px;
}
QLineEdit:focus { border: 1px solid #7c4dff; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #1e1e1e; border: 1px solid #333; border-left: 4px solid #7c4dff; border-radius: 4px; margin-bottom: 8px;
}
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #ffffff;
}

QFrame[class="combatCard"] { background-color: #1e1e1e; border: 1px solid #333; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #b0bec5; }
QFrame[class="combatCard"][active="true"] { background-color: #1a1a2e; border: 1px solid #7c4dff; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 5px solid #00c853; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 5px solid #d50000; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 5px solid #616161; }
QFrame[class="combatCard"][type="Player"] { border-left: 5px solid #651fff; }

QListWidget, QTableWidget { background-color: #000000; color: #b0bec5; border: 1px solid #333; }
QListWidget::item:selected { background-color: #4527a0; color: white; }
/* --- BUTONLAR (MIDNIGHT - PURPLE) --- */
QPushButton {
    background-color: #1e1e1e;
    color: #e0e0e0;
    border: 1px solid #333;
    border-radius: 4px;
    padding: 6px 12px;
}
QPushButton:hover { background-color: #333; border-color: #651fff; }

QPushButton#primaryBtn {
    background-color: #651fff; /* Derin Mor */
    color: white;
    border: none;
}
QPushButton#primaryBtn:hover { background-color: #7c4dff; }

QPushButton#successBtn {
    background-color: #00c853;
    color: white;
    border: none;
}
QPushButton#successBtn:hover { background-color: #00e676; }

QPushButton#dangerBtn {
    background-color: #d50000;
    color: white;
    border: none;
}
QPushButton#dangerBtn:hover { background-color: #ff1744; }

QPushButton#actionBtn {
    background-color: #ffab00; /* AltÄ±n */
    color: black;
    border: none;
}
QPushButton#actionBtn:hover { background-color: #ffc400; }

QGroupBox { background-color: transparent; border: 1px solid #333; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #b388ff; }
QTabWidget::pane { border: 1px solid #333; background-color: #121212; }
QTabBar::tab { background-color: #1e1e1e; color: #777; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #121212; color: #b388ff; border-top: 3px solid #651fff; }
QLabel#headerLabel { color: #7c4dff; font-weight: bold; } QLabel#toolbarLabel { color: #b0bec5; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\ocean.qss
===== FILE CONTENT =====
/* === OCEAN THEME (FIXED) === */
QWidget { background-color: #0f1b26; color: #e0f7fa; font-family: 'Segoe UI', sans-serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #0f1b26; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #162533; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #0a131a; color: #80deea; border: 1px solid #4dd0e1; border-radius: 4px; padding: 6px;
}

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #0a131a; border: 1px solid #37474f; border-left: 4px solid #00bcd4; border-radius: 4px; margin-bottom: 8px;
}
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #e0f7fa;
}

QFrame[class="combatCard"] { background-color: #0a131a; border: 1px solid #37474f; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #e0f7fa; }
QFrame[class="combatCard"][active="true"] { background-color: #263238; border: 1px solid #00bcd4; }

QListWidget, QTableWidget { background-color: #0a131a; color: #e0f7fa; border: 1px solid #37474f; }
QListWidget::item:selected { background-color: #00acc1; color: white; }
QPushButton { background-color: #263238; color: #e0f7fa; border: 1px solid #455a64; border-radius: 4px; padding: 6px 12px; }
QPushButton:hover { background-color: #37474f; border-color: #4dd0e1; }
QPushButton#primaryBtn { background-color: #00bcd4; color: black; border: none; font-weight: bold; }
QPushButton#successBtn { background-color: #00897b; color: white; border: none; }
QPushButton#dangerBtn { background-color: #c62828; color: white; border: none; }

QGroupBox { background-color: transparent; border: 1px solid #37474f; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #4dd0e1; }
QTabWidget::pane { border: 1px solid #37474f; background-color: #162533; }
QTabBar::tab { background-color: #1c2a38; color: #546e7a; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #162533; color: #26c6da; border-top: 2px solid #26c6da; }
QLabel#headerLabel { color: #26c6da; font-weight: bold; } QLabel#toolbarLabel { color: #e0f7fa; }
QWidget#entityItem {
    background-color: transparent; /* Widget'Ä±n kendisi ÅŸeffaf */
}

QLabel#entityName {
    color: #e0e0e0; /* TemanÄ±n ana yazÄ± rengi neyse o (Ã–rn: #e0e0e0) */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #888888; /* Daha soluk bir renk */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./themes\parchment.qss
===== FILE CONTENT =====
/* === PARCHMENT THEME (FIXED) === */
QWidget { background-color: #dccdb5; color: #3e2723; font-family: 'Georgia', serif; font-size: 14px; }
QMainWindow, QDialog, QScrollArea { background-color: #dccdb5; border: none; }
QWidget#sheetContainer, QWidget#sidebarContainer, QScrollArea#mainScroll, QScrollArea#sidebarScroll { background-color: #e5dace; }

QLineEdit, QTextEdit, QPlainTextEdit, QSpinBox, QComboBox {
    background-color: #f2eadd; color: #3e2723; border: 1px solid #a1887f; border-radius: 4px; padding: 6px; selection-background-color: #8d6e63;
}
QLineEdit:focus, QTextEdit:focus { border: 1px solid #5d4037; background-color: #ffffff; }

/* --- KARTLAR (ÅžEFFAF TEXTBOX) --- */
QFrame[class="featureCard"] {
    background-color: #ebdcc6; border: 1px solid #bcaaa4; border-left: 4px solid #795548; border-radius: 4px; margin-bottom: 8px;
}
/* KART Ä°Ã‡Ä° TEXTBOX: ÅžEFFAF */
QFrame[class="featureCard"] QLineEdit, QFrame[class="featureCard"] QTextEdit {
    background-color: transparent; border: none; color: #3e2723;
}

QFrame[class="combatCard"] { background-color: #ebdcc6; border: 1px solid #bcaaa4; border-radius: 6px; margin-bottom: 4px; }
QFrame[class="combatCard"] QLabel { background-color: transparent; color: #3e2723; }
QFrame[class="combatCard"][active="true"] { background-color: #d7ccc8; border: 2px solid #5d4037; }
QFrame[class="combatCard"][attitude="friendly"] { border-left: 5px solid #558b2f; }
QFrame[class="combatCard"][attitude="hostile"] { border-left: 5px solid #c62828; }
QFrame[class="combatCard"][attitude="neutral"] { border-left: 5px solid #8d6e63; }
QFrame[class="combatCard"][type="Player"] { border-left: 5px solid #1565c0; }

QListWidget, QTableWidget { background-color: #f2eadd; color: #3e2723; border: 1px solid #a1887f; }
QListWidget::item:selected { background-color: #a1887f; color: #fff8e1; }
/* --- BUTONLAR (PARCHMENT - LEATHER STYLE) --- */
QPushButton {
    background-color: #e5dace; /* AÃ§Ä±k parÅŸÃ¶men */
    color: #4e342e; /* Koyu kahve yazÄ± */
    border: 1px solid #a1887f; /* Bronz sÄ±nÄ±r */
    border-radius: 4px;
    padding: 6px 12px;
    font-weight: bold;
}
QPushButton:hover { background-color: #d7ccc8; border-color: #8d6e63; }

QPushButton#primaryBtn {
    background-color: #5d4037; /* Koyu Deri */
    color: #fdfbf7; /* KaÄŸÄ±t rengi yazÄ± */
    border: 1px solid #3e2723;
}
QPushButton#primaryBtn:hover { background-color: #6d4c41; }

QPushButton#successBtn {
    background-color: #558b2f; /* Yosun YeÅŸili */
    color: white;
    border: 1px solid #33691e;
}
QPushButton#successBtn:hover { background-color: #689f38; }

QPushButton#dangerBtn {
    background-color: #c62828; /* MÃ¼hÃ¼r KÄ±rmÄ±zÄ±sÄ± */
    color: white;
    border: 1px solid #b71c1c;
}
QPushButton#dangerBtn:hover { background-color: #d32f2f; }

QPushButton#actionBtn {
    background-color: #ff8f00; /* Kehribar */
    color: #3e2723;
    border: 1px solid #ff6f00;
}
QPushButton#actionBtn:hover { background-color: #ffa000; }

QGroupBox { background-color: transparent; border: 1px solid #a1887f; border-radius: 6px; margin-top: 20px; padding-top: 15px; color: #5d4037; font-weight: bold; }
QTabWidget::pane { border: 1px solid #a1887f; background-color: #e5dace; }
QTabBar::tab { background-color: #dccdb5; color: #6d4c41; padding: 8px 15px; }
QTabBar::tab:selected { background-color: #e5dace; color: #3e2723; border-top: 3px solid #5d4037; font-weight: bold; }
QLabel#headerLabel { color: #5d4037; font-weight: bold; } QLabel#toolbarLabel { color: #3e2723; font-weight: bold; }
/* --- ENTITY LIST ITEM DÃœZELTMESÄ° (AÃ‡IK) --- */
QWidget#entityItem {
    background-color: transparent;
}

QLabel#entityName {
    color: #000000; /* Koyu yazÄ± */
    background-color: transparent;
    font-weight: bold;
}

QLabel#entityCat {
    color: #555555; /* Gri yazÄ± */
    background-color: transparent;
    font-style: italic;
}

===== FILE PATH =====
./ui\campaign_selector.py
===== FILE CONTENT =====
# ui/campaign_selector.py tamamÄ±nÄ± gÃ¼ncelleyelim:

from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QListWidget, QPushButton, 
                             QLineEdit, QHBoxLayout, QLabel, QMessageBox, QWidget, QComboBox)
from core.locales import tr, set_language
from PyQt6.QtCore import Qt

class CampaignSelector(QDialog):
    def __init__(self, data_manager):
        super().__init__()
        self.dm = data_manager
        self.selected_campaign = None
        
        self.setWindowTitle("Select World") # GeÃ§ici, update_texts dÃ¼zeltecek
        self.setFixedSize(400, 500)
        # Stil QSS'den gelecek, burayÄ± temizliyoruz veya basic bÄ±rakÄ±yoruz
        
        self.init_ui()
        self.refresh_list()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # BaÅŸlÄ±k
        self.lbl_title = QLabel()
        self.lbl_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lbl_title.setObjectName("headerLabel") # QSS ID
        self.lbl_title.setStyleSheet("font-size: 20px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(self.lbl_title)
        
        # Liste
        self.list_widget = QListWidget()
        self.list_widget.itemDoubleClicked.connect(self.load_campaign)
        layout.addWidget(self.list_widget)
        
        # YÃ¼kle Butonu
        self.btn_load = QPushButton()
        self.btn_load.setObjectName("primaryBtn")
        self.btn_load.clicked.connect(self.load_campaign)
        layout.addWidget(self.btn_load)
        
        layout.addSpacing(20)
        
        # Yeni OluÅŸturma AlanÄ±
        create_layout = QHBoxLayout()
        self.inp_new_name = QLineEdit()
        
        self.btn_create = QPushButton()
        self.btn_create.setObjectName("successBtn")
        self.btn_create.clicked.connect(self.create_campaign)
        
        create_layout.addWidget(self.inp_new_name)
        create_layout.addWidget(self.btn_create)
        
        layout.addLayout(create_layout)

        # Dil SeÃ§imi
        lang_layout = QHBoxLayout()
        self.lbl_lang = QLabel(tr("LBL_LANGUAGE"))
        self.combo_lang = QComboBox()
        self.combo_lang.addItems(["English", "TÃ¼rkÃ§e"])
        
        current_lang = self.dm.settings.get("language", "EN")
        self.combo_lang.setCurrentIndex(1 if current_lang == "TR" else 0)
        self.combo_lang.currentIndexChanged.connect(self.change_language)
        
        lang_layout.addStretch()
        lang_layout.addWidget(self.lbl_lang)
        lang_layout.addWidget(self.combo_lang)
        layout.addLayout(lang_layout)

        self.update_texts()

    def change_language(self, index):
        code = "TR" if index == 1 else "EN"
        self.dm.save_settings({"language": code})
        self.update_texts()

    def update_texts(self):
        self.setWindowTitle(tr("TITLE_SELECT_WORLD"))
        self.lbl_title.setText(tr("LBL_SELECT_WORLD_TITLE"))
        self.btn_load.setText(tr("BTN_LOAD"))
        self.inp_new_name.setPlaceholderText(tr("PH_NEW_WORLD_NAME"))
        self.btn_create.setText(tr("BTN_CREATE"))
        self.lbl_lang.setText(tr("LBL_LANGUAGE"))

    def refresh_list(self):
        self.list_widget.clear()
        campaigns = self.dm.get_available_campaigns()
        self.list_widget.addItems(campaigns)

    def load_campaign(self):
        current_item = self.list_widget.currentItem()
        if not current_item:
            QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_SELECT_WORLD_WARN"))
            return
            
        world_name = current_item.text()
        success, msg = self.dm.load_campaign_by_name(world_name)
        
        if success:
            self.selected_campaign = world_name
            self.accept()
        else:
            QMessageBox.critical(self, tr("MSG_ERROR"), msg)

    def create_campaign(self):
        name = self.inp_new_name.text().strip()
        if not name:
            QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_NAME_EMPTY"))
            return
            
        if name in self.dm.get_available_campaigns():
             QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_WORLD_EXISTS"))
             return

        success, msg = self.dm.create_campaign(name)
        if success:
            self.selected_campaign = name
            self.accept()
        else:
            QMessageBox.critical(self, tr("MSG_ERROR"), msg)

===== FILE PATH =====
./ui\player_window.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import QMainWindow, QWidget, QVBoxLayout, QStackedWidget, QTextBrowser
from PyQt6.QtCore import Qt, QUrl
from PyQt6.QtGui import QPixmap
# QWebEngineView is imported lazily in show_pdf() to prevent segfault on startup
from ui.widgets.image_viewer import ImageViewer

class PlayerWindow(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Player View - Second Screen")
        self.resize(800, 600)
        self.setStyleSheet("background-color: black;")
        
        central = QWidget()
        self.setCentralWidget(central)
        layout = QVBoxLayout(central)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # STACKED WIDGET (Sayfalar arasÄ± geÃ§iÅŸ iÃ§in)
        self.stack = QStackedWidget()
        
        # SAYFA 0: RESÄ°M GÃ–RÃœNTÃœLEYÄ°CÄ° (Zoom/Pan Ã¶zellikli)
        self.image_viewer = ImageViewer()
        self.stack.addWidget(self.image_viewer)
        
        # SAYFA 1: KARAKTER KARTI (HTML Stat Block)
        self.stat_viewer = QTextBrowser()
        self.stat_viewer.setStyleSheet("""
            QTextBrowser {
                background-color: #1a1a1a;
                color: #e0e0e0;
                border: none;
                padding: 20px;
                font-family: 'Segoe UI', serif;
            }
        """)
        self.stack.addWidget(self.stat_viewer)

        # SAYFA 2: PDF GÃ–RÃœNTÃœLEYÄ°CÄ° (WebEngine) - Lazy loaded
        # QWebEngineView is created on first use to avoid segfault on startup
        self.pdf_viewer = None
        self.pdf_viewer_index = None  # Track the stack index when created
        
        layout.addWidget(self.stack)

    def show_image(self, pixmap):
        """Sadece resmi gÃ¶sterir"""
        self.stack.setCurrentIndex(0)
        self.image_viewer.set_image(pixmap)

    def show_stat_block(self, html_content):
        """Karakter kartÄ±nÄ± (HTML) gÃ¶sterir"""
        self.stack.setCurrentIndex(1)
        self.stat_viewer.setHtml(html_content)

    def show_pdf(self, pdf_path):
        """PDF dosyasÄ±nÄ± gÃ¶sterir (lazy loads QWebEngineView on first use)"""
        # Lazy initialization: create QWebEngineView only when needed
        if self.pdf_viewer is None:
            from PyQt6.QtWebEngineWidgets import QWebEngineView
            self.pdf_viewer = QWebEngineView()
            self.pdf_viewer.setStyleSheet("background-color: #333;")
            self.stack.addWidget(self.pdf_viewer)
            self.pdf_viewer_index = self.stack.count() - 1
            
            # Enable PDF viewing settings
            self.pdf_viewer.settings().setAttribute(
                self.pdf_viewer.settings().WebAttribute.PluginsEnabled, True
            )
            self.pdf_viewer.settings().setAttribute(
                self.pdf_viewer.settings().WebAttribute.PdfViewerEnabled, True
            )
        
        # Switch to PDF viewer and load the file
        self.stack.setCurrentIndex(self.pdf_viewer_index)
        local_url = QUrl.fromLocalFile(pdf_path)
        self.pdf_viewer.setUrl(local_url)

    def update_theme(self, qss):
        """Uygulanan QSS'i pencereye yansÄ±tÄ±r"""
        self.setStyleSheet(qss)


===== FILE PATH =====
./ui\soundpad_panel.py
===== FILE CONTENT =====
import os
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QLabel, QFrame, QPushButton, 
                             QHBoxLayout, QSlider, QComboBox, QGroupBox, QScrollArea)
from PyQt6.QtCore import Qt
from core.locales import tr
from core.audio.engine import MusicBrain
from core.audio.loader import load_all_themes

class SoundpadPanel(QWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFixedWidth(320)
        self.setObjectName("soundpadContainer")
        
        # Ses Motoru
        self.audio_brain = MusicBrain()
        
        # Temalar
        self.themes = load_all_themes()
        self.current_theme = None
        
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        layout.setContentsMargins(10, 10, 10, 10)
        
        # BaÅŸlÄ±k
        self.lbl_title = QLabel("ðŸ”Š " + tr("TITLE_SOUNDPAD"))
        self.lbl_title.setObjectName("headerLabel")
        self.lbl_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.lbl_title.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 10px;")
        layout.addWidget(self.lbl_title)
        
        # --- Ä°Ã‡ERÄ°K ---
        self.content_frame = QFrame()
        self.content_frame.setStyleSheet("background-color: rgba(0, 0, 0, 0.2); border-radius: 6px;")
        self.v_box = QVBoxLayout(self.content_frame)
        
        if not self.themes:
            lbl_err = QLabel("No themes found.\nCheck assets/soundpad folder.")
            lbl_err.setStyleSheet("color: #ff5555; font-style: italic;")
            lbl_err.setAlignment(Qt.AlignmentFlag.AlignCenter)
            self.v_box.addWidget(lbl_err)
        else:
            # 1. Tema SeÃ§imi
            lbl_select = QLabel("Select Theme:")
            self.combo_themes = QComboBox()
            for tid, theme in self.themes.items():
                self.combo_themes.addItem(theme.name, tid)
            
            # Tema YÃ¼kle Butonu
            self.btn_load_theme = QPushButton("ðŸ“‚ Load Theme")
            self.btn_load_theme.setObjectName("primaryBtn")
            self.btn_load_theme.clicked.connect(self.load_selected_theme)
            
            self.v_box.addWidget(lbl_select)
            self.v_box.addWidget(self.combo_themes)
            self.v_box.addWidget(self.btn_load_theme)
            
            self.v_box.addSpacing(15)
            
            # 2. State (Mod) ButonlarÄ± AlanÄ± (Dinamik)
            self.grp_states = QGroupBox("Mood / State")
            self.grp_states.setStyleSheet("QGroupBox { font-weight: bold; border: 1px solid #555; margin-top: 5px; }")
            self.layout_states = QVBoxLayout(self.grp_states)
            self.v_box.addWidget(self.grp_states)
            self.grp_states.setVisible(False) # BaÅŸlangÄ±Ã§ta gizli
            
            self.v_box.addSpacing(15)
            
            # 3. Intensity Slider
            self.grp_intensity = QGroupBox("Intensity")
            self.grp_intensity.setStyleSheet("QGroupBox { font-weight: bold; border: 1px solid #555; margin-top: 5px; }")
            v_int = QVBoxLayout(self.grp_intensity)
            
            self.slider_intensity = QSlider(Qt.Orientation.Horizontal)
            self.slider_intensity.setRange(0, 2) # Base, Lv1, Lv2
            self.slider_intensity.setTickPosition(QSlider.TickPosition.TicksBelow)
            self.slider_intensity.setTickInterval(1)
            self.slider_intensity.setValue(0)
            self.slider_intensity.valueChanged.connect(self.change_intensity)
            
            self.lbl_intensity_val = QLabel("Base")
            self.lbl_intensity_val.setAlignment(Qt.AlignmentFlag.AlignCenter)
            
            v_int.addWidget(self.slider_intensity)
            v_int.addWidget(self.lbl_intensity_val)
            self.v_box.addWidget(self.grp_intensity)
            self.grp_intensity.setVisible(False) # BaÅŸlangÄ±Ã§ta gizli
            
            self.v_box.addStretch()
            
            # 4. Master Volume & Stop
            lbl_vol = QLabel("Master Volume")
            self.slider_vol = QSlider(Qt.Orientation.Horizontal)
            self.slider_vol.setRange(0, 100)
            self.slider_vol.setValue(50)
            self.slider_vol.valueChanged.connect(self.change_volume)
            
            self.btn_stop = QPushButton("â¹ï¸ Stop All")
            self.btn_stop.setObjectName("dangerBtn")
            self.btn_stop.clicked.connect(self.stop_all)
            
            self.v_box.addWidget(lbl_vol)
            self.v_box.addWidget(self.slider_vol)
            self.v_box.addSpacing(5)
            self.v_box.addWidget(self.btn_stop)

        layout.addWidget(self.content_frame)

    def load_selected_theme(self):
        tid = self.combo_themes.currentData()
        if tid in self.themes:
            self.current_theme = self.themes[tid]
            
            # Motoru gÃ¼ncelle
            self.audio_brain.set_theme(self.current_theme)
            
            # Slider sÄ±fÄ±rla
            self.slider_intensity.setValue(0)
            self.lbl_intensity_val.setText("Base")
            self.grp_intensity.setVisible(True)
            
            # State butonlarÄ±nÄ± oluÅŸtur
            self._rebuild_state_buttons()
            self.grp_states.setVisible(True)

    def _rebuild_state_buttons(self):
        # Temizle
        while self.layout_states.count():
            child = self.layout_states.takeAt(0)
            if child.widget(): child.widget().deleteLater()
        
        if not self.current_theme: return

        # ButonlarÄ± Sakla (Daha sonra ikon deÄŸiÅŸtirmek iÃ§in)
        self.state_buttons = {} 

        for state_name in self.current_theme.states.keys():
            btn = QPushButton(state_name.title())
            btn.setCheckable(True) # BasÄ±lÄ± kalma Ã¶zelliÄŸi
            
            # Renkler
            if state_name.lower() == "combat": btn.setObjectName("dangerBtn")
            elif state_name.lower() == "victory": btn.setObjectName("successBtn")
            else: btn.setObjectName("primaryBtn")
            
            # TÄ±klama olayÄ±
            btn.clicked.connect(lambda ch, s=state_name: self.on_state_clicked(s))
            
            self.layout_states.addWidget(btn)
            self.state_buttons[state_name] = btn

    def on_state_clicked(self, state_name):
        """
        1. TÄ±k: KuyruÄŸa al (Ä°konu â³ yap)
        2. TÄ±k: Hemen geÃ§ (Zorla)
        """
        # Åžu anki durumu kontrol et
        current_id = self.audio_brain.current_state_id
        pending_id = self.audio_brain.pending_state_id
        
        # EÄŸer zaten bu moddaysak ve bekleyen bir ÅŸey yoksa iÅŸlem yapma
        if state_name == current_id and pending_id is None:
            # Buton basÄ±lÄ± kaldÄ±ysa geri kaldÄ±r
            self.state_buttons[state_name].setChecked(True)
            return

        # SENARYO 1: Zaten kuyruktaysa -> Hemen GeÃ§ (Force)
        if state_name == pending_id:
            self.audio_brain.force_transition()
            # Ä°konu normale dÃ¶ndÃ¼r (GeÃ§iÅŸ baÅŸlayÄ±nca resetlenecek)
            self.state_buttons[state_name].setText(state_name.title() + " ðŸš€")
            return

        # SENARYO 2: Ä°lk defa tÄ±klandÄ± -> KuyruÄŸa Al
        self.audio_brain.queue_state(state_name)
        
        # GÃ¶rsel Geri Bildirim
        for name, btn in self.state_buttons.items():
            if name == state_name:
                btn.setText(name.title() + " â³") # Kum saati
                btn.setChecked(True)
            elif name == current_id:
                btn.setText(name.title()) # Mevcut olan normal kalsÄ±n
                btn.setChecked(True)
            else:
                btn.setText(name.title())
                btn.setChecked(False)

    def change_intensity(self, val):
        labels = ["Base", "Low", "High", "Epic"]
        text = labels[val] if val < len(labels) else str(val)
        self.lbl_intensity_val.setText(text)
        
        self.audio_brain.set_intensity(val)

    def change_volume(self, val):
        self.audio_brain.set_volume(val / 100.0)

    def stop_all(self):
        self.audio_brain.stop()

    def retranslate_ui(self):
        self.lbl_title.setText("ðŸ”Š " + tr("TITLE_SOUNDPAD"))

===== FILE PATH =====
./ui\workers.py
===== FILE CONTENT =====
from PyQt6.QtCore import QThread, pyqtSignal

class ApiSearchWorker(QThread):
    finished = pyqtSignal(bool, object, str) # success, data, message

    def __init__(self, data_manager, category, query):
        super().__init__()
        self.data_manager = data_manager
        self.category = category
        self.query = query

    def run(self):
        try:
            # fetch_from_api artÄ±k ya (True, msg, ID) dÃ¶nÃ¼yor (zaten varsa)
            # ya da (True, msg, DATA_DICT) dÃ¶nÃ¼yor (yeni Ã§ekildiyse)
            success, msg, result = self.data_manager.fetch_from_api(self.category, self.query)
            self.finished.emit(success, result, msg)
        except Exception as e:
            self.finished.emit(False, {}, str(e))

class ApiListWorker(QThread):
    finished = pyqtSignal(list)

    def __init__(self, api_client, category):
        super().__init__()
        self.api_client = api_client
        self.category = category

    def run(self):
        data = self.api_client.get_list(self.category)
        self.finished.emit(data)


===== FILE PATH =====
./ui\dialogs\api_browser.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QListWidget, 
                             QLineEdit, QPushButton, QLabel, QTextEdit, 
                             QMessageBox, QListWidgetItem, QSplitter, QWidget, QApplication)
from PyQt6.QtCore import Qt
from ui.workers import ApiListWorker, ApiSearchWorker
from core.locales import tr

class ApiBrowser(QDialog):
    def __init__(self, data_manager, category, parent=None):
        super().__init__(parent)
        self.dm = data_manager
        self.category = category
        self.selected_data = None
        
        self.setWindowTitle(f"{tr('TITLE_API')}: {category}")
        self.resize(900, 600)
        
        # Hardcoded stil bloÄŸu KALDIRILDI. 
        # TÃ¼m renkler ve ÅŸekiller artÄ±k QSS dosyalarÄ±ndan (dark.qss vb.) yÃ¼klenecek.
        
        self.full_list = [] # API'den gelen ham liste
        self.init_ui()
        self.load_list()

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        
        # Ãœst: Arama
        self.inp_filter = QLineEdit()
        self.inp_filter.setPlaceholderText(f"{tr('LBL_SEARCH_API')} ({self.category})")
        self.inp_filter.textChanged.connect(self.filter_list)
        main_layout.addWidget(self.inp_filter)
        
        # Orta: Splitter (Liste | Ã–nizleme)
        splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Sol: Liste
        self.list_widget = QListWidget()
        self.list_widget.itemClicked.connect(self.on_item_clicked)
        splitter.addWidget(self.list_widget)
        
        # SaÄŸ: Ã–nizleme
        preview_widget = QWidget()
        prev_layout = QVBoxLayout(preview_widget)
        prev_layout.setContentsMargins(10, 0, 0, 0) # Sol taraftan biraz boÅŸluk bÄ±rak
        
        self.lbl_name = QLabel(tr("MSG_NO_SELECTION"))
        # BaÅŸlÄ±k iÃ§in ID atÄ±yoruz (Temalarda Ã¶zelleÅŸtirilebilir)
        self.lbl_name.setObjectName("headerLabel")
        # Sadece font bÃ¼yÃ¼klÃ¼ÄŸÃ¼nÃ¼ ve kalÄ±nlÄ±ÄŸÄ±nÄ± burada belirtiyoruz, rengi temaya bÄ±rakÄ±yoruz.
        self.lbl_name.setStyleSheet("font-size: 18px; font-weight: bold; margin-bottom: 5px;")
        
        self.txt_desc = QTextEdit()
        self.txt_desc.setReadOnly(True)
        
        btn_layout = QHBoxLayout()
        self.btn_import = QPushButton(tr("BTN_IMPORT"))
        # Temadan "YeÅŸil Buton" stilini almasÄ± iÃ§in ID:
        self.btn_import.setObjectName("successBtn")
        self.btn_import.setEnabled(False)
        self.btn_import.clicked.connect(self.import_selected)
        
        self.btn_import_npc = QPushButton(tr("BTN_IMPORT_NPC"))
        # Temadan "Mavi/Ana Buton" stilini almasÄ± iÃ§in ID:
        self.btn_import_npc.setObjectName("primaryBtn")
        self.btn_import_npc.setVisible(False)
        self.btn_import_npc.clicked.connect(lambda: self.import_selected(target_type="NPC"))
        
        btn_layout.addWidget(self.btn_import)
        btn_layout.addWidget(self.btn_import_npc)
        
        prev_layout.addWidget(self.lbl_name)
        prev_layout.addWidget(self.txt_desc)
        prev_layout.addLayout(btn_layout)
        
        splitter.addWidget(preview_widget)
        splitter.setSizes([300, 600])
        
        main_layout.addWidget(splitter)

    def load_list(self):
        self.list_widget.clear()
        self.lbl_name.setText(tr("MSG_LOADING"))
        self.setEnabled(False)
        
        # Worker ile listeyi Ã§ek
        self.list_worker = ApiListWorker(self.dm.api_client, self.category)
        self.list_worker.finished.connect(self.on_list_loaded)
        self.list_worker.start()

    def on_list_loaded(self, data):
        self.setEnabled(True)
        self.lbl_name.setText(tr("MSG_NO_SELECTION"))
        self.full_list = data
        
        if not self.full_list:
            QMessageBox.information(self, tr("MSG_WARNING"), tr("MSG_LIST_EMPTY"))
            return

        # Listeyi doldur
        for item in self.full_list:
            list_item = QListWidgetItem(item["name"])
            list_item.setData(Qt.ItemDataRole.UserRole, item["index"])
            self.list_widget.addItem(list_item)

    def filter_list(self):
        query = self.inp_filter.text().lower()
        self.list_widget.clear()
        for item in self.full_list:
            if query in item["name"].lower():
                list_item = QListWidgetItem(item["name"])
                list_item.setData(Qt.ItemDataRole.UserRole, item["index"])
                self.list_widget.addItem(list_item)

    def on_item_clicked(self, item):
        index_name = item.data(Qt.ItemDataRole.UserRole)
        
        # KullanÄ±cÄ±ya "YÃ¼kleniyor..." hissi ver
        self.lbl_name.setText(item.text() + f" ({tr('MSG_LOADING')})")
        self.txt_desc.clear()
        self.btn_import.setEnabled(False)
        self.list_widget.setEnabled(False)
        
        # Worker ile detaylarÄ± Ã§ek
        self.detail_worker = ApiSearchWorker(self.dm, self.category, index_name)
        self.detail_worker.finished.connect(self.on_details_loaded)
        self.detail_worker.start()

    def on_details_loaded(self, success, data_or_id, msg):
        self.list_widget.setEnabled(True)
        
        if success:
            if isinstance(data_or_id, str):
                # Zaten veritabanÄ±nda var, ID gelmiÅŸ
                data = self.dm.data["entities"].get(data_or_id)
                self.btn_import.setEnabled(False)
                self.btn_import.setText(tr("MSG_EXISTS"))
                self.btn_import_npc.setVisible(False)
            else:
                # Yeni veri
                data = data_or_id
                self.btn_import.setEnabled(True)
                
            if not data:
                self.lbl_name.setText(tr("MSG_ERROR"))
                self.txt_desc.setText(tr("BulunamadÄ±."))
                return

            self.selected_data = data
            self.lbl_name.setText(data.get("name"))
            
            # Monster ise butonlarÄ± kategoriye gÃ¶re ayarla
            try: self.btn_import.clicked.disconnect()
            except: pass
            
            if self.category == "NPC":
                # NPC kategorisinden aÃ§Ä±ldÄ±ysa direkt NPC olarak aktar
                self.btn_import.setText(tr("BTN_IMPORT_NPC"))
                self.btn_import.clicked.connect(lambda: self.import_selected(target_type="NPC"))
                self.btn_import_npc.setVisible(False)
            elif self.category == "Monster":
                # Monster kategorisinden aÃ§Ä±ldÄ±ysa varsayÄ±lan Monster (ama NPC seÃ§eneÄŸi de var)
                self.btn_import.setText(tr("BTN_IMPORT"))
                self.btn_import.clicked.connect(lambda: self.import_selected(target_type=None))
                
                if not isinstance(data_or_id, str):
                    self.btn_import_npc.setVisible(True)
                    self.btn_import_npc.setEnabled(True)
                else:
                    self.btn_import_npc.setVisible(False)
            else:
                # DiÄŸer kategoriler (BÃ¼yÃ¼, EÅŸya vb.)
                self.btn_import.setText(tr("BTN_IMPORT"))
                self.btn_import.clicked.connect(lambda: self.import_selected(target_type=None))
                self.btn_import_npc.setVisible(False)

            # AÃ§Ä±klamayÄ± oluÅŸtur
            desc = f"{tr('LBL_TYPE')}: {tr('CAT_' + data.get('type', '').upper())}\n\n"
            desc += data.get("description", "")
            
            # Statlar vs varsa ekle
            if "attributes" in data:
                desc += f"\n\n--- {tr('LBL_PROPERTIES')} ---\n"
                for k, v in data["attributes"].items():
                    val = tr(v) if str(v).startswith("LBL_") else v
                    desc += f"{tr(k)}: {val}\n"
            
            self.txt_desc.setText(desc)
        else:
            self.lbl_name.setText(tr("MSG_ERROR"))
            self.txt_desc.setText(msg)
            self.btn_import.setEnabled(False)

    def import_selected(self, target_type=None):
        if self.selected_data:
            # KullanÄ±cÄ±ya geri bildirim ver
            self.btn_import.setEnabled(False)
            self.btn_import_npc.setEnabled(False)
            self.btn_import.setText(tr("MSG_IMPORTING"))
            QApplication.processEvents() # ArayÃ¼zÃ¼n donmamasÄ± iÃ§in
            
            try:
                # AsÄ±l kaydetme iÅŸlemini yap (bÃ¼yÃ¼lerle birlikte)
                self.dm.import_entity_with_dependencies(self.selected_data, type_override=target_type)
                
                QMessageBox.information(self, tr("MSG_SUCCESS"), tr("MSG_IMPORT_SUCCESS_DETAIL", name=self.selected_data['name']))
                self.accept()
            except Exception as e:
                self.btn_import.setEnabled(True)
                self.btn_import.setText(tr("BTN_IMPORT"))
                QMessageBox.critical(self, tr("MSG_ERROR"), f"Hata oluÅŸtu: {str(e)}")

===== FILE PATH =====
./ui\dialogs\bulk_downloader.py
===== FILE CONTENT =====
import os
import json
import requests
import time
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QLabel, QProgressBar, 
                             QPushButton, QTextEdit, QMessageBox)
from PyQt6.QtCore import Qt, QThread, pyqtSignal
from config import BASE_DIR, API_BASE_URL
from core.locales import tr

# KÃ¼tÃ¼phane deposu
LIBRARY_DIR = os.path.join(BASE_DIR, "cache", "library")

class DownloadWorker(QThread):
    progress_signal = pyqtSignal(int)
    log_signal = pyqtSignal(str)
    finished_signal = pyqtSignal()

    def __init__(self):
        super().__init__()
        self.is_running = True
        
        # Ä°ndirilecek tÃ¼m kategoriler ve API uÃ§ noktalarÄ± (Endpoints)
        # Not: 'equipment' endpoint'i; Weapons, Armor, Adventuring Gear, Tools ve Mounts'u kapsar.
        # 'magic-items' ise tÃ¼m bÃ¼yÃ¼lÃ¼ eÅŸyalarÄ± kapsar. Bu ikisi toplam %100 eÅŸya kapsamÄ± saÄŸlar.
        self.categories = {
            "monsters": tr("CAT_MONSTERS_PL"),
            "spells": tr("CAT_SPELLS_PL"),
            "equipment": tr("CAT_EQUIPMENT_ALL"), 
            "magic-items": tr("CAT_MAGIC_ITEMS_ALL"),
            "classes": tr("CAT_CLASSES_PL"),
            "races": tr("CAT_RACES_PL")
        }

    def run(self):
        self.log_signal.emit(tr("LOG_STARTING"))
        
        # 1. KlasÃ¶rleri HazÄ±rla
        for endpoint in self.categories.keys():
            path = os.path.join(LIBRARY_DIR, endpoint)
            if not os.path.exists(path):
                os.makedirs(path)

        session = requests.Session()
        
        # AdÄ±m 1: TÃ¼m Listeleri (Index) Ã‡ek
        total_items_to_download = 0
        lists_to_process = {}
        
        for endpoint, label in self.categories.items():
            if not self.is_running: break
            
            self.log_signal.emit(tr("LOG_SCANNING", label=label))
            try:
                # API'den tÃ¼m listeyi Ã§ek
                url = f"{API_BASE_URL}/{endpoint}"
                resp = session.get(url, timeout=10)
                
                if resp.status_code == 200:
                    data = resp.json()
                    items = data.get("results", [])
                    lists_to_process[endpoint] = items
                    total_items_to_download += len(items)
                    
                    # Ä°ndex dosyasÄ±nÄ± (arama listesi) gÃ¼ncelle
                    self._save_index(endpoint, items)
                else:
                    self.log_signal.emit(tr("LOG_ERROR_LIST", label=label, code=resp.status_code))
                    
            except Exception as e:
                self.log_signal.emit(tr("LOG_CONN_ERROR", label=label, error=str(e)))

        self.log_signal.emit(tr("LOG_TOTAL_ITEMS", count=total_items_to_download))
        
        # AdÄ±m 2: Her Bir Ã–ÄŸenin DetayÄ±nÄ± Ä°ndir
        current_count = 0
        
        for endpoint, items in lists_to_process.items():
            folder_path = os.path.join(LIBRARY_DIR, endpoint)
            label = self.categories[endpoint]
            
            label = self.categories[endpoint]
            
            self.log_signal.emit(tr("LOG_DOWNLOADING", label=label, count=len(items)))
            
            for item in items:
                if not self.is_running: break
                
                index = item["index"]
                file_path = os.path.join(folder_path, f"{index}.json")
                
                # EÄŸer dosya zaten varsa ve boyutu 0 deÄŸilse atla (Zaman tasarrufu)
                if os.path.exists(file_path) and os.path.getsize(file_path) > 0:
                    current_count += 1
                    # Her 50 itemde bir arayÃ¼zÃ¼ gÃ¼ncelle ki donmasÄ±n
                    if current_count % 10 == 0:
                        self._update_progress(current_count, total_items_to_download)
                    continue

                # API'den Detay Ã‡ek
                try:
                    url = f"{API_BASE_URL}/{endpoint}/{index}"
                    resp = session.get(url, timeout=5)
                    
                    if resp.status_code == 200:
                        with open(file_path, "w", encoding="utf-8") as f:
                            json.dump(resp.json(), f, indent=4)
                    else:
                        self.log_signal.emit(tr("LOG_ERROR_ITEM", name=item.get('name'), code=resp.status_code))
                    
                    # API'yi boÄŸmamak iÃ§in minik bekleme
                    time.sleep(0.05)
                    
                except Exception as e:
                    self.log_signal.emit(tr("LOG_ERROR_GENERAL", name=item.get('name'), error=str(e)))

                current_count += 1
                if current_count % 5 == 0: # Her 5 indirmede bir progress gÃ¼ncelle
                    self._update_progress(current_count, total_items_to_download)

        self.finished_signal.emit()

    def _update_progress(self, current, total):
        if total > 0:
            percent = int((current / total) * 100)
            self.progress_signal.emit(percent)

    def _save_index(self, endpoint, new_items):
        """
        API'den gelen listeyi 'reference_indexes.json' dosyasÄ±na kaydeder.
        Ã–NEMLÄ°: 'equipment' ve 'magic-items' kategorilerini 'EÅŸya (Equipment)' altÄ±nda birleÅŸtirir.
        BÃ¶ylece Ã§evrimdÄ±ÅŸÄ± aramada hepsi tek listede Ã§Ä±kar.
        """
        index_file = os.path.join(BASE_DIR, "cache", "reference_indexes.json")
        full_index = {}
        
        # Mevcut index dosyasÄ±nÄ± oku
        if os.path.exists(index_file):
            try:
                with open(index_file, "r", encoding="utf-8") as f:
                    full_index = json.load(f)
            except:
                full_index = {}

        # Bizim uygulamanÄ±n kullandÄ±ÄŸÄ± kategori anahtarlarÄ±
        key_map = {
            "monsters": "Canavar",
            "spells": "BÃ¼yÃ¼ (Spell)",
            "equipment": "EÅŸya (Equipment)",
            "magic-items": "EÅŸya (Equipment)", # DÄ°KKAT: Ä°kisini de aynÄ± yere kaydediyoruz
            "classes": "SÄ±nÄ±f (Class)",
            "races": "Irk (Race)"
        }
        
        app_key = key_map.get(endpoint)
        if app_key:
            # EÄŸer bu kategori zaten varsa, Ã¼zerine yazma mantÄ±ÄŸÄ±
            if app_key == "EÅŸya (Equipment)":
                # Equipment ve Magic Items birleÅŸtirme mantÄ±ÄŸÄ±
                existing_list = full_index.get(app_key, [])
                
                # Mevcut listedeki indexleri (ID) bir set'e at ki duplicate olmasÄ±n
                existing_ids = {i["index"] for i in existing_list}
                
                # Yeni gelenleri ekle
                for item in new_items:
                    if item["index"] not in existing_ids:
                        existing_list.append(item)
                        existing_ids.add(item["index"])
                
                full_index[app_key] = existing_list
            else:
                # DiÄŸer kategoriler iÃ§in direkt overwrite (gÃ¼ncel liste)
                full_index[app_key] = new_items

        # DosyayÄ± kaydet
        try:
            with open(index_file, "w", encoding="utf-8") as f:
                json.dump(full_index, f, indent=4)
        except Exception as e:
            print(f"Index kayÄ±t hatasÄ±: {e}")

    def stop(self):
        self.is_running = False

class BulkDownloadDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle(tr("TITLE_DOWNLOADER"))
        self.setFixedSize(600, 500)
        self.setStyleSheet("background-color: #1e1e1e; color: white;")
        
        self.worker = None
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # Bilgi Etiketi
        lbl_info = QLabel(tr("LBL_DOWNLOADER_DESC"))
        lbl_info.setWordWrap(True)
        lbl_info.setStyleSheet("color: #e0e0e0; margin-bottom: 10px;")
        layout.addWidget(lbl_info)
        
        # Ä°lerleme Ã‡ubuÄŸu
        self.progress_bar = QProgressBar()
        self.progress_bar.setValue(0)
        self.progress_bar.setStyleSheet("""
            QProgressBar { 
                border: 2px solid #444; 
                border-radius: 5px; 
                text-align: center; 
                background-color: #222;
                color: white;
                height: 25px;
            }
            QProgressBar::chunk { 
                background-color: #2e7d32; 
                width: 20px; 
            }
        """)
        layout.addWidget(self.progress_bar)
        
        # Log Penceresi
        self.txt_log = QTextEdit()
        self.txt_log.setReadOnly(True)
        self.txt_log.setStyleSheet("""
            background-color: #121212; 
            border: 1px solid #333; 
            font-family: 'Consolas', monospace; 
            font-size: 12px; 
            color: #bbb;
        """)
        layout.addWidget(self.txt_log)
        
        # BaÅŸlat Butonu
        self.btn_start = QPushButton(tr("BTN_START_DOWNLOAD"))
        self.btn_start.setStyleSheet("""
            QPushButton {
                background-color: #0d47a1; 
                color: white; 
                padding: 12px; 
                font-weight: bold; 
                font-size: 14px;
                border-radius: 4px;
            }
            QPushButton:hover { background-color: #1565c0; }
            QPushButton:disabled { background-color: #444; color: #888; }
        """)
        self.btn_start.clicked.connect(self.start_download)
        layout.addWidget(self.btn_start)

    def start_download(self):
        self.btn_start.setEnabled(False)
        self.btn_start.setText(tr("MSG_DOWNLOADING_WAIT"))
        self.txt_log.clear()
        
        self.worker = DownloadWorker()
        self.worker.progress_signal.connect(self.update_progress)
        self.worker.log_signal.connect(self.update_log)
        self.worker.finished_signal.connect(self.on_finished)
        self.worker.start()

    def update_progress(self, val):
        self.progress_bar.setValue(val)

    def update_log(self, text):
        self.txt_log.append(text)
        # Otomatik en alta kaydÄ±r
        sb = self.txt_log.verticalScrollBar()
        sb.setValue(sb.maximum())

    def on_finished(self):
        self.btn_start.setText(tr("MSG_DOWNLOAD_FINISHED"))
        self.btn_start.setEnabled(True)
        self.progress_bar.setValue(100)
        if self.parent() and hasattr(self.parent(), "dm"):
            self.parent().dm.reload_library_cache()
            
        QMessageBox.information(self, tr("MSG_SUCCESS"), tr("MSG_DOWNLOAD_COMPLETE"))

    def closeEvent(self, event):
        if self.worker and self.worker.isRunning():
            reply = QMessageBox.question(self, tr("BTN_CANCEL"), 
                                       tr("MSG_CONFIRM_CLOSE_DOWNLOAD"),
                                       QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No)
            if reply == QMessageBox.StandardButton.Yes:
                self.worker.stop()
                self.worker.wait()
                event.accept()
            else:
                event.ignore()
        else:
            event.accept()

===== FILE PATH =====
./ui\dialogs\encounter_selector.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, 
                             QTableWidgetItem, QHeaderView, QPushButton, QLineEdit, 
                             QComboBox, QLabel, QSpinBox, QAbstractItemView, QFrame)
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QColor, QBrush
from core.locales import tr

class EncounterSelectionDialog(QDialog):
    def __init__(self, data_manager, parent=None):
        super().__init__(parent)
        self.dm = data_manager
        self.selected_entities = [] 
        
        self.setWindowTitle(tr("TITLE_ADD_COMBAT"))
        self.resize(800, 600)
        # Stil QSS'den gelecek, buraya yazmÄ±yoruz.
        
        self.init_ui()
        self.load_data()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # --- ÃœST FÄ°LTRE ALANI ---
        filter_layout = QHBoxLayout()
        
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText(tr("PH_SEARCH_NAME_TAG"))
        self.inp_search.textChanged.connect(self.filter_table)
        
        self.combo_type = QComboBox()
        self.combo_type.addItem(tr("LBL_TYPE_ALL"), "TÃ¼mÃ¼")
        self.combo_type.addItem(tr("CAT_NPC"), "NPC")
        self.combo_type.addItem(tr("CAT_MONSTER"), "Monster") # Data 'Monster' olduÄŸu iÃ§in value 'Monster' kalmalÄ±
        self.combo_type.addItem(tr("CAT_PLAYER"), "Player")
        
        self.combo_type.currentTextChanged.connect(self.filter_table)
        
        filter_layout.addWidget(QLabel("ðŸ”"))
        filter_layout.addWidget(self.inp_search, 3)
        filter_layout.addWidget(QLabel(f"{tr('LBL_TYPE')}:"))
        filter_layout.addWidget(self.combo_type, 1)
        
        layout.addLayout(filter_layout)
        
        # --- ORTA TABLO ALANI ---
        self.table = QTableWidget()
        self.table.setColumnCount(6)
        # BaÅŸlÄ±klar
        headers = [tr("HEADER_NAME"), tr("LBL_TYPE"), tr("LBL_HP"), tr("LBL_AC"), tr("HEADER_INIT_BONUS"), "ID"]
        self.table.setHorizontalHeaderLabels(headers)
        self.table.hideColumn(5) # ID sÃ¼tunu gizli
        
        # Tablo AyarlarÄ±
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.SelectionMode.ExtendedSelection)
        self.table.setSortingEnabled(True)
        self.table.setEditTriggers(QAbstractItemView.EditTrigger.NoEditTriggers)
        self.table.doubleClicked.connect(self.add_and_close)
        
        layout.addWidget(self.table)
        
        # --- ALT AKSÄ°YON ALANI ---
        action_layout = QHBoxLayout()
        self.lbl_count = QLabel(tr("LBL_ADD_COUNT"))
        self.spin_count = QSpinBox()
        self.spin_count.setRange(1, 20)
        self.spin_count.setValue(1)
        self.spin_count.setFixedWidth(60)
        
        self.btn_add = QPushButton(tr("BTN_ADD_SELECTED"))
        self.btn_add.setObjectName("successBtn")
        self.btn_add.clicked.connect(self.accept_selection)
        
        action_layout.addStretch()
        action_layout.addWidget(self.lbl_count)
        action_layout.addWidget(self.spin_count)
        action_layout.addWidget(self.btn_add)
        
        layout.addLayout(action_layout)

    def _parse_int(self, value):
        """Metin iÃ§indeki ilk sayÄ±yÄ± alÄ±r (Ã–rn: '45 (5d10)' -> 45)"""
        if not value: return 0
        try:
            # BoÅŸluktan bÃ¶l ve ilk kÄ±smÄ± al
            first_part = str(value).split(' ')[0]
            # Sadece rakamlarÄ± filtrele (Ã–rn: '14,' -> '14')
            clean_num = ''.join(filter(str.isdigit, first_part))
            return int(clean_num) if clean_num else 0
        except:
            return 0

    def load_data(self):
        self.table.setRowCount(0)
        entities = self.dm.data["entities"]
        
        # Verileri sÄ±ralama kolaylÄ±ÄŸÄ± iÃ§in Ã¶nce listeye alalÄ±m (Opsiyonel ama temiz olur)
        # Ancak direkt dÃ¶ngÃ¼ de olur.
        
        for eid, data in entities.items():
            etype = data.get("type", "NPC")
            
            # Sadece savaÅŸÃ§Ä± tipleri listele
            if etype not in ["NPC", "Monster", "Canavar", "Player", "Oyuncu"]:
                continue
                
            name = data.get("name", tr("NAME_UNNAMED"))
            tags = " ".join(data.get("tags", [])).lower()
            
            # StatlarÄ± Ã‡ek ve Temizle
            c_stats = data.get("combat_stats", {})
            
            raw_hp = c_stats.get("hp", "10")
            raw_ac = c_stats.get("ac", "10")
            
            # TemizlenmiÅŸ (SayÄ±sal) DeÄŸerler (SÄ±ralama iÃ§in kullanÄ±labilir)
            hp_val = self._parse_int(raw_hp)
            ac_val = self._parse_int(raw_ac)
            
            # Ä°nisiyatif Bonusu Hesapla
            stats = data.get("stats", {})
            dex = int(stats.get("DEX", 10))
            dex_mod = (dex - 10) // 2
            
            extra_init = self._parse_int(c_stats.get("initiative") or c_stats.get("init_bonus") or 0)
            total_init_bonus = dex_mod + extra_init
            
            sign = "+" if total_init_bonus >= 0 else ""
            init_str = f"{sign}{total_init_bonus}"
            
            # Tabloya Ekle
            row = self.table.rowCount()
            self.table.insertRow(row)
            
            # 0: Ä°sim
            item_name = QTableWidgetItem(name)
            # Arama iÃ§in gizli veri (Ä°sim + Tag + Tip)
            search_data = f"{name.lower()} {tags} {etype.lower()}"
            item_name.setData(Qt.ItemDataRole.UserRole, search_data)
            self.table.setItem(row, 0, item_name)
            
            # 1: Tip
            self.table.setItem(row, 1, QTableWidgetItem(etype))
            
            # 2: HP (SayÄ±sal sÄ±ralama iÃ§in setData kullanÄ±yoruz)
            item_hp = QTableWidgetItem(str(hp_val))
            item_hp.setData(Qt.ItemDataRole.DisplayRole, hp_val) # SayÄ±sal sÄ±ralama
            item_hp.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, 2, item_hp)
            
            # 3: AC
            item_ac = QTableWidgetItem(str(ac_val))
            item_ac.setData(Qt.ItemDataRole.DisplayRole, ac_val)
            item_ac.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            self.table.setItem(row, 3, item_ac)
            
            # 4: Init Bonus
            item_init = QTableWidgetItem(init_str)
            item_init.setData(Qt.ItemDataRole.DisplayRole, total_init_bonus)
            item_init.setTextAlignment(Qt.AlignmentFlag.AlignCenter)
            if total_init_bonus > 0:
                item_init.setForeground(QBrush(QColor("#4caf50"))) # YeÅŸil
            elif total_init_bonus < 0:
                item_init.setForeground(QBrush(QColor("#ef5350"))) # KÄ±rmÄ±zÄ±
            self.table.setItem(row, 4, item_init)
            
            # 5: ID (Gizli)
            self.table.setItem(row, 5, QTableWidgetItem(eid))

    def filter_table(self):
        search_text = self.inp_search.text().lower()
        # Combo data (TÃ¼mÃ¼, NPC, Monster, Player)
        filter_type = self.combo_type.currentData() 
        
        # Tip eÅŸleÅŸtirme haritasÄ± (Data'daki tip ile filtre arasÄ±ndaki iliÅŸki)
        mapping = {
            "NPC": ["NPC"], 
            "Monster": ["Monster", "Canavar"], 
            "Player": ["Player", "Oyuncu"]
        }
        allowed_types = mapping.get(filter_type, [])
        
        for row in range(self.table.rowCount()):
            # Gizli arama verisi (isim + tagler)
            row_search_data = self.table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            row_type_text = self.table.item(row, 1).text()
            
            match_text = search_text in row_search_data
            match_type = (filter_type == "TÃ¼mÃ¼") or (row_type_text in allowed_types)
            
            self.table.setRowHidden(row, not (match_text and match_type))

    def accept_selection(self):
        selected_rows = self.table.selectionModel().selectedRows()
        if not selected_rows: return
            
        count = self.spin_count.value()
        for index in selected_rows:
            row = index.row()
            eid = self.table.item(row, 5).text()
            for _ in range(count):
                self.selected_entities.append(eid)
        self.accept()

    def add_and_close(self):
        row = self.table.currentRow()
        if row >= 0:
            eid = self.table.item(row, 5).text()
            self.selected_entities.append(eid)
            self.accept()

===== FILE PATH =====
./ui\dialogs\entity_selector.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import (QDialog, QVBoxLayout, QHBoxLayout, QTableWidget, 
                             QTableWidgetItem, QPushButton, QLineEdit, QHeaderView,
                             QAbstractItemView)
from PyQt6.QtCore import Qt
from core.locales import tr

class EntitySelectorDialog(QDialog):
    def __init__(self, data_manager, parent=None):
        super().__init__(parent)
        self.dm = data_manager
        self.selected_entities = [] # SeÃ§ilenlerin ID listesi
        
        self.setWindowTitle("SavaÅŸa VarlÄ±k Ekle")
        self.resize(700, 500)
        self.setStyleSheet("background-color: #1e1e1e; color: white;")
        
        self.init_ui()
        self.load_data()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # Arama
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText(tr("LBL_SEARCH"))
        self.inp_search.setStyleSheet("padding: 8px; background-color: #333; border: 1px solid #555;")
        self.inp_search.textChanged.connect(self.filter_list)
        layout.addWidget(self.inp_search)
        
        # Tablo
        self.table = QTableWidget()
        self.table.setColumnCount(5)
        self.table.setHorizontalHeaderLabels([tr("HEADER_NAME"), tr("LBL_TYPE"), "HP", "AC", "Init Bonus"])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.table.setSelectionBehavior(QAbstractItemView.SelectionBehavior.SelectRows)
        self.table.setSelectionMode(QAbstractItemView.SelectionMode.MultiSelection) # Ã‡OKLU SEÃ‡Ä°M
        self.table.setStyleSheet("""
            QTableWidget { background-color: #252526; border: 1px solid #444; gridline-color: #444; }
            QTableWidget::item:selected { background-color: #2e7d32; color: white; }
            QHeaderView::section { background-color: #333; padding: 4px; border: 1px solid #444; }
        """)
        layout.addWidget(self.table)
        
        # Butonlar
        btn_layout = QHBoxLayout()
        self.btn_cancel = QPushButton(tr("BTN_CANCEL"))
        self.btn_cancel.clicked.connect(self.reject)
        self.btn_cancel.setStyleSheet("padding: 10px; background-color: #d32f2f; color: white;")
        
        self.btn_add = QPushButton(tr("BTN_ADD"))
        self.btn_add.clicked.connect(self.add_selected)
        self.btn_add.setStyleSheet("padding: 10px; background-color: #388e3c; color: white; font-weight: bold;")
        
        btn_layout.addStretch()
        btn_layout.addWidget(self.btn_cancel)
        btn_layout.addWidget(self.btn_add)
        layout.addLayout(btn_layout)

    def load_data(self):
        self.table.setRowCount(0)
        entities = self.dm.data["entities"]
        
        row = 0
        for eid, data in entities.items():
            etype = data.get("type", "NPC")
            # Sadece savaÅŸa girebilecekleri listele
            if etype not in ["NPC", "Monster", "Player"]:
                continue
                
            self.table.insertRow(row)
            
            # Verileri Ã§ek
            name = data.get("name", "Unknown")
            c_stats = data.get("combat_stats", {})
            hp = str(c_stats.get("hp", "-"))
            ac = str(c_stats.get("ac", "-"))
            
            # Ä°nisiyatif Bonusu Hesapla (DEX mod + manuel bonus)
            dex = int(data.get("stats", {}).get("DEX", 10))
            dex_mod = (dex - 10) // 2
            extra = int(c_stats.get("initiative") or 0)
            total_bonus = dex_mod + extra
            bonus_str = f"+{total_bonus}" if total_bonus >= 0 else str(total_bonus)
            
            # Tabloya yaz
            item_name = QTableWidgetItem(name)
            item_name.setData(Qt.ItemDataRole.UserRole, eid) # ID sakla
            
            self.table.setItem(row, 0, item_name)
            self.table.setItem(row, 1, QTableWidgetItem(etype))
            self.table.setItem(row, 2, QTableWidgetItem(hp))
            self.table.setItem(row, 3, QTableWidgetItem(ac))
            self.table.setItem(row, 4, QTableWidgetItem(bonus_str))
            
            row += 1

    def filter_list(self):
        query = self.inp_search.text().lower()
        for i in range(self.table.rowCount()):
            name = self.table.item(i, 0).text().lower()
            if query in name:
                self.table.setRowHidden(i, False)
            else:
                self.table.setRowHidden(i, True)

    def add_selected(self):
        selected_rows = self.table.selectionModel().selectedRows()
        if not selected_rows:
            return
            
        for index in selected_rows:
            row = index.row()
            eid = self.table.item(row, 0).data(Qt.ItemDataRole.UserRole)
            self.selected_entities.append(eid)
            
        self.accept()

===== FILE PATH =====
./ui\tabs\database_tab.py
===== FILE CONTENT =====
import os
from PyQt6.QtWidgets import (QWidget, QHBoxLayout, QVBoxLayout, QListWidget, 
                             QPushButton, QLineEdit, QComboBox, QSplitter, 
                             QMessageBox, QListWidgetItem, QCheckBox, QLabel, 
                             QStyle, QTabWidget, QMenu, QTabBar)
from PyQt6.QtGui import QColor, QBrush, QDrag, QAction, QIcon, QPixmap, QDesktopServices
from PyQt6.QtCore import Qt, QMimeData, QUrl

from ui.widgets.npc_sheet import NpcSheet
from ui.dialogs.api_browser import ApiBrowser
from ui.dialogs.bulk_downloader import BulkDownloadDialog
from ui.workers import ApiSearchWorker
from core.models import ENTITY_SCHEMAS
from core.locales import tr

class EntityListItemWidget(QWidget):
    """
    Listede gÃ¶rÃ¼necek Ã¶zel satÄ±r tasarÄ±mÄ±.
    Ãœstte: Ä°sim (Bold)
    Altta: Kategori (Gri ve Ä°talik) - Dinamik Ã‡eviri
    """
    def __init__(self, name, raw_category, parent=None):
        super().__init__(parent)
        
        # --- BU SATIRI EKLEYÄ°N ---
        self.setObjectName("entityItem") 
        # BÃ¶ylece QSS dosyasÄ±nda #entityItem diyerek bu widget'Ä± hedefleyebiliriz.
        
        layout = QVBoxLayout(self)
        layout.setContentsMargins(5, 5, 5, 5)
        layout.setSpacing(2)
        
        # Ä°sim AlanÄ±
        lbl_name = QLabel(name)
        # --- objectName EKLENDÄ° ---
        lbl_name.setObjectName("entityName")
        # Hardcoded stili temizleyip QSS'e bÄ±rakÄ±yoruz veya sadece font ayarÄ± bÄ±rakÄ±yoruz
        lbl_name.setStyleSheet("font-size: 14px; font-weight: bold; background-color: transparent;")
        
        # Kategori AlanÄ±
        display_cat = self.translate_category(raw_category)
        lbl_cat = QLabel(display_cat)
        # --- objectName EKLENDÄ° ---
        lbl_cat.setObjectName("entityCat")
        # Arka planÄ± ÅŸeffaf yapÄ±yoruz
        lbl_cat.setStyleSheet("font-size: 11px; font-style: italic; background-color: transparent;")
        
        layout.addWidget(lbl_name)
        layout.addWidget(lbl_cat)

    def translate_category(self, raw_cat):
        # Ham veriyi (monster, Canavar vb.) standartlaÅŸtÄ±ralÄ±m
        key_map = {
            "monster": "CAT_MONSTER", "monsters": "CAT_MONSTER", "canavar": "CAT_MONSTER",
            "spell": "CAT_SPELL", "spells": "CAT_SPELL", "bÃ¼yÃ¼ (spell)": "CAT_SPELL",
            "npc": "CAT_NPC",
            "equipment": "CAT_EQUIPMENT", "eÅŸya (equipment)": "CAT_EQUIPMENT",
            "magic-items": "CAT_EQUIPMENT",
            "class": "CAT_CLASS", "classes": "CAT_CLASS", "sÄ±nÄ±f (class)": "CAT_CLASS",
            "race": "CAT_RACE", "races": "CAT_RACE", "irk (race)": "CAT_RACE"
        }
        
        # KÃ¼Ã§Ã¼k harfe Ã§evirip eÅŸleÅŸtir
        translation_key = key_map.get(str(raw_cat).lower())
        
        if translation_key:
            return tr(translation_key)
        return str(raw_cat).title() # EÅŸleÅŸmezse olduÄŸu gibi yaz

# --- 1. SÃœRÃœKLENEBÄ°LÄ°R LÄ°STE ---
class DraggableListWidget(QListWidget):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setDragEnabled(True) # SÃ¼rÃ¼klemeyi aktif et

    def startDrag(self, supportedActions):
        item = self.currentItem()
        if not item: return

        eid = item.data(Qt.ItemDataRole.UserRole)
        if not eid: return

        # MIME verisi oluÅŸtur (Sadece Entity ID taÅŸÄ±yacak)
        mime = QMimeData()
        mime.setText(str(eid))
        
        drag = QDrag(self)
        drag.setMimeData(mime)
        # SÃ¼rÃ¼klerken bir Ã¶nizleme resmi koyabiliriz (opsiyonel)
        # drag.setPixmap(...) 
        drag.exec(Qt.DropAction.CopyAction)

# --- 2. VARLIK SEKME YÃ–NETÄ°CÄ°SÄ° (SOL VEYA SAÄž PANEL) ---
class EntityTabWidget(QTabWidget):
    """
    Ä°Ã§ine varlÄ±k kartlarÄ±nÄ±n (NpcSheet) eklendiÄŸi sekme yapÄ±sÄ±.
    SÃ¼rÃ¼kle-bÄ±rak kabul eder.
    """
    def __init__(self, data_manager, parent_db_tab, panel_id):
        super().__init__()
        self.dm = data_manager
        self.parent_db_tab = parent_db_tab
        self.panel_id = panel_id # "left" veya "right"
        
        self.setTabsClosable(True)
        self.setMovable(True)
        self.setAcceptDrops(True) # Ãœzerine bÄ±rakÄ±lmayÄ± kabul et
        self.tabCloseRequested.connect(self.close_tab)
        
        # Stil: Modern sekme gÃ¶rÃ¼nÃ¼mÃ¼
        self.setStyleSheet("""
            QTabWidget::pane { border: 1px solid #444; background-color: #1e1e1e; }
            QTabBar::tab { background: #2d2d2d; color: #aaa; padding: 8px 15px; margin-right: 2px; }
            QTabBar::tab:selected { background: #1e1e1e; color: white; border-top: 2px solid #007acc; font-weight: bold; }
            QTabBar::tab:hover { background: #3e3e3e; }
        """)

    def dragEnterEvent(self, event):
        if event.mimeData().hasText():
            event.acceptProposedAction()

    def dropEvent(self, event):
        eid = event.mimeData().text()
        # Bu ID'yi bu panele ekle
        self.parent_db_tab.open_entity_tab(eid, target_panel=self.panel_id)
        event.acceptProposedAction()

    def close_tab(self, index):
        # Sekmeyi kapat
        widget = self.widget(index)
        if widget:
            widget.deleteLater()
        self.removeTab(index)

# --- 3. ANA VERÄ°TABANI SEKMESÄ° ---
class DatabaseTab(QWidget):
    def __init__(self, data_manager, player_window):
        super().__init__()
        self.dm = data_manager
        self.player_window = player_window
        self.init_ui()

    def init_ui(self):
        main_layout = QHBoxLayout(self)
        
        # --- SOL KENAR Ã‡UBUÄžU (LÄ°STE & FÄ°LTRELER) ---
        sidebar_widget = QWidget()
        sidebar_layout = QVBoxLayout(sidebar_widget)
        sidebar_layout.setContentsMargins(0, 0, 0, 0)
        
        # Arama ve Filtreler
        self.inp_search = QLineEdit()
        self.inp_search.setPlaceholderText(tr("LBL_SEARCH"))
        self.inp_search.textChanged.connect(self.refresh_list)
        
        filter_layout = QHBoxLayout()
        self.combo_filter = QComboBox()
        self.combo_filter.addItem(tr("CAT_ALL"), None)
        for cat in ENTITY_SCHEMAS.keys():
            self.combo_filter.addItem(tr(f"CAT_{cat.upper().replace(' ', '_').replace('(', '').replace(')', '')}"), cat)
        self.combo_filter.currentTextChanged.connect(self.refresh_list)
        
        self.check_show_library = QCheckBox(tr("LBL_CHECK_LIBRARY"))
        self.check_show_library.setChecked(True)
        self.check_show_library.stateChanged.connect(self.refresh_list)
        
        filter_layout.addWidget(self.combo_filter)
        filter_layout.addWidget(self.check_show_library)
        
        # Butonlar
        self.btn_download_all = QPushButton(tr("BTN_DOWNLOAD_ALL"))
        self.btn_download_all.clicked.connect(self.open_bulk_downloader)
        
        self.btn_browser = QPushButton(tr("BTN_API_BROWSER"))
        self.btn_browser.clicked.connect(self.open_api_browser)

        # Liste (SÃ¼rÃ¼klenebilir)
        self.list_widget = DraggableListWidget()
        self.list_widget.itemDoubleClicked.connect(self.on_item_double_clicked)
        
        # Yeni Ekle Butonu
        self.btn_add = QPushButton(tr("BTN_NEW_ENTITY"))
        self.btn_add.setObjectName("successBtn")
        self.btn_add.clicked.connect(self.create_new_entity)
        
        sidebar_layout.addWidget(self.inp_search)
        sidebar_layout.addLayout(filter_layout)
        sidebar_layout.addWidget(self.btn_download_all)
        sidebar_layout.addWidget(self.btn_browser)
        sidebar_layout.addWidget(self.list_widget)
        sidebar_layout.addWidget(self.btn_add)

        # --- ORTA ALAN (Ã‡Ä°FT SEKME PANELÄ°) ---
        self.workspace_splitter = QSplitter(Qt.Orientation.Horizontal)
        
        # Sol Panel (VarsayÄ±lan Panel)
        self.tab_manager_left = EntityTabWidget(self.dm, self, "left")
        
        # SaÄŸ Panel (Ä°kincil Panel)
        self.tab_manager_right = EntityTabWidget(self.dm, self, "right")
        
        # BaÅŸlangÄ±Ã§ta saÄŸ panel boÅŸ olduÄŸu iÃ§in geniÅŸliÄŸini kÃ¼Ã§Ã¼k tutabiliriz veya eÅŸit bÃ¶lebiliriz
        self.workspace_splitter.addWidget(self.tab_manager_left)
        self.workspace_splitter.addWidget(self.tab_manager_right)
        self.workspace_splitter.setSizes([800, 800]) # EÅŸit baÅŸlat
        self.workspace_splitter.setCollapsible(0, False) # Sol taraf tamamen kapanmasÄ±n

        # Ana Splitter (Sidebar | Workspace)
        main_splitter = QSplitter(Qt.Orientation.Horizontal)
        main_splitter.addWidget(sidebar_widget)
        main_splitter.addWidget(self.workspace_splitter)
        main_splitter.setSizes([300, 1200])

        main_layout.addWidget(main_splitter)
        
        self.refresh_list()

    def retranslate_ui(self):
        # 1. Kenar Ã‡ubuÄŸu (Sidebar) ElemanlarÄ±nÄ± GÃ¼ncelle
        self.inp_search.setPlaceholderText(tr("LBL_SEARCH"))
        
        # Filtre Combobox'Ä±nÄ± gÃ¼ncelle
        for i in range(self.combo_filter.count()):
            cat = self.combo_filter.itemData(i)
            if cat: 
                # Standart kategori anahtarlarÄ±nÄ± Ã§evir
                self.combo_filter.setItemText(i, tr(f"CAT_{cat.upper().replace(' ', '_').replace('(', '').replace(')', '')}"))
            else:
                self.combo_filter.setItemText(i, tr("CAT_ALL"))

        self.check_show_library.setText(tr("LBL_CHECK_LIBRARY"))
        self.btn_download_all.setText(tr("BTN_DOWNLOAD_ALL"))
        self.btn_browser.setText(tr("BTN_API_BROWSER"))
        self.btn_add.setText(tr("BTN_NEW_ENTITY"))

        # 2. AÃ§Ä±k Olan Sekmeleri (NpcSheet'leri) GÃ¼ncelle
        # Sol ve SaÄŸ panellerdeki tÃ¼m sekmeleri gezip dillerini gÃ¼ncelliyoruz.
        for manager in [self.tab_manager_left, self.tab_manager_right]:
            for i in range(manager.count()):
                widget = manager.widget(i)
                # EÄŸer widget bir NpcSheet ise (retranslate_ui metodu varsa) Ã§aÄŸÄ±r
                if hasattr(widget, "retranslate_ui"):
                    widget.retranslate_ui()

    def refresh_list(self):
        self.list_widget.clear()
        text = self.inp_search.text().lower()
        
        # Filtreleme iÃ§in standart kategori isimlerini kullanalÄ±m
        flt_data = self.combo_filter.currentData()

        # Kategori DÃ¶nÃ¼ÅŸtÃ¼rÃ¼cÃ¼ (Database -> API Key)
        def normalize_type(t):
            t = str(t).lower()
            if t in ["canavar", "monster", "monsters"]: return "monster"
            if "spell" in t or "bÃ¼yÃ¼" in t: return "spell"
            if "equipment" in t or "eÅŸya" in t: return "equipment"
            if "class" in t or "sÄ±nÄ±f" in t: return "class"
            if "race" in t or "irk" in t: return "race"
            return t

        target_cat = normalize_type(flt_data) if flt_data else None

        # 1. YEREL VARLIKLAR
        for eid, data in self.dm.data["entities"].items():
            name = data.get("name", "")
            raw_type = data.get("type", "NPC")
            norm_type = normalize_type(raw_type)
            
            if target_cat and norm_type != target_cat: continue
            if text not in name.lower() and text not in str(data.get("tags", "")).lower(): continue
            
            item = QListWidgetItem(self.list_widget)
            item.setData(Qt.ItemDataRole.UserRole, eid)
            
            widget = EntityListItemWidget(name, raw_type)
            item.setSizeHint(widget.sizeHint())
            self.list_widget.setItemWidget(item, widget)

        # 2. KÃœTÃœPHANE (CACHE/OFFLINE)
        if self.check_show_library.isChecked() and (len(text) > 2 or target_cat):
            lib_results = self.dm.search_in_library(None, text)
            
            for res in lib_results:
                # --- HATA DÃœZELTME BAÅžLANGICI ---
                # 'index' anahtarÄ± yoksa gÃ¼venli Ã§Ä±kÄ±ÅŸ yap
                if "index" not in res:
                    continue
                # ------------------------------

                res_cat = res["type"]
                norm_res_cat = normalize_type(res_cat)
                
                if target_cat and norm_res_cat != target_cat: continue
                
                item = QListWidgetItem(self.list_widget)
                
                api_safe_cat = "monsters" if norm_res_cat == "monster" else \
                               "spells" if norm_res_cat == "spell" else \
                               "equipment" if norm_res_cat == "equipment" else \
                               "classes" if norm_res_cat == "class" else \
                               "races" if norm_res_cat == "race" else norm_res_cat
                               
                safe_id = f"lib_{api_safe_cat}_{res['index']}"
                item.setData(Qt.ItemDataRole.UserRole, safe_id)
                
                widget = EntityListItemWidget("ðŸ“š " + res["name"], res_cat)
                item.setSizeHint(widget.sizeHint())
                self.list_widget.setItemWidget(item, widget)

    # --- SEKME AÃ‡MA MANTIÄžI ---
    def on_item_double_clicked(self, item):
        eid = item.data(Qt.ItemDataRole.UserRole)
        # Ã‡ift tÄ±k varsayÄ±lan olarak SOL panele aÃ§ar
        self.open_entity_tab(eid, target_panel="left")

    def open_entity_tab(self, eid, target_panel="left"):
        """
        Belirtilen entity ID'sini hedef panelde (left/right) aÃ§ar.
        EÄŸer zaten aÃ§Ä±ksa o sekmeye odaklanÄ±r.
        """
        # 1. KÃ¼tÃ¼phane Ã¶ÄŸesi mi kontrol et (lib_...)
        if str(eid).startswith("lib_"):
            parts = eid.split("_")
            self._fetch_and_open_api_entity(parts[1], parts[2], target_panel)
            return

        # 2. Hangi TabManager kullanÄ±lacak?
        target_manager = self.tab_manager_left if target_panel == "left" else self.tab_manager_right
        other_manager = self.tab_manager_right if target_panel == "left" else self.tab_manager_left

        # 3. Bu entity ZATEN bu panelde aÃ§Ä±k mÄ±?
        for i in range(target_manager.count()):
            sheet = target_manager.widget(i)
            if sheet.property("entity_id") == eid:
                target_manager.setCurrentIndex(i)
                return

        # 4. Bu entity DÄ°ÄžER panelde aÃ§Ä±k mÄ±? (Opsiyonel: Ä°ki tarafta aynÄ± anda aÃ§Ä±lmasÄ±nÄ± engelleyebiliriz veya izin verebiliriz)
        # Åžimdilik izin verelim, DM karÅŸÄ±laÅŸtÄ±rma yapmak isteyebilir.
        
        # 5. Yeni Sekme OluÅŸtur
        data = self.dm.data["entities"].get(eid)
        if not data: return
        
        new_sheet = NpcSheet()
        new_sheet.setProperty("entity_id", eid) # ID'yi widget Ã¼zerinde sakla
        
        # Veriyi doldur
        self.populate_sheet(new_sheet, data)
        
        # Buton BaÄŸlantÄ±larÄ±
        new_sheet.btn_save.clicked.connect(lambda: self.save_sheet_data(new_sheet))
        new_sheet.btn_delete.clicked.connect(lambda: self.delete_entity_from_tab(new_sheet))
        
        # Player Window \u0026 PDF Buttons
        new_sheet.btn_show_player.clicked.connect(lambda: self._show_to_player(new_sheet))
        new_sheet.btn_add_pdf.clicked.connect(lambda: self._add_pdf_to_sheet(new_sheet))
        new_sheet.btn_open_pdf.clicked.connect(lambda: self._open_pdf_file(new_sheet))
        new_sheet.btn_project_pdf.clicked.connect(lambda: self._project_pdf_to_player(new_sheet))
        new_sheet.btn_remove_pdf.clicked.connect(lambda: self._remove_pdf_from_sheet(new_sheet))
        new_sheet.btn_open_pdf_folder.clicked.connect(lambda: self._open_pdf_folder(new_sheet))
        
        # Sekmeye Ekle
        icon_char = "ðŸ‘¤" if data.get("type") == "NPC" else "ðŸ‰" if data.get("type") == "Monster" else "ðŸ“œ"
        tab_index = target_manager.addTab(new_sheet, f"{icon_char} {data.get('name')}")
        target_manager.setCurrentIndex(tab_index)

    def _fetch_and_open_api_entity(self, cat, idx, target_panel):
        # API'den veri Ã§ekme iÅŸlemi
        # HATA BURADAYDI: "worker =" derseniz fonksiyon bitince silinir.
        # DÃœZELTME: "self.worker =" diyerek sÄ±nÄ±fÄ±n hafÄ±zasÄ±nda tutuyoruz.
        
        self.api_worker = ApiSearchWorker(self.dm, cat, idx)
        
        # Lambda fonksiyonu ile panel bilgisini taÅŸÄ±yoruz
        self.api_worker.finished.connect(lambda s, d, m: self._on_api_fetched(s, d, m, target_panel))
        
        # Ä°ÅŸ bitince worker'Ä± temizlemek iyi bir pratiktir
        self.api_worker.finished.connect(lambda: setattr(self, 'api_worker', None))
        
        self.api_worker.start()

    def open_entity_card(self, eid):
        # KÃ¼tÃ¼phane Ã¶ÄŸesi mi? (lib_...)
        if str(eid).startswith("lib_"):
            parts = eid.split("_")
            cat = parts[1]; idx = parts[2]
            
            # BURASI DA DEÄžÄ°ÅžMELÄ°: worker -> self.worker
            self.search_worker = ApiSearchWorker(self.dm, cat, idx)
            self.search_worker.finished.connect(lambda s, d, m: self.on_api_fetched(s, d, m))
            self.search_worker.start()
        else:
            # Zaten var, kartÄ± aÃ§
            self._create_card_window(eid)

    def _on_api_fetched(self, success, data_or_id, msg, target_panel):
        if success:
            if isinstance(data_or_id, dict):
                # Yeni veri, kaydet ve aÃ§
                new_id = self.dm.import_entity_with_dependencies(data_or_id)
                self.refresh_list()
                self.open_entity_tab(new_id, target_panel)
            elif isinstance(data_or_id, str):
                # Zaten var, ID ile aÃ§
                self.open_entity_tab(data_or_id, target_panel)
        else:
            QMessageBox.warning(self, tr("MSG_ERROR"), msg)

    def create_new_entity(self):
        # Yeni boÅŸ varlÄ±k oluÅŸtur ve sol panele ekle
        default_data = {"name": "Yeni VarlÄ±k", "type": "NPC"}
        new_id = self.dm.save_entity(None, default_data)
        self.refresh_list()
        self.open_entity_tab(new_id, "left")

    def save_sheet_data(self, sheet):
        eid = sheet.property("entity_id")
        data = self.collect_data_from_sheet(sheet)
        if not data: return

        self.dm.save_entity(eid, data)
        QMessageBox.information(self, tr("MSG_SUCCESS"), tr("MSG_SAVED"))
        
        # Sekme baÅŸlÄ±ÄŸÄ±nÄ± gÃ¼ncelle
        # Hangi panelde olduÄŸunu bul
        for manager in [self.tab_manager_left, self.tab_manager_right]:
            idx = manager.indexOf(sheet)
            if idx != -1:
                icon_char = "ðŸ‘¤" if data.get("type") == "NPC" else "ðŸ‰"
                manager.setTabText(idx, f"{icon_char} {data.get('name')}")
        
        self.refresh_list()

    def delete_entity_from_tab(self, sheet):
        eid = sheet.property("entity_id")
        if QMessageBox.question(self, tr("BTN_DELETE"), tr("MSG_CONFIRM_DELETE")) == QMessageBox.StandardButton.Yes:
            self.dm.delete_entity(eid)
            self.refresh_list()
            # AÃ§Ä±k olan tÃ¼m sekmeleri bul ve kapat
            for manager in [self.tab_manager_left, self.tab_manager_right]:
                idx = manager.indexOf(sheet)
                if idx != -1: manager.removeTab(idx)

    # --- VERÄ° DOLDURMA / TOPLAMA (ESKÄ° KODDAN UYARLANDI) ---
    def populate_sheet(self, s, data):
        s.inp_name.setText(data.get("name", ""))
        curr_type = data.get("type", "NPC")
        idx = s.inp_type.findText(curr_type)
        s.inp_type.setCurrentIndex(idx if idx >= 0 else 0)
        s.inp_tags.setText(", ".join(data.get("tags", [])))
        s.inp_desc.setText(data.get("description", ""))
        
        stats = data.get("stats", {})
        for k, v in s.stats_inputs.items(): v.setText(str(stats.get(k, 10)))
        
        c = data.get("combat_stats", {})
        s.inp_hp.setText(str(c.get("hp", "")))
        s.inp_max_hp.setText(str(c.get("max_hp", "")))
        s.inp_ac.setText(str(c.get("ac", ""))) 
        s.inp_speed.setText(str(c.get("speed", "")))
        s.inp_init.setText(str(c.get("initiative", "")))

        s.inp_saves.setText(data.get("saving_throws", ""))
        s.inp_skills.setText(data.get("skills", ""))
        s.inp_vuln.setText(data.get("damage_vulnerabilities", ""))
        s.inp_resist.setText(data.get("damage_resistances", ""))
        s.inp_dmg_immune.setText(data.get("damage_immunities", ""))
        s.inp_cond_immune.setText(data.get("condition_immunities", ""))
        s.inp_prof.setText(str(data.get("proficiency_bonus", "")))
        s.inp_pp.setText(str(data.get("passive_perception", "")))

        s.update_ui_by_type(curr_type)
        attrs = data.get("attributes", {})
        for l, w in s.dynamic_inputs.items():
            val = attrs.get(l, "")
            if isinstance(w, QComboBox): 
                ix = w.findData(val)
                if ix >= 0:
                    w.setCurrentIndex(ix)
                else:
                    ix_text = w.findText(val)
                    if ix_text >= 0:
                        w.setCurrentIndex(ix_text)
                    else:
                        w.setCurrentText(val)
            else: 
                w.setText(str(val))

        s.clear_all_cards()
        self._fill_cards(s, s.trait_container, data.get("traits", []))
        self._fill_cards(s, s.action_container, data.get("actions", []))
        self._fill_cards(s, s.reaction_container, data.get("reactions", []))
        self._fill_cards(s, s.legendary_container, data.get("legendary_actions", []))
        self._fill_cards(s, s.inventory_container, data.get("inventory", []))
        self._fill_cards(s, s.custom_spell_container, data.get("custom_spells", []))
        
        s.image_list = data.get("images", [])
        if not s.image_list and data.get("image_path"): s.image_list = [data.get("image_path")]
        s.current_img_index = 0
        if s.image_list:
             path = self.dm.get_full_path(s.image_list[0])
             if path and os.path.exists(path): s.lbl_image.setPixmap(QPixmap(path))
        
        # BaÄŸlÄ± BÃ¼yÃ¼ler Listesi (BasitleÅŸtirilmiÅŸ)
        s.list_assigned_spells.clear()
        for spell_id in data.get("spells", []):
            spell = self.dm.data["entities"].get(spell_id)
            if spell: s.list_assigned_spells.addItem(f"{spell['name']} (Lv {spell.get('attributes',{}).get('LBL_LEVEL','?')})")
        
        # PDF List
        s.list_pdfs.clear()
        for pdf_filename in data.get("pdfs", []):
            s.list_pdfs.addItem(pdf_filename)

    def collect_data_from_sheet(self, s):
        if not s.inp_name.text(): return None
        
        def get_cards(container):
            res = []; layout = container.dynamic_area
            for i in range(layout.count()):
                w = layout.itemAt(i).widget()
                if w: res.append({"name": w.inp_title.text(), "desc": w.inp_desc.toPlainText()})
            return res
            
        data = {
            "name": s.inp_name.text(), 
            "type": s.inp_type.currentText(),
            "tags": [t.strip() for t in s.inp_tags.text().split(",") if t.strip()],
            "description": s.inp_desc.toPlainText(),
            "images": s.image_list,
            "stats": {k: int(v.text() or 10) for k, v in s.stats_inputs.items()},
            "combat_stats": {
                "hp": s.inp_hp.text(), "max_hp": s.inp_max_hp.text(), "ac": s.inp_ac.text(),
                "speed": s.inp_speed.text(), "initiative": s.inp_init.text()
            },
            "saving_throws": s.inp_saves.text(), "skills": s.inp_skills.text(),
            "damage_vulnerabilities": s.inp_vuln.text(), "damage_resistances": s.inp_resist.text(),
            "damage_immunities": s.inp_dmg_immune.text(), "condition_immunities": s.inp_cond_immune.text(),
            "proficiency_bonus": s.inp_prof.text(), "passive_perception": s.inp_pp.text(),
            "attributes": {l: (w.currentText() if isinstance(w, QComboBox) else w.text()) for l, w in s.dynamic_inputs.items()},
            "traits": get_cards(s.trait_container), "actions": get_cards(s.action_container),
            "reactions": get_cards(s.reaction_container), "legendary_actions": get_cards(s.legendary_container),
            "inventory": get_cards(s.inventory_container), "custom_spells": get_cards(s.custom_spell_container),
            "pdfs": [s.list_pdfs.item(i).text() for i in range(s.list_pdfs.count())]
        }
        return data

    def _fill_cards(self, sheet, container, data_list):
        for item in data_list: sheet.add_feature_card(container, item.get("name"), item.get("desc"))

    # --- PLAYER WINDOW & PDF HANDLERS ---
    def _show_to_player(self, sheet):
        """Show current entity image to player window"""
        if not sheet.image_list:
            QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_NO_IMAGE_IN_ENTITY"))
            return
        
        # Get current image path
        img_path = sheet.image_list[sheet.current_img_index]
        full_path = self.dm.get_full_path(img_path)
        
        if full_path and os.path.exists(full_path):
            from PyQt6.QtGui import QPixmap
            pixmap = QPixmap(full_path)
            self.player_window.show_image(pixmap)
            self.player_window.show()
        else:
            QMessageBox.warning(self, tr("MSG_ERROR"), tr("MSG_FILE_NOT_FOUND_DISK"))
    
    def _add_pdf_to_sheet(self, sheet):
        """Add PDF file to entity"""
        from PyQt6.QtWidgets import QFileDialog
        
        fname, _ = QFileDialog.getOpenFileName(
            self, 
            tr("BTN_SELECT_PDF"), 
            "", 
            "PDF Files (*.pdf)"
        )
        
        if fname:
            eid = sheet.property("entity_id")
            pdf_filename = self.dm.import_pdf(fname)
            
            # Get current entity data
            data = self.dm.data["entities"].get(eid, {})
            pdfs = data.get("pdfs", [])
            
            # Add new PDF if not already in list
            if pdf_filename not in pdfs:
                pdfs.append(pdf_filename)
                data["pdfs"] = pdfs
                self.dm.save_entity(eid, data)
                
                # Update UI list
                sheet.list_pdfs.addItem(pdf_filename)
    
    def _open_pdf_file(self, sheet):
        """Open selected PDF in system viewer"""
        selected = sheet.list_pdfs.currentItem()
        if not selected:
            QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_SELECT_PDF_FIRST"))
            return
        
        pdf_filename = selected.text()
        pdf_path = self.dm.get_full_path(pdf_filename)
        
        if pdf_path and os.path.exists(pdf_path):
            from PyQt6.QtGui import QDesktopServices
            from PyQt6.QtCore import QUrl
            QDesktopServices.openUrl(QUrl.fromLocalFile(pdf_path))
        else:
            MessageBox.warning(self, tr("MSG_ERROR"), tr("MSG_FILE_NOT_FOUND_DISK"))
    
    def _project_pdf_to_player(self, sheet):
        """Project PDF to player window"""
        selected = sheet.list_pdfs.currentItem()
        if not selected:
            QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_SELECT_PDF_FIRST"))
            return
        
        pdf_filename = selected.text()
        pdf_path = self.dm.get_full_path(pdf_filename)
        
        if pdf_path and os.path.exists(pdf_path):
            self.player_window.show_pdf(pdf_path)
            self.player_window.show()
        else:
            QMessageBox.warning(self, tr("MSG_ERROR"), tr("MSG_FILE_NOT_FOUND_DISK"))
    
    def _remove_pdf_from_sheet(self, sheet):
        """Remove selected PDF from entity"""
        selected = sheet.list_pdfs.currentItem()
        if not selected:
            return
        
        if QMessageBox.question(
            self, 
            tr("BTN_REMOVE"), 
            tr("MSG_REMOVE_PDF_CONFIRM")
        ) == QMessageBox.StandardButton.Yes:
            eid = sheet.property("entity_id")
            pdf_filename = selected.text()
            
            # Remove from data
            data = self.dm.data["entities"].get(eid, {})
            pdfs = data.get("pdfs", [])
            if pdf_filename in pdfs:
                pdfs.remove(pdf_filename)
                data["pdfs"] = pdfs
                self.dm.save_entity(eid, data)
            
            # Remove from UI
            sheet.list_pdfs.takeItem(sheet.list_pdfs.row(selected))
    
    def _open_pdf_folder(self, sheet):
        """Open PDF folder in file manager"""
        eid = sheet.property("entity_id")
        pdf_dir = os.path.join(self.dm.current_campaign_path, "assets")
        
        # Create folder if it doesn't exist
        os.makedirs(pdf_dir, exist_ok=True)
        
        from PyQt6.QtGui import QDesktopServices
        from PyQt6.QtCore import QUrl
        QDesktopServices.openUrl(QUrl.fromLocalFile(pdf_dir))

    # Dialogs
    def open_api_browser(self):
        cat = self.combo_filter.currentData()
        if not cat: return QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_SELECT_CATEGORY"))
        if ApiBrowser(self.dm, cat, self).exec(): self.refresh_list()
        
    def open_bulk_downloader(self): 
        BulkDownloadDialog(self).exec()

===== FILE PATH =====
./ui\tabs\map_tab.py
===== FILE CONTENT =====
import os
import uuid
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QPushButton, 
                             QFileDialog, QFrame, QMessageBox, QInputDialog)
from PyQt6.QtGui import QPixmap
from ui.widgets.map_viewer import MapViewer, MapPinItem
from core.locales import tr

class MapTab(QWidget):
    def __init__(self, data_manager, player_window, main_window_ref):
        super().__init__()
        self.dm = data_manager
        self.player_window = player_window
        self.main_window_ref = main_window_ref # VeritabanÄ± sekmesine geÃ§iÅŸ iÃ§in ref
        self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        # --- Toolbar (Butonlar Burada) ---
        toolbar = QHBoxLayout()
        self.btn_load_map = QPushButton(tr("BTN_LOAD_MAP"))
        self.btn_load_map.clicked.connect(self.upload_map_image)
        
        self.btn_show_map_pl = QPushButton(tr("BTN_PROJECT_MAP"))
        self.btn_show_map_pl.setObjectName("primaryBtn")
        self.btn_show_map_pl.clicked.connect(self.push_map_to_player)
        
        toolbar.addWidget(self.btn_load_map)
        toolbar.addStretch()
        toolbar.addWidget(self.btn_show_map_pl)
        
        # --- Viewer ---
        viewer_frame = QFrame()
        viewer_frame.setStyleSheet("background-color: #111; border: 1px solid #444;")
        v_layout = QVBoxLayout(viewer_frame)
        v_layout.setContentsMargins(0,0,0,0)
        
        self.map_viewer = MapViewer()
        self.map_viewer.setStyleSheet("border: none;")
        self.map_viewer.pin_created_signal.connect(self.handle_new_pin)
        self.map_viewer.pin_moved_signal.connect(self.handle_pin_moved)
        
        v_layout.addWidget(self.map_viewer)
        
        layout.addLayout(toolbar)
        layout.addWidget(viewer_frame)

    def retranslate_ui(self):
        self.btn_load_map.setText(tr("BTN_LOAD_MAP"))
        self.btn_show_map_pl.setText(tr("BTN_PROJECT_MAP"))

    def upload_map_image(self):
        fname, _ = QFileDialog.getOpenFileName(self, tr("MSG_SELECT_MAP"), "", "Images (*.png *.jpg *.jpeg)")
        if fname:
            rel = self.dm.import_image(fname)
            self.dm.set_map_image(rel)
            self.render_map()

    def render_map(self):
        path = self.dm.get_full_path(self.dm.data["map_data"].get("image_path"))
        if not path or not os.path.exists(path): return
        
        self.map_viewer.load_map(QPixmap(path))
        
        pins = self.dm.data["map_data"].get("pins", [])
        entities = self.dm.data["entities"]
        
        for pin in pins:
            if pin["entity_id"] in entities:
                ent = entities[pin["entity_id"]]
                color = "#007acc"
                if ent["type"] == "NPC": color = "#ff9800"
                elif ent["type"] == "Location": color = "#2e7d32"
                elif ent["type"] == "Monster": color = "#d32f2f"
                elif ent["type"] == "Player": color = "#4caf50"
                
                pin_id = pin.get("id")
                if not pin_id: pin_id = str(uuid.uuid4())
                
                pin_item = MapPinItem(pin["x"], pin["y"], 24, color, pin_id, pin["entity_id"], ent["name"], self.on_pin_action)
                self.map_viewer.add_pin_object(pin_item)

    def push_map_to_player(self):
        if self.player_window.isVisible():
            path = self.dm.get_full_path(self.dm.data["map_data"].get("image_path"))
            self.player_window.show_image(QPixmap(path) if path else None)
        else:
            QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_NO_PLAYER_SCREEN"))

    def handle_new_pin(self, x, y):
        entities = self.dm.data["entities"]
        if not entities: 
            QMessageBox.warning(self, tr("MSG_ERROR"), tr("MSG_ADD_ENTITY_FIRST"))
            return
            
        items, ids = [], []
        
        # --- FÄ°LTRELEME MANTIÄžI ---
        # Haritaya sadece fiziksel olarak bulunabilen ÅŸeyler eklensin
        allowed_types = ["NPC", "Monster", "Player", "Location", "Equipment"]
        
        for eid, data in entities.items():
            # EÄŸer varlÄ±ÄŸÄ±n tipi izin verilenler listesindeyse listeye ekle
            if data.get("type") in allowed_types:
                items.append(f"{data['name']} ({data['type']})")
                ids.append(eid)
        
        if not items:
            QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_NO_ENTITY_FOR_PIN"))
            return
            
        item, ok = QInputDialog.getItem(self, tr("MSG_ADD_PIN"), tr("MSG_SELECT_ENTITY"), items, 0, False)
        if ok and item:
            self.dm.add_pin(x, y, ids[items.index(item)])
            self.render_map()

    def on_pin_action(self, action_type, pin_obj):
        if action_type == "inspect":
            # Ana penceredeki Database tabÄ±na geÃ§ ve karakteri yÃ¼kle
            # Bunun iÃ§in main_window referansÄ±na veya signal'e ihtiyacÄ±mÄ±z var.
            # Åžimdilik main_window_ref Ã¼zerinden gidelim.
            if self.main_window_ref:
                self.main_window_ref.tabs.setCurrentIndex(0) # Database tab
                self.main_window_ref.db_tab.load_entity_by_id(pin_obj.entity_id)
                
        elif action_type == "move":
            self.map_viewer.start_move_mode(pin_obj.pin_id)
            
        elif action_type == "delete":
            if QMessageBox.question(self, tr("BTN_DELETE"), tr("MSG_DELETE_PIN")) == QMessageBox.StandardButton.Yes:
                self.dm.remove_specific_pin(pin_obj.pin_id)
                self.render_map()

    def handle_pin_moved(self, pin_id, new_x, new_y):
        self.dm.move_pin(pin_id, new_x, new_y)
        self.render_map()

===== FILE PATH =====
./ui\tabs\session_tab.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import (QWidget, QHBoxLayout, QVBoxLayout, QTextEdit, 
                             QLabel, QPushButton, QGroupBox, QInputDialog, 
                             QComboBox, QMessageBox)
from PyQt6.QtCore import QDateTime
from core.locales import tr
from ui.widgets.combat_tracker import CombatTracker
import random

class SessionTab(QWidget):
    def __init__(self, data_manager):
        super().__init__()
        self.dm = data_manager
        self.current_session_id = None
        self.init_ui()
        
        last_sid = self.dm.get_last_active_session_id()
        
        if last_sid:
            idx = self.combo_sessions.findData(last_sid)
            if idx >= 0:
                self.combo_sessions.setCurrentIndex(idx)
                self.load_session()
        elif self.combo_sessions.count() > 0:
            # ID yok ama listede session varsa ilkini seÃ§
            self.combo_sessions.setCurrentIndex(0)
            self.load_session()

    def init_ui(self):
        layout = QHBoxLayout(self)

        # --- SOL: SAVAÅž TAKÄ°PÃ‡Ä°SÄ° ---
        left_layout = QVBoxLayout()
        self.combat_tracker = CombatTracker(self.dm)
        
        # OTOMATÄ°K KAYIT BAÄžLANTISI
        # CombatTracker'da veri deÄŸiÅŸince save_session'Ä± tetikle
        self.combat_tracker.data_changed_signal.connect(self.auto_save)
        
        left_layout.addWidget(QLabel(tr("TITLE_COMBAT")))
        left_layout.addWidget(self.combat_tracker)
        
        # Zar Paneli
        dice_group = QGroupBox(tr("GRP_DICE"))
        dice_layout = QHBoxLayout(dice_group)
        for d in [4, 6, 8, 10, 12, 20, 100]:
            btn = QPushButton(f"d{d}")
            btn.clicked.connect(lambda checked, x=d: self.roll_dice(x))
            dice_layout.addWidget(btn)
        left_layout.addWidget(dice_group)
        
        # --- SAÄž: NOTLAR & LOG ---
        right_layout = QVBoxLayout()
        
        # Session SeÃ§ici
        session_control = QHBoxLayout()
        self.combo_sessions = QComboBox()
        self.refresh_session_list()
        
        # Session deÄŸiÅŸince otomatik yÃ¼kle (opsiyonel ama kullanÄ±ÅŸlÄ±)
        # self.combo_sessions.currentIndexChanged.connect(self.load_session) 
        # Ancak kullanÄ±cÄ± yeni oluÅŸtururken vs karÄ±ÅŸabilir, butona bÄ±rakalÄ±m ÅŸimdilik.
        
        self.btn_new_session = QPushButton(tr("BTN_NEW_SESSION"))
        self.btn_new_session.clicked.connect(self.new_session)
        
        # Manuel KayÄ±t Butonu (Auto-save var ama kullanÄ±cÄ±lar basmayÄ± sever)
        self.btn_save_session = QPushButton(tr("BTN_SAVE"))
        self.btn_save_session.clicked.connect(lambda: self.save_session(show_msg=True))
        
        session_control.addWidget(self.combo_sessions, 2)
        session_control.addWidget(self.btn_new_session, 1)
        session_control.addWidget(self.btn_save_session, 1)
        
        self.btn_load_session = QPushButton(tr("BTN_LOAD_SESSION"))
        self.btn_load_session.clicked.connect(self.load_session)
        session_control.addWidget(self.btn_load_session)

        # Log
        self.txt_log = QTextEdit()
        self.txt_log.setPlaceholderText(tr("LBL_EVENT_LOG_PH"))
        # Log deÄŸiÅŸince de kaydet
        self.txt_log.textChanged.connect(self.auto_save)
        
        log_input_layout = QHBoxLayout()
        self.inp_log_entry = QTextEdit()
        self.inp_log_entry.setMaximumHeight(50)
        self.btn_add_log = QPushButton(tr("BTN_ADD_LOG"))
        self.btn_add_log.clicked.connect(self.add_log)
        log_input_layout.addWidget(self.inp_log_entry)
        log_input_layout.addWidget(self.btn_add_log)

        # Notlar
        self.txt_notes = QTextEdit()
        self.txt_notes.setPlaceholderText(tr("LBL_NOTES"))
        # Not deÄŸiÅŸince de kaydet
        self.txt_notes.textChanged.connect(self.auto_save)

        right_layout.addLayout(session_control)
        right_layout.addWidget(self.txt_log)
        right_layout.addLayout(log_input_layout)
        right_layout.addWidget(self.txt_notes)

        layout.addLayout(left_layout, 1)
        layout.addLayout(right_layout, 1)

    def retranslate_ui(self):
        # Update labels and button texts
        self.btn_new_session.setText(tr("BTN_NEW_SESSION"))
        self.btn_save_session.setText(tr("BTN_SAVE"))
        self.btn_load_session.setText(tr("BTN_LOAD_SESSION"))
        self.txt_log.setPlaceholderText(tr("LBL_EVENT_LOG_PH"))
        self.btn_add_log.setText(tr("BTN_ADD_LOG"))
        self.txt_notes.setPlaceholderText(tr("LBL_NOTES"))
        
        # Static labels (need to find them or store them)
        # For simplicity, I'll update the ones I have references for.
        # Labels like "Olay GÃ¼nlÃ¼ÄŸÃ¼" were added as QLabel(tr("LBL_LOG")) without refs.
        # I should probably store references to them if I want to update them.
        # But most users care about buttons and placeholders.
        
        # Update combat tracker
        if hasattr(self.combat_tracker, "retranslate_ui"):
            self.combat_tracker.retranslate_ui()

    # --- FONKSÄ°YONLAR ---
    def roll_dice(self, sides):
        result = random.randint(1, sides)
        self.log_message(tr("MSG_ROLLED_DICE", sides=sides, result=result))

    def log_message(self, message):
        timestamp = QDateTime.currentDateTime().toString("HH:mm")
        self.txt_log.append(f"[{timestamp}] {message}")

    def add_log(self):
        text = self.inp_log_entry.toPlainText().strip()
        if text:
            self.log_message(text)
            self.inp_log_entry.clear()

    def new_session(self):
        name, ok = QInputDialog.getText(self, tr("TITLE_NEW_SESSION"), tr("LBL_SESSION_NAME"))
        if ok and name:
            sid = self.dm.create_session(name)
            self.refresh_session_list()
            idx = self.combo_sessions.findData(sid)
            if idx >= 0: self.combo_sessions.setCurrentIndex(idx)
            
            self.current_session_id = sid
            self.txt_log.clear()
            self.txt_notes.clear()
            self.combat_tracker.clear_tracker()
            self.log_message(tr("MSG_SESSION_STARTED", name=name))
            self.save_session(show_msg=False) # Ä°lk kaydÄ± yap

    def refresh_session_list(self):
        self.combo_sessions.clear()
        sessions = self.dm.data.get("sessions", [])
        for s in sessions:
            self.combo_sessions.addItem(s["name"], s["id"])

    def load_session(self):
        sid = self.combo_sessions.currentData()
        if not sid: return
        
        session_data = self.dm.get_session(sid)
        if session_data:
            self.current_session_id = sid
            self.dm.set_active_session(sid) # Aktif olarak iÅŸaretle
            
            # Notlar ve Loglar
            self.txt_log.blockSignals(True)
            self.txt_notes.blockSignals(True)
            self.txt_log.setHtml(session_data.get("logs", ""))
            self.txt_notes.setText(session_data.get("notes", ""))
            self.txt_log.blockSignals(False)
            self.txt_notes.blockSignals(False)
            
            # Combat State
            combatants_data = session_data.get("combatants", [])
            if isinstance(combatants_data, dict):
                 self.combat_tracker.load_session_state(combatants_data)
            else:
                 self.combat_tracker.load_combat_data(combatants_data)
            
            # Loga yazma (Gereksiz kalabalÄ±k etmesin)
            # self.log_message("Oturum YÃ¼klendi.")

    def auto_save(self):
        """KullanÄ±cÄ±ya mesaj gÃ¶stermeden sessizce kaydeder."""
        if self.current_session_id:
            self.save_session(show_msg=False)

    def save_session(self, show_msg=False):
        if not self.current_session_id:
            if show_msg: QMessageBox.warning(self, tr("MSG_ERROR"), tr("MSG_CREATE_SESSION_FIRST"))
            return
            
        logs = self.txt_log.toHtml()
        notes = self.txt_notes.toPlainText()
        combat_state = self.combat_tracker.get_session_state()
        
        self.dm.save_session_data(self.current_session_id, notes, logs, combat_state)
        
        if show_msg:
            QMessageBox.information(self, tr("MSG_SUCCESS"), tr("MSG_SAVED"))

===== FILE PATH =====
./ui\widgets\aspect_ratio_label.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import QLabel
from PyQt6.QtGui import QPixmap
from PyQt6.QtCore import Qt
from core.locales import tr

class AspectRatioLabel(QLabel):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.setMinimumSize(100, 100)
        self.setStyleSheet("border: 2px dashed #444; background-color: #222; border-radius: 8px;")
        self._pixmap = None

    def setPixmap(self, pixmap):
        self._pixmap = pixmap
        self.update_image()

    def resizeEvent(self, event):
        self.update_image()
        super().resizeEvent(event)

    def update_image(self):
        if self._pixmap and not self._pixmap.isNull():
            scaled = self._pixmap.scaled(self.size(), Qt.AspectRatioMode.KeepAspectRatio, Qt.TransformationMode.SmoothTransformation)
            super().setPixmap(scaled)
        else:
            super().setPixmap(QPixmap())
            self.setText(tr("LBL_NO_IMAGE"))

===== FILE PATH =====
./ui\widgets\combat_tracker.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QTableWidget, QTableWidgetItem, 
                             QHBoxLayout, QPushButton, QHeaderView, QInputDialog, 
                             QMenu, QMessageBox, QFrame, QLineEdit, QFileDialog, 
                             QDialog, QListWidget, QListWidgetItem, QLabel, 
                             QAbstractItemView, QProgressBar, QSlider, QComboBox, QScrollArea)
from PyQt6.QtGui import QAction, QColor, QBrush, QCursor, QIcon, QPixmap, QPainter, QPainterPath
from PyQt6.QtCore import Qt, pyqtSignal, QSize, QUrl, QRect
from core.locales import tr
from ui.windows.battle_map_window import BattleMapWindow
from ui.dialogs.encounter_selector import EncounterSelectionDialog
import random
import os
import uuid

# --- YARDIMCILAR ---
def clean_stat_value(value, default=10):
    if value is None: return default
    s_val = str(value).strip()
    if not s_val: return default
    try:
        first_part = s_val.split(' ')[0]
        digits = ''.join(filter(str.isdigit, first_part))
        return int(digits) if digits else default
    except: return default

class ConditionIcon(QWidget):
    removed = pyqtSignal(str) # effect_name

    def __init__(self, name, icon_path, duration=0, max_duration=0):
        super().__init__()
        self.name = name
        self.icon_path = icon_path
        self.duration = int(duration)
        self.max_duration = int(max_duration)
        
        # --- DEÄžÄ°ÅžÄ°KLÄ°K 1: Boyutu KÃ¼Ã§Ã¼lttÃ¼k (36 -> 24) ---
        self.setFixedSize(24, 24) 
        
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.setToolTip(f"{name} ({self.duration}/{self.max_duration} Turns)")

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        # --- DEÄžÄ°ÅžÄ°KLÄ°K 2: Ã‡izim alanÄ±nÄ± 24px'e gÃ¶re ayarladÄ±k ---
        path = QPainterPath()
        path.addEllipse(1, 1, 22, 22) # Kenarlardan 1px boÅŸluk, 22px Ã§ap
        painter.setClipPath(path)
        
        if self.icon_path and os.path.exists(self.icon_path):
            # Resmi kÃ¼Ã§Ã¼k daireye sÄ±ÄŸdÄ±r
            painter.drawPixmap(0, 0, 24, 24, QPixmap(self.icon_path))
        else:
            # Resim yoksa varsayÄ±lan renk ve harf
            painter.setBrush(QBrush(QColor("#5c6bc0")))
            painter.drawRect(0, 0, 24, 24)
            painter.setPen(Qt.GlobalColor.white)
            
            # YazÄ± fontunu kÃ¼Ã§Ã¼lt
            font = painter.font()
            font.setPointSize(8) 
            font.setBold(True)
            painter.setFont(font)
            
            painter.drawText(QRect(0, 0, 24, 24), Qt.AlignmentFlag.AlignCenter, self.name[:2].upper())
            
        # SÃ¼re GÃ¶stergesi (Badge)
        if self.max_duration > 0:
            painter.setClipping(False) # Badge dairenin dÄ±ÅŸÄ±na taÅŸmasÄ±n ama kesilmesin diye klibi kaldÄ±rÄ±yoruz
            painter.setBrush(QBrush(QColor(0, 0, 0, 200))) # YarÄ± saydam siyah arka plan
            painter.setPen(Qt.PenStyle.NoPen)
            
            # Badge konumu (En alt kÄ±sÄ±m)
            painter.drawRoundedRect(0, 14, 24, 10, 2, 2) 
            
            painter.setPen(Qt.GlobalColor.white)
            font = painter.font()
            font.setPointSize(6) # Rakam fontu iyice kÃ¼Ã§Ã¼ldÃ¼
            font.setBold(True)
            painter.setFont(font)
            
            # RakamÄ± ortala
            painter.drawText(QRect(0, 14, 24, 10), Qt.AlignmentFlag.AlignCenter, f"{self.duration}")

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.RightButton:
            menu = QMenu(self)
            del_act = QAction("âŒ KaldÄ±r", self)
            del_act.triggered.connect(lambda: self.removed.emit(self.name))
            menu.addAction(del_act)
            menu.exec(event.globalPos())

# --- DURUMLAR WIDGETI ---
class ConditionsWidget(QWidget):
    conditionsChanged = pyqtSignal()
    clicked = pyqtSignal()

    def __init__(self, parent=None):
        super().__init__(parent)
        self.layout = QHBoxLayout(self)
        self.layout.setContentsMargins(2, 2, 2, 2)
        self.layout.setSpacing(2)
        self.layout.addStretch()
        self.active_conditions = []
        self.setCursor(Qt.CursorShape.PointingHandCursor)

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            # EÄŸer tÄ±klanan yer bir ikon deÄŸilse (boÅŸluksa) sinyal gÃ¶nder
            child = self.childAt(event.pos())
            if not isinstance(child, ConditionIcon):
                self.clicked.emit()
        super().mousePressEvent(event)

    def set_conditions(self, conditions_list):
        while self.layout.count() > 1: 
            item = self.layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()
        self.active_conditions = conditions_list
        for cond in conditions_list:
            icon_widget = ConditionIcon(cond["name"], cond.get("icon"), cond.get("duration"), cond.get("max_duration"))
            icon_widget.removed.connect(self.remove_condition)
            self.layout.insertWidget(self.layout.count() - 1, icon_widget)

    def add_condition(self, name, icon_path, max_turns):
        for c in self.active_conditions:
            if c["name"] == name: c["duration"] = max_turns; c["max_duration"] = max_turns; self.set_conditions(self.active_conditions); self.conditionsChanged.emit(); return
        self.active_conditions.append({"name": name, "icon": icon_path, "duration": max_turns, "max_duration": max_turns})
        self.set_conditions(self.active_conditions); self.conditionsChanged.emit()

    def remove_condition(self, name):
        self.active_conditions = [c for c in self.active_conditions if c["name"] != name]
        self.set_conditions(self.active_conditions); self.conditionsChanged.emit()

    def tick_conditions(self):
        remaining = []
        for c in self.active_conditions:
            if c["max_duration"] > 0:
                c["duration"] -= 1
                if c["duration"] > 0: remaining.append(c)
            else: remaining.append(c)
        self.active_conditions = remaining; self.set_conditions(self.active_conditions); self.conditionsChanged.emit()

# --- HP BAR WIDGET ---
class HpBarWidget(QWidget):
    hpChanged = pyqtSignal(int)
    def __init__(self, current_hp, max_hp):
        super().__init__(); self.current = int(current_hp); self.max_val = int(max_hp) if int(max_hp) > 0 else 1
        l = QHBoxLayout(self); l.setContentsMargins(0, 2, 0, 2); l.setSpacing(2)
        b_m = QPushButton("-"); b_m.setFixedSize(20, 20); b_m.setCursor(Qt.CursorShape.PointingHandCursor); b_m.setStyleSheet("QPushButton { background-color: #c62828; color: white; border: none; border-radius: 3px; font-weight: bold; } QPushButton:hover { background-color: #d32f2f; }"); b_m.clicked.connect(self.decrease_hp)
        self.bar = QProgressBar(); self.bar.setRange(0, self.max_val); self.bar.setValue(self.current); self.bar.setTextVisible(True); self.bar.setFormat(f"%v / {self.max_val}"); self.bar.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.update_color()
        b_p = QPushButton("+"); b_p.setFixedSize(20, 20); b_p.setCursor(Qt.CursorShape.PointingHandCursor); b_p.setStyleSheet("QPushButton { background-color: #2e7d32; color: white; border: none; border-radius: 3px; font-weight: bold; } QPushButton:hover { background-color: #388e3c; }"); b_p.clicked.connect(self.increase_hp)
        l.addWidget(b_m); l.addWidget(self.bar, 1); l.addWidget(b_p)

    def update_color(self):
        r = self.current / self.max_val if self.max_val > 0 else 0
        c = "#2e7d32" if r > 0.5 else "#fbc02d" if r > 0.2 else "#c62828"
        self.bar.setStyleSheet(f"QProgressBar::chunk {{ background-color: {c}; }} QProgressBar {{ color: white; border: 1px solid #555; border-radius: 3px; background: rgba(0,0,0,0.3); }}")

    def update_hp(self, new_hp): self.current = int(new_hp); self.bar.setValue(self.current); self.bar.setFormat(f"{self.current} / {self.max_val}"); self.update_color(); self.hpChanged.emit(self.current)
    def decrease_hp(self): self.update_hp(self.current - 1)
    def increase_hp(self): self.update_hp(self.current + 1)

CONDITIONS = ["Blinded", "Charmed", "Deafened", "Frightened", "Grappled", "Incapacitated", "Invisible", "Paralyzed", "Petrified", "Poisoned", "Prone", "Restrained", "Stunned", "Unconscious", "Exhaustion"]

class NumericTableWidgetItem(QTableWidgetItem):
    def __lt__(self, other):
        try: return float(self.data(Qt.ItemDataRole.DisplayRole)) < float(other.data(Qt.ItemDataRole.DisplayRole))
        except: return super().__lt__(other)

class MapSelectorDialog(QDialog):
    def __init__(self, assets_path, parent=None):
        super().__init__(parent); self.assets_path = assets_path; self.selected_file = None; self.is_new_import = False; self.setWindowTitle(tr("TITLE_MAP_SELECTOR")); self.setFixedSize(600, 500); self.init_ui(); self.load_maps()
    def init_ui(self):
        l = QVBoxLayout(self); lbl = QLabel(tr("LBL_SAVED_MAPS")); lbl.setObjectName("toolbarLabel"); l.addWidget(lbl)
        self.lw = QListWidget(); self.lw.setViewMode(QListWidget.ViewMode.IconMode); self.lw.setIconSize(QSize(150, 150)); self.lw.setResizeMode(QListWidget.ResizeMode.Adjust); self.lw.setSpacing(10); self.lw.setProperty("class", "iconList"); self.lw.itemDoubleClicked.connect(self.select_existing); l.addWidget(self.lw)
        h = QHBoxLayout(); b1 = QPushButton(tr("BTN_IMPORT_NEW_MAP")); b1.setObjectName("successBtn"); b1.clicked.connect(self.select_new); b2 = QPushButton(tr("BTN_OPEN_SELECTED_MAP")); b2.setObjectName("primaryBtn"); b2.clicked.connect(self.select_existing); h.addWidget(b1); h.addStretch(); h.addWidget(b2); l.addLayout(h)
    def load_maps(self):
        if not os.path.exists(self.assets_path): return
        for f in os.listdir(self.assets_path):
             if f.lower().endswith(('.png', '.jpg', '.jpeg')): self.lw.addItem(QListWidgetItem(QIcon(os.path.join(self.assets_path, f)), f))
    def select_existing(self):
        if self.lw.currentItem(): self.selected_file = self.lw.currentItem().text(); self.accept()
        else: QMessageBox.warning(self, tr("MSG_WARNING"), tr("MSG_SELECT_MAP_FROM_LIST"))
    def select_new(self): self.is_new_import = True; self.accept()

# --- COMBAT TRACKER ---
class CombatTracker(QWidget):
    data_changed_signal = pyqtSignal()

    def __init__(self, data_manager):
        super().__init__()
        self.dm = data_manager; self.battle_map_window = None; self.loading = False; self.encounters = {}; self.current_encounter_id = None
        self.create_encounter("Default Encounter"); self.init_ui()

    def init_ui(self):
        layout = QVBoxLayout(self)
        
        enc_layout = QHBoxLayout()
        self.combo_encounters = QComboBox(); self.combo_encounters.currentIndexChanged.connect(self.switch_encounter); self.combo_encounters.setMinimumWidth(200)
        self.btn_new_enc = QPushButton("âž•"); self.btn_new_enc.setFixedWidth(40); self.btn_new_enc.setToolTip(tr("TIP_NEW_ENC")); self.btn_new_enc.clicked.connect(self.prompt_new_encounter)
        self.btn_rename_enc = QPushButton("âœï¸"); self.btn_rename_enc.setFixedWidth(40); self.btn_rename_enc.setToolTip(tr("TIP_RENAME_ENC")); self.btn_rename_enc.clicked.connect(self.rename_encounter)
        self.btn_del_enc = QPushButton("ðŸ—‘ï¸"); self.btn_del_enc.setFixedWidth(40); self.btn_del_enc.setToolTip(tr("TIP_DEL_ENC")); self.btn_del_enc.clicked.connect(self.delete_encounter); self.btn_del_enc.setObjectName("dangerBtn")
        enc_layout.addWidget(QLabel(tr("LBL_ENCOUNTER_PREFIX"))); enc_layout.addWidget(self.combo_encounters); enc_layout.addWidget(self.btn_new_enc); enc_layout.addWidget(self.btn_rename_enc); enc_layout.addWidget(self.btn_del_enc)
        layout.addLayout(enc_layout)

        self.table = QTableWidget(); self.table.setColumnCount(5); self.table.setHorizontalHeaderLabels([tr("HEADER_NAME"), tr("HEADER_INIT"), tr("HEADER_AC"), tr("HEADER_HP"), tr("HEADER_COND")])
        self.table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch); self.table.horizontalHeader().setSectionResizeMode(4, QHeaderView.ResizeMode.Stretch)
        self.table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows); self.table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.table.customContextMenuRequested.connect(self.open_context_menu); self.table.itemChanged.connect(self.on_data_changed); self.table.cellDoubleClicked.connect(self.on_cell_double_clicked); self.table.setSortingEnabled(False)
        layout.addWidget(self.table)

        q_lo = QHBoxLayout()
        self.inp_quick_name = QLineEdit(); self.inp_quick_name.setPlaceholderText(tr("HEADER_NAME"))
        self.inp_quick_init = QLineEdit(); self.inp_quick_init.setPlaceholderText(tr("LBL_INIT")); self.inp_quick_init.setMaximumWidth(50)
        self.inp_quick_hp = QLineEdit(); self.inp_quick_hp.setPlaceholderText(tr("LBL_HP")); self.inp_quick_hp.setMaximumWidth(50)
        self.btn_quick_add = QPushButton(tr("BTN_QUICK_ADD")); self.btn_quick_add.clicked.connect(self.quick_add)
        q_lo.addWidget(self.inp_quick_name, 3); q_lo.addWidget(self.inp_quick_init, 1); q_lo.addWidget(self.inp_quick_hp, 1); q_lo.addWidget(self.btn_quick_add, 1)
        layout.addLayout(q_lo)

        btn_layout = QHBoxLayout()
        self.lbl_round = QLabel(f"{tr('LBL_ROUND_PREFIX')}1"); self.lbl_round.setObjectName("headerLabel"); self.lbl_round.setStyleSheet("font-size: 16px; font-weight: bold; margin-right: 10px;")
        self.btn_next_turn = QPushButton(tr("BTN_NEXT_TURN")); self.btn_next_turn.setObjectName("actionBtn"); self.btn_next_turn.clicked.connect(self.next_turn)
        self.btn_battle_map = QPushButton(tr("BTN_BATTLE_MAP")); self.btn_battle_map.setObjectName("primaryBtn"); self.btn_battle_map.clicked.connect(self.open_battle_map)
        btn_layout.addWidget(self.lbl_round); btn_layout.addWidget(self.btn_next_turn); btn_layout.addWidget(self.btn_battle_map)
        layout.addLayout(btn_layout)
        
        btn_layout2 = QHBoxLayout()
        self.btn_add = QPushButton(tr("BTN_ADD")); self.btn_add.clicked.connect(self.add_combatant_dialog)
        self.btn_add_players = QPushButton(tr("BTN_ADD_PLAYERS")); self.btn_add_players.clicked.connect(self.add_all_players)
        self.btn_roll = QPushButton(tr("BTN_ROLL_INIT")); self.btn_roll.clicked.connect(self.roll_initiatives)
        
        # --- HATA BURADAYDI: self.clear_tracker tanÄ±mlanmadan Ã¶nce kullanÄ±lÄ±yordu ---
        # Ama Python'da self.clear_tracker metoduna referans vermek sorun olmaz, 
        # sorun clear_tracker metodunun sÄ±nÄ±f iÃ§inde hiÃ§ tanÄ±mlanmamÄ±ÅŸ olmasÄ±ydÄ±.
        self.btn_clear_all = QPushButton(tr("BTN_CLEAR_ALL"))
        self.btn_clear_all.clicked.connect(self.clear_tracker) 
        self.btn_clear_all.setObjectName("dangerBtn")
        
        btn_layout2.addWidget(self.btn_add); btn_layout2.addWidget(self.btn_add_players); btn_layout2.addWidget(self.btn_roll); btn_layout2.addWidget(self.btn_clear_all)
        layout.addLayout(btn_layout2)
        
        self.refresh_encounter_combo()

    def create_encounter(self, name):
        eid = str(uuid.uuid4()); self.encounters[eid] = {"id":eid, "name":name, "combatants":[], "map_path":None, "token_size":50, "turn_index":-1, "round":1, "token_positions":{}}; self.current_encounter_id = eid; return eid
    def prompt_new_encounter(self): 
        n,ok = QInputDialog.getText(self, tr("TITLE_NEW_ENC"), tr("LBL_ENC_NAME")); 
        if ok and n: self.create_encounter(n); self.refresh_encounter_combo()
    def rename_encounter(self):
        if not self.current_encounter_id: return
        n,ok = QInputDialog.getText(self, tr("TITLE_RENAME_ENC"), tr("LBL_NEW_NAME"), text=self.encounters[self.current_encounter_id]["name"])
        if ok and n: self.encounters[self.current_encounter_id]["name"] = n; self.refresh_encounter_combo()
    def delete_encounter(self):
        if len(self.encounters) <= 1: QMessageBox.warning(self, tr("MSG_ERROR"), tr("MSG_LAST_ENC_DELETE")); return
        if QMessageBox.question(self, tr("TITLE_DELETE"), tr("MSG_CONFIRM_ENC_DELETE"), QMessageBox.StandardButton.Yes|QMessageBox.StandardButton.No)==QMessageBox.StandardButton.Yes: del self.encounters[self.current_encounter_id]; self.refresh_encounter_combo()
    def switch_encounter(self, idx): 
        eid = self.combo_encounters.itemData(idx)
        if eid and eid in self.encounters: self._save_current_state_to_memory(); self.current_encounter_id = eid; self.refresh_ui_from_current_encounter(); self.refresh_battle_map(force_map_reload=True)
    def refresh_encounter_combo(self):
        self.combo_encounters.blockSignals(True); self.combo_encounters.clear()
        if not self.encounters: self.create_encounter("Default Encounter")
        for eid, e in self.encounters.items(): self.combo_encounters.addItem(e["name"], eid)
        if self.current_encounter_id: self.combo_encounters.setCurrentIndex(self.combo_encounters.findData(self.current_encounter_id))
        else: self.current_encounter_id = self.combo_encounters.itemData(0); self.combo_encounters.setCurrentIndex(0)
        self.combo_encounters.blockSignals(False); self.refresh_ui_from_current_encounter()

    def add_direct_row(self, name, init, ac, hp, conditions_data, eid, init_bonus=0, tid=None):
        if not tid: tid = str(uuid.uuid4())
        
        # --- KRÄ°TÄ°K EKLEME: Sinyalleri Durdur ---
        # Tabloyu doldururken "Veri deÄŸiÅŸti" sinyalini kapatÄ±yoruz ki sÃ¼rekli kaydetmeye Ã§alÄ±ÅŸÄ±p Ã§Ã¶kmesin.
        self.table.blockSignals(True)
        
        row = self.table.rowCount()
        self.table.insertRow(row)
        
        self.table.setItem(row, 0, QTableWidgetItem(name))
        
        it_init = NumericTableWidgetItem(str(init))
        it_init.setData(Qt.ItemDataRole.UserRole, eid)
        it_init.setData(Qt.ItemDataRole.UserRole+1, tid)
        self.table.setItem(row, 1, it_init)
        
        self.table.setItem(row, 2, NumericTableWidgetItem(str(clean_stat_value(ac))))
        
        cur = clean_stat_value(hp)
        mx = cur
        if eid and eid in self.dm.data["entities"]:
             try: 
                 db_max = clean_stat_value(self.dm.data["entities"][eid]["combat_stats"]["max_hp"])
                 mx = db_max if db_max >= cur else cur
             except: pass
             
        hp_w = HpBarWidget(cur, mx)
        hp_w.hpChanged.connect(lambda v, w=hp_w: self.on_widget_hp_changed(w, v))
        self.table.setCellWidget(row, 3, hp_w)
        
        # HP hÃ¼cresi (Sort iÃ§in gizli text)
        self.table.setItem(row, 3, NumericTableWidgetItem(str(cur))) 
        
        cond_w = ConditionsWidget()
        # --- Condition Widget Signal BaÄŸlantÄ±sÄ± (Ã–nceki dÃ¼zeltmelerden gelen) ---
        cond_w.clicked.connect(lambda w=cond_w: self.open_condition_menu_for_widget(w))
        
        if isinstance(conditions_data, str) and conditions_data: 
            conditions_data = [{"name": c.strip(), "icon": None, "duration": 0, "max_duration": 0} for c in conditions_data.split(",")]
        elif not isinstance(conditions_data, list): 
            conditions_data = []
            
        cond_w.set_conditions(conditions_data)
        cond_w.conditionsChanged.connect(self.data_changed_signal.emit)
        self.table.setCellWidget(row, 4, cond_w)

        # --- KRÄ°TÄ°K EKLEME: Sinyalleri Geri AÃ§ ---
        self.table.blockSignals(False)
        
        # Ä°ÅŸlem bitince bir kere kaydet sinyali gÃ¶nderelim
        self.data_changed_signal.emit()

    def open_condition_menu_for_widget(self, widget):
        # Widget'Ä±n hangi satÄ±rda olduÄŸunu bul
        index = self.table.indexAt(widget.pos())
        if not index.isValid(): return
        row = index.row()
        
        # MenÃ¼yÃ¼ oluÅŸtur
        menu = QMenu(self)
        menu.setStyleSheet("QMenu { background-color: #333; color: white; border: 1px solid #555; } QMenu::item:selected { background-color: #007acc; }")
        
        # 1. Standart Durumlar (Standard 5e Conditions)
        std_menu = menu.addMenu(tr("MENU_STD_CONDITIONS"))
        for cond in CONDITIONS: # DosyanÄ±n baÅŸÄ±nda tanÄ±mlÄ± liste
            action = QAction(cond, self)
            action.triggered.connect(lambda checked, r=row, n=cond: self.add_condition_to_row(r, n, None, 0))
            std_menu.addAction(action)
            
        menu.addSeparator()
        
        # 2. Ã–zel Durum Etkileri (Status Effects from Database)
        # VeritabanÄ±nda tipi "Status Effect" olanlarÄ± Ã§ek
        custom_effects = [e for e in self.dm.data["entities"].values() if e.get("type") == "Status Effect"]
        
        if custom_effects:
            lbl = menu.addAction(tr("MENU_SAVED_EFFECTS"))
            lbl.setEnabled(False)
            
            for eff in custom_effects:
                eff_name = eff.get("name", "Bilinmeyen")
                
                # Ä°kon yolu (varsa)
                icon_path = None
                if eff.get("images"):
                    full_path = self.dm.get_full_path(eff["images"][0])
                    if full_path and os.path.exists(full_path):
                        icon_path = full_path
                
                # SÃ¼re (Duration)
                try: 
                    duration = int(eff.get("attributes", {}).get("LBL_DURATION_TURNS", 0))
                except: 
                    duration = 0
                
                action = QAction(eff_name, self)
                if icon_path:
                    action.setIcon(QIcon(icon_path))
                
                # TÄ±klanÄ±nca eklenecek
                action.triggered.connect(lambda checked, r=row, n=eff_name, p=icon_path, d=duration: self.add_condition_to_row(r, n, p, d))
                menu.addAction(action)
        else:
            no_act = menu.addAction(tr("MSG_NO_SAVED_EFFECTS"))
            no_act.setEnabled(False)

        # MenÃ¼yÃ¼ fare pozisyonunda aÃ§
        menu.exec(QCursor.pos())

    def refresh_ui_from_current_encounter(self):
        self.loading = True; self.table.blockSignals(True); self.table.setRowCount(0)
        if not self.current_encounter_id: return
        enc = self.encounters[self.current_encounter_id]
        self.lbl_round.setText(f"{tr('LBL_ROUND_PREFIX')}{enc.get('round', 1)}")
        for c in enc.get("combatants", []):
            tid = c.get("tid") or str(uuid.uuid4())
            if c.get("x") is not None: enc["token_positions"][tid] = (float(c["x"]), float(c["y"]))
            self.add_direct_row(c["name"], c["init"], c["ac"], c["hp"], c.get("conditions", []), c["eid"], c.get("bonus", 0), tid)
        self._sort_and_refresh(); self.table.blockSignals(False); self.loading = False

    def _save_current_state_to_memory(self):
        if not self.current_encounter_id: return
        
        enc = self.encounters[self.current_encounter_id]
        combatants = []
        
        for r in range(self.table.rowCount()):
            # Ä°sim hÃ¼cresi yoksa bu satÄ±rÄ± atla (HenÃ¼z oluÅŸmamÄ±ÅŸ satÄ±r)
            if not self.table.item(r, 0): continue
            
            # --- GÃœVENLÄ° VERÄ° OKUMA ---
            # EÄŸer hÃ¼cre henÃ¼z oluÅŸturulmadÄ±ysa (None ise) varsayÄ±lan deÄŸer dÃ¶ndÃ¼r
            def get_text_safe(col_index, default_val=""):
                item = self.table.item(r, col_index)
                return item.text() if item else default_val

            hp_w = self.table.cellWidget(r, 3)
            cond_w = self.table.cellWidget(r, 4)
            
            # ID'leri gÃ¼venli al
            tid = None
            eid = None
            item_init = self.table.item(r, 1)
            if item_init:
                tid = item_init.data(Qt.ItemDataRole.UserRole + 1)
                eid = item_init.data(Qt.ItemDataRole.UserRole)
            
            if not tid: tid = str(uuid.uuid4())

            combatants.append({
                "tid": str(tid),
                "eid": str(eid) if eid else None,
                "name": get_text_safe(0, "???"),  # Ä°sim
                "init": get_text_safe(1, "0"),    # Ä°nisiyatif
                "ac": get_text_safe(2, "10"),     # AC
                "hp": str(hp_w.current) if hp_w else "0",
                "conditions": cond_w.active_conditions if cond_w else [],
                "bonus": 0,
                "x": enc["token_positions"].get(tid, (None,None))[0],
                "y": enc["token_positions"].get(tid, (None,None))[1]
            })
            
        enc["combatants"] = combatants

    def next_turn(self):
        if not self.current_encounter_id: return
        enc = self.encounters[self.current_encounter_id]; count = self.table.rowCount()
        if count == 0: return
        self.loading = True; enc["turn_index"] += 1
        if enc["turn_index"] >= count: enc["turn_index"] = 0; enc["round"] += 1; self.lbl_round.setText(f"{tr('LBL_ROUND_PREFIX')}{enc['round']}")
        w = self.table.cellWidget(enc["turn_index"], 4)
        if w: w.tick_conditions()
        self.update_highlights(); self.refresh_battle_map(); self.loading = False; self.data_changed_signal.emit()

    def update_highlights(self):
        if not self.current_encounter_id: return
        idx = self.encounters[self.current_encounter_id]["turn_index"]
        self.table.blockSignals(True)
        for r in range(self.table.rowCount()):
             for c in range(self.table.columnCount()):
                  if self.table.item(r, c): self.table.item(r, c).setBackground(QBrush(Qt.BrushStyle.NoBrush))
        if 0 <= idx < self.table.rowCount():
             for c in range(self.table.columnCount()):
                  if self.table.item(idx, c): self.table.item(idx, c).setBackground(QBrush(QColor(100, 149, 237, 100)))
        self.table.blockSignals(False)

    def _sort_and_refresh(self):
        if not self.current_encounter_id: return
        enc = self.encounters[self.current_encounter_id]; cur_tid = None
        if 0 <= enc["turn_index"] < self.table.rowCount(): cur_tid = self.table.item(enc["turn_index"], 1).data(Qt.ItemDataRole.UserRole+1)
        self.table.blockSignals(True); self.table.sortItems(1, Qt.SortOrder.DescendingOrder); self.table.blockSignals(False)
        if cur_tid:
             for r in range(self.table.rowCount()):
                  if self.table.item(r, 1).data(Qt.ItemDataRole.UserRole+1) == cur_tid: enc["turn_index"] = r; break
        self.update_highlights(); self.refresh_battle_map(); 
        if not self.loading: self.data_changed_signal.emit()

    def on_widget_hp_changed(self, widget, val):
        idx = self.table.indexAt(widget.pos())
        if idx.isValid(): self.table.item(idx.row(), 3).setText(str(val)); self._save_current_state_to_memory(); self.refresh_battle_map(); self.data_changed_signal.emit()

    def open_context_menu(self, pos):
        row = self.table.rowAt(pos.y()); 
        if row == -1: return
        menu = QMenu()
        add_cond_menu = menu.addMenu("ðŸ©¸ " + tr("MENU_ADD_COND") if tr("MENU_ADD_COND") else "Add Condition")
        for c in CONDITIONS: 
             a = QAction(c, self); a.triggered.connect(lambda ch, n=c: self.add_condition_to_row(row, n, None, 0)); add_cond_menu.addAction(a)
        add_cond_menu.addSeparator()
        custom_effects = [e for e in self.dm.data["entities"].values() if e.get("type") == "Status Effect"]
        for eff in custom_effects:
            p = self.dm.get_full_path(eff["images"][0]) if eff.get("images") else None
            try: d = int(eff.get("attributes", {}).get("LBL_DURATION_TURNS", 0))
            except: d = 0
            a = QAction(eff["name"], self); 
            if p: a.setIcon(QIcon(p))
            a.triggered.connect(lambda ch, n=eff["name"], p=p, d=d: self.add_condition_to_row(row, n, p, d))
            add_cond_menu.addAction(a)
        menu.addSeparator()
        del_act = QAction("âŒ " + tr("MENU_REMOVE_COMBAT") if tr("MENU_REMOVE_COMBAT") else "Remove", self); del_act.triggered.connect(lambda: self.delete_row(row)); menu.addAction(del_act)
        menu.exec(self.table.viewport().mapToGlobal(pos))

    def add_condition_to_row(self, row, name, icon_path, duration):
        if duration == 0:
            d, ok = QInputDialog.getInt(self, tr("LBL_DURATION_PROMPT_TITLE"), tr("LBL_DURATION_PROMPT_MSG", name=name), 0, 0, 100)
            if ok: duration = d
        w = self.table.cellWidget(row, 4)
        if w: w.add_condition(name, icon_path, duration)
    
    # --- EKSÄ°K OLAN FONKSÄ°YON EKLENDÄ° ---
    def clear_tracker(self):
        if not self.current_encounter_id: return
        enc = self.encounters[self.current_encounter_id]
        
        self.table.setRowCount(0)
        enc["combatants"] = []
        enc["token_positions"] = {}
        enc["turn_index"] = -1
        enc["round"] = 1
        enc["map_path"] = None 
        
        self.lbl_round.setText(f"{tr('LBL_ROUND_PREFIX')}1")
        self.refresh_battle_map(force_map_reload=True) 
        if not self.loading: self.data_changed_signal.emit()
    # -----------------------------------

    def on_cell_double_clicked(self, r, c): 
        if c==3: 
            w=self.table.cellWidget(r,3); 
            if w: 
                v,ok=QInputDialog.getInt(self, tr("TITLE_EDIT_HP"), tr("LBL_NEW_HP"), w.current, 0, 9999)
                if ok: w.update_hp(v)
    def on_data_changed(self, i): 
        if self.loading: return
        if i.column()==1: self._sort_and_refresh()
        else: self._save_current_state_to_memory(); self.data_changed_signal.emit()
    def quick_add(self):
        n=self.inp_quick_name.text().strip(); 
        if n: self.add_direct_row(n, self.inp_quick_init.text() or str(random.randint(1,20)), "10", self.inp_quick_hp.text() or "10", [], None); self.inp_quick_name.clear(); self._sort_and_refresh()
    def add_combatant_dialog(self):
        d=EncounterSelectionDialog(self.dm, self)
        if d.exec(): 
            for eid in d.selected_entities: self.add_row_from_entity(eid)
            self._sort_and_refresh()
    def add_row_from_entity(self, eid):
        d=self.dm.data["entities"].get(eid)
        if d:
            try: m=(int(d["stats"]["DEX"])-10)//2
            except: m=0
            try: m+=clean_stat_value(d["combat_stats"].get("initiative"), 0)
            except: pass
            self.add_direct_row(d["name"], random.randint(1,20)+m, d["combat_stats"].get("ac","10"), d["combat_stats"].get("hp","10"), [], eid, m)
    def add_all_players(self):
        ex=[self.table.item(r,1).data(Qt.ItemDataRole.UserRole) for r in range(self.table.rowCount())]
        for k,v in self.dm.data["entities"].items(): 
            if v["type"]=="Player" and k not in ex: self.add_row_from_entity(k)
        self._sort_and_refresh()
    def roll_initiatives(self):
        self.table.blockSignals(True)
        for r in range(self.table.rowCount()):
             b = self.table.item(r,0).data(Qt.ItemDataRole.UserRole) or 0
             self.table.item(r,1).setText(str(random.randint(1,20)+b))
        self.table.blockSignals(False); self._sort_and_refresh()
    def delete_row(self, r): 
        self.table.removeRow(r)
        if self.current_encounter_id:
             enc = self.encounters[self.current_encounter_id]
             if enc["turn_index"] >= r: enc["turn_index"] = max(0, enc["turn_index"]-1)
        self.update_highlights(); self.refresh_battle_map(); self.data_changed_signal.emit()
    def get_session_state(self): self._save_current_state_to_memory(); return {"encounters": self.encounters, "current_encounter_id": self.current_encounter_id}
    def load_session_state(self, d):
        self.loading=True; self.combo_encounters.blockSignals(True); self.combo_encounters.clear()
        if "encounters" in d: self.encounters=d["encounters"]; tid=d.get("current_encounter_id")
        else: # Legacy
             eid=str(uuid.uuid4()); self.encounters={eid:{"id":eid,"name":"Legacy","combatants":d.get("combatants",[]),"round":1,"turn_index":-1,"token_positions":{},"token_size":50}}; tid=eid
        for k,v in self.encounters.items(): self.combo_encounters.addItem(v["name"], k)
        if tid: self.combo_encounters.setCurrentIndex(self.combo_encounters.findData(tid)); self.current_encounter_id=tid
        else: self.combo_encounters.setCurrentIndex(0); self.current_encounter_id=self.combo_encounters.itemData(0)
        self.refresh_ui_from_current_encounter(); self.combo_encounters.blockSignals(False); self.loading=False
    def load_combat_data(self, l): self.load_session_state({"combatants":l})
    
    def open_battle_map(self):
        if self.battle_map_window and self.battle_map_window.isVisible(): self.battle_map_window.raise_(); self.battle_map_window.activateWindow(); return
        enc = self.encounters.get(self.current_encounter_id)
        if not enc: return
        if not enc.get("map_path"):
             d=MapSelectorDialog(os.path.join(self.dm.current_campaign_path,"assets"), self)
             if d.exec():
                  if d.is_new_import: 
                       f,_=QFileDialog.getOpenFileName(self,"Select","", "Img (*.png *.jpg)"); 
                       if f: enc["map_path"]=self.dm.import_image(f)
                  elif d.selected_file: enc["map_path"]=os.path.join("assets",d.selected_file)
                  self.data_changed_signal.emit()
             else: return
        self.battle_map_window = BattleMapWindow(self.dm)
        self.battle_map_window.token_moved_signal.connect(self.on_token_moved_in_map)
        self.battle_map_window.slider_size.valueChanged.connect(self.on_token_size_changed)
        self.battle_map_window.show(); self.refresh_battle_map(True)
    def on_token_moved_in_map(self, tid, x, y): 
        if self.current_encounter_id: self.encounters[self.current_encounter_id]["token_positions"][tid]=(x,y); self.data_changed_signal.emit()
    def on_token_size_changed(self, v): 
        if self.current_encounter_id: self.encounters[self.current_encounter_id]["token_size"]=v; self.data_changed_signal.emit()
    def refresh_battle_map(self, force_map_reload=False):
        if not self.battle_map_window or not self.current_encounter_id: return
        enc=self.encounters[self.current_encounter_id]; self._save_current_state_to_memory()
        mp=self.dm.get_full_path(enc.get("map_path")) if (force_map_reload or not self.battle_map_window.map_item) else None
        cd=[]
        for c in enc["combatants"]:
             t="NPC"; a="LBL_ATTR_NEUTRAL"
             if c["eid"] in self.dm.data["entities"]:
                  e=self.dm.data["entities"][c["eid"]]; t=e.get("type","NPC"); a=e.get("attributes",{}).get("LBL_ATTITUDE","LBL_ATTR_NEUTRAL"); 
                  if t=="Monster": a="LBL_ATTR_HOSTILE"
             c["type"]=t; c["attitude"]=a; cd.append(c)
        self.battle_map_window.update_combat_data(cd, enc["turn_index"], mp, enc["token_size"])

    def retranslate_ui(self):
        self.table.setHorizontalHeaderLabels([tr("HEADER_NAME"), tr("HEADER_INIT"), tr("HEADER_AC"), tr("HEADER_HP"), tr("HEADER_COND")])
        self.inp_quick_name.setPlaceholderText(tr("HEADER_NAME"))
        self.btn_quick_add.setText(tr("BTN_QUICK_ADD"))
        self.btn_next_turn.setText(tr("BTN_NEXT_TURN"))
        self.btn_add.setText(tr("BTN_ADD"))
        self.btn_add_players.setText(tr("BTN_ADD_PLAYERS"))
        self.btn_roll.setText(tr("BTN_ROLL_INIT"))
        self.btn_clear_all.setText(tr("BTN_CLEAR_ALL"))
        if self.current_encounter_id: self.lbl_round.setText(f"{tr('LBL_ROUND_PREFIX')}{self.encounters[self.current_encounter_id].get('round', 1)}")
        if self.battle_map_window and self.battle_map_window.isVisible(): self.battle_map_window.retranslate_ui(); self.refresh_battle_map()

===== FILE PATH =====
./ui\widgets\image_viewer.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import QGraphicsView, QGraphicsScene, QGraphicsPixmapItem
from PyQt6.QtGui import QPainter, QWheelEvent
from PyQt6.QtCore import Qt

class ImageViewer(QGraphicsView):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        
        # Kaliteli Render AyarlarÄ±
        self.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)
        
        # SÃ¼rÃ¼kle ve Gez
        self.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        self.setResizeAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        
        # Arka plan (Siyah/KaranlÄ±k)
        self.setStyleSheet("background-color: #000; border: none;")
        self.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        self.pixmap_item = None

    def set_image(self, pixmap):
        self.scene.clear()
        if pixmap and not pixmap.isNull():
            self.pixmap_item = QGraphicsPixmapItem(pixmap)
            # Kaliteli kÃ¼Ã§Ã¼ltme/bÃ¼yÃ¼tme modu
            self.pixmap_item.setTransformationMode(Qt.TransformationMode.SmoothTransformation)
            self.scene.addItem(self.pixmap_item)
            self.setSceneRect(self.pixmap_item.boundingRect())
            self.fitInView(self.pixmap_item, Qt.AspectRatioMode.KeepAspectRatio) # Ä°lk aÃ§Ä±lÄ±ÅŸta sÄ±ÄŸdÄ±r
        else:
            self.pixmap_item = None

    def wheelEvent(self, event: QWheelEvent):
        # Zoom Ä°ÅŸlemi
        zoom_in_factor = 1.15
        zoom_out_factor = 1 / zoom_in_factor

        if event.angleDelta().y() > 0:
            self.scale(zoom_in_factor, zoom_in_factor)
        else:
            self.scale(zoom_out_factor, zoom_out_factor)

===== FILE PATH =====
./ui\widgets\map_viewer.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import QGraphicsView, QGraphicsScene, QGraphicsPixmapItem, QGraphicsEllipseItem, QMenu, QGraphicsItem
from PyQt6.QtGui import QPixmap, QBrush, QColor, QPen, QAction, QPainter, QWheelEvent, QCursor
from PyQt6.QtCore import Qt, pyqtSignal
from core.locales import tr

class MapPinItem(QGraphicsEllipseItem):
    def __init__(self, x, y, radius, color, pin_id, entity_id, tooltip_text, callback_action):
        super().__init__(x - radius/2, y - radius/2, radius, radius)
        self.pin_id = pin_id
        self.entity_id = entity_id
        self.callback_action = callback_action # (action_type, pin_obj) -> Fonksiyon
        
        self.setBrush(QBrush(QColor(color)))
        pen = QPen(Qt.GlobalColor.white)
        pen.setWidth(2)
        self.setPen(pen)
        
        self.setToolTip(tooltip_text)
        self.setZValue(10)
        self.setCursor(Qt.CursorShape.PointingHandCursor)
        self.setFlags(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable)

    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            # Sol tÄ±k menÃ¼sÃ¼
            menu = QMenu()
            menu.setStyleSheet("QMenu { background-color: #333; color: white; border: 1px solid #555; } QMenu::item:selected { background-color: #007acc; }")
            
            act_inspect = QAction(tr("MENU_CTX_INSPECT"), menu)
            act_move = QAction(tr("MENU_CTX_MOVE"), menu)
            act_delete = QAction(tr("MENU_CTX_DELETE"), menu)
            
            menu.addAction(act_inspect)
            menu.addAction(act_move)
            menu.addSeparator()
            menu.addAction(act_delete)
            
            selected = menu.exec(QCursor.pos())
            
            if selected == act_inspect: self.callback_action("inspect", self)
            elif selected == act_move: self.callback_action("move", self)
            elif selected == act_delete: self.callback_action("delete", self)
                
            event.accept()
        else:
            super().mousePressEvent(event)

class MapViewer(QGraphicsView):
    pin_created_signal = pyqtSignal(float, float)
    pin_moved_signal = pyqtSignal(str, float, float) # id, new_x, new_y

    def __init__(self, parent=None):
        super().__init__(parent)
        self.scene = QGraphicsScene(self)
        self.setScene(self.scene)
        self.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)
        self.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)
        self.setTransformationAnchor(QGraphicsView.ViewportAnchor.AnchorUnderMouse)
        self.setBackgroundBrush(QBrush(QColor("#111")))
        
        self.map_item = None
        self.is_moving_pin = False
        self.moving_pin_id = None

    def load_map(self, pixmap):
        self.scene.clear()
        self.map_item = QGraphicsPixmapItem(pixmap)
        self.map_item.setTransformationMode(Qt.TransformationMode.SmoothTransformation)
        self.map_item.setZValue(0)
        self.scene.addItem(self.map_item)
        self.setSceneRect(self.map_item.boundingRect())
        self.cancel_move_mode()

    def add_pin_object(self, pin_item):
        self.scene.addItem(pin_item)

    def start_move_mode(self, pin_id):
        self.is_moving_pin = True
        self.moving_pin_id = pin_id
        self.viewport().setCursor(Qt.CursorShape.CrossCursor)
        self.setDragMode(QGraphicsView.DragMode.NoDrag)

    def cancel_move_mode(self):
        self.is_moving_pin = False
        self.moving_pin_id = None
        self.viewport().setCursor(Qt.CursorShape.ArrowCursor)
        self.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)

    def mousePressEvent(self, event):
        if self.is_moving_pin and event.button() == Qt.MouseButton.LeftButton:
            scene_pos = self.mapToScene(event.pos())
            if self.map_item and self.map_item.boundingRect().contains(scene_pos):
                self.pin_moved_signal.emit(self.moving_pin_id, scene_pos.x(), scene_pos.y())
                self.cancel_move_mode()
                return
        super().mousePressEvent(event)

    def wheelEvent(self, event: QWheelEvent):
        zoom_in = 1.15
        zoom_out = 1 / zoom_in
        if event.angleDelta().y() > 0: self.scale(zoom_in, zoom_in)
        else: self.scale(zoom_out, zoom_out)

    def contextMenuEvent(self, event):
        if self.is_moving_pin:
            self.cancel_move_mode()
            return

        if not self.map_item: return
        menu = QMenu(self)
        menu.setStyleSheet("QMenu { background-color: #333; color: white; border: 1px solid #555; } QMenu::item:selected { background-color: #007acc; }")
        
        action_add_pin = QAction(tr("MENU_CTX_PIN"), self)
        menu.addAction(action_add_pin)
        
        scene_pos = self.mapToScene(event.pos())
        if not self.map_item.boundingRect().contains(scene_pos): return
        
        action = menu.exec(event.globalPos())
        if action == action_add_pin:
            self.pin_created_signal.emit(scene_pos.x(), scene_pos.y())

===== FILE PATH =====
./ui\widgets\npc_sheet.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import (QWidget, QVBoxLayout, QHBoxLayout, QFormLayout, 
                             QLineEdit, QTextEdit, QComboBox, QTabWidget, 
                             QLabel, QGroupBox, QPushButton, QScrollArea, QFrame, 
                             QListWidget, QFileDialog, QMessageBox, QStyle)
from PyQt6.QtCore import Qt, QUrl
from PyQt6.QtGui import QDesktopServices, QPixmap
from ui.widgets.aspect_ratio_label import AspectRatioLabel
from core.models import ENTITY_SCHEMAS
from core.locales import tr
import os

class NpcSheet(QWidget):
    def __init__(self):
        super().__init__()
        self.dynamic_inputs = {}
        self.image_list = []
        self.current_img_index = 0
        self.init_ui()

    def init_ui(self):
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)

        # Scroll Area AyarlarÄ±
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.Shape.NoFrame)
        scroll.setObjectName("mainScroll") 
        
        # Ä°Ã§erik Widget'Ä± (Tema rengini almasÄ± iÃ§in ayarlar)
        self.content_widget = QWidget()
        self.content_widget.setObjectName("sheetContainer")
        self.content_widget.setAttribute(Qt.WidgetAttribute.WA_StyledBackground, True)

        self.content_layout = QVBoxLayout(self.content_widget)
        
        # --- ÃœST BÃ–LÃœM (RESÄ°M & TEMEL BÄ°LGÄ°) ---
        top_layout = QHBoxLayout()
        img_layout = QVBoxLayout()
        
        # Resim GÃ¶sterici
        self.lbl_image = AspectRatioLabel()
        self.lbl_image.setFixedSize(200, 200)
        
        # Galeri Kontrolleri
        gallery_controls = QHBoxLayout()
        self.btn_prev_img = QPushButton()
        self.btn_prev_img.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_ArrowBack))
        self.btn_prev_img.setMaximumWidth(30)
        self.btn_prev_img.clicked.connect(self.show_prev_image)
        
        self.btn_next_img = QPushButton()
        self.btn_next_img.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_ArrowForward))
        self.btn_next_img.setMaximumWidth(30)
        self.btn_next_img.clicked.connect(self.show_next_image)
        
        self.lbl_img_counter = QLabel("0/0")
        self.lbl_img_counter.setAlignment(Qt.AlignmentFlag.AlignCenter)
        
        gallery_controls.addWidget(self.btn_prev_img)
        gallery_controls.addWidget(self.lbl_img_counter)
        gallery_controls.addWidget(self.btn_next_img)
        
        # Resim Ekle/Sil ButonlarÄ±
        btn_img_actions = QHBoxLayout()
        self.btn_add_img = QPushButton(tr("BTN_ADD"))
        self.btn_add_img.setObjectName("successBtn")
        self.btn_add_img.clicked.connect(self.add_image_dialog)
        
        self.btn_remove_img = QPushButton()
        self.btn_remove_img.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon))
        self.btn_remove_img.setObjectName("dangerBtn")
        self.btn_remove_img.clicked.connect(self.remove_current_image)
        
        btn_img_actions.addWidget(self.btn_add_img)
        btn_img_actions.addWidget(self.btn_remove_img)

        # Oyuncuya GÃ¶ster Butonu
        self.btn_show_player = QPushButton(tr("BTN_SHOW_PLAYER"))
        self.btn_show_player.setObjectName("primaryBtn")
        
        img_layout.addWidget(self.lbl_image)
        img_layout.addLayout(gallery_controls)
        img_layout.addLayout(btn_img_actions)
        img_layout.addWidget(self.btn_show_player)
        img_layout.addStretch()

        # Bilgi Formu
        info_layout = QFormLayout()
        self.inp_name = QLineEdit()
        self.inp_type = QComboBox()
        
        for cat in ENTITY_SCHEMAS.keys():
            self.inp_type.addItem(tr(f"CAT_{cat.upper().replace(' ', '_').replace('(', '').replace(')', '')}"), cat)
        self.inp_type.currentIndexChanged.connect(self._on_type_index_changed)
        
        self.inp_tags = QLineEdit(); self.inp_tags.setPlaceholderText(tr("LBL_TAGS_PH"))
        
        self.combo_location = QComboBox()
        self.lbl_location = QLabel(tr("LBL_LOCATION"))
        self.list_residents = QListWidget(); self.list_residents.setMaximumHeight(80)
        self.lbl_residents = QLabel(tr("LBL_RESIDENTS"))
        
        self.inp_desc = QTextEdit()
        self.inp_desc.setMinimumHeight(80)
        self.inp_desc.setMaximumHeight(150)
        self.inp_desc.setPlaceholderText(tr("LBL_DESC"))

        info_layout.addRow(tr("LBL_NAME"), self.inp_name)
        info_layout.addRow(tr("LBL_TYPE"), self.inp_type)
        info_layout.addRow(tr("LBL_TAGS"), self.inp_tags)
        info_layout.addRow(self.lbl_location, self.combo_location)
        info_layout.addRow(self.lbl_residents, self.list_residents)
        info_layout.addRow(tr("LBL_DESC"), self.inp_desc)

        top_layout.addLayout(img_layout); top_layout.addLayout(info_layout)
        self.content_layout.addLayout(top_layout)

        # --- DÄ°NAMÄ°K ALANLAR ---
        self.grp_dynamic = QGroupBox(tr("LBL_PROPERTIES"))
        self.layout_dynamic = QFormLayout(self.grp_dynamic)
        self.content_layout.addWidget(self.grp_dynamic)

        # --- SEKMELER ---
        self.tabs = QTabWidget()
        self.tab_stats = QWidget(); self.setup_stats_tab(); self.tabs.addTab(self.tab_stats, tr("TAB_STATS"))
        self.tab_spells = QWidget(); self.setup_spells_tab(); self.tabs.addTab(self.tab_spells, tr("TAB_SPELLS"))
        self.tab_features = QWidget(); self.setup_features_tab(); self.tabs.addTab(self.tab_features, tr("TAB_ACTIONS"))
        self.tab_inventory = QWidget(); self.setup_inventory_tab(); self.tabs.addTab(self.tab_inventory, tr("TAB_INV"))
        self.tab_docs = QWidget(); self.setup_docs_tab(); self.tabs.addTab(self.tab_docs, tr("TAB_DOCS"))

        self.content_layout.addWidget(self.tabs)
        scroll.setWidget(self.content_widget)
        main_layout.addWidget(scroll)

        # --- ALT BUTONLAR ---
        btn_layout = QHBoxLayout(); btn_layout.setContentsMargins(10, 10, 10, 10)
        self.btn_delete = QPushButton(tr("BTN_DELETE")); self.btn_delete.setObjectName("dangerBtn")
        self.btn_save = QPushButton(tr("BTN_SAVE")); self.btn_save.setObjectName("primaryBtn")
        btn_layout.addStretch(); btn_layout.addWidget(self.btn_delete); btn_layout.addWidget(self.btn_save)
        main_layout.addLayout(btn_layout)
        
        self.update_ui_by_type(self.inp_type.currentData())

    def retranslate_ui(self):
        """
        Dil deÄŸiÅŸtiÄŸinde arayÃ¼zdeki tÃ¼m metinleri gÃ¼nceller.
        Dinamik alanlar (etiketler ve combobox seÃ§enekleri) dahildir.
        """
        # 1. Statik Combobox (VarlÄ±k Tipi) GÃ¼ncellemesi
        for i in range(self.inp_type.count()):
            cat = self.inp_type.itemData(i)
            if cat:
                # CAT_NPC, CAT_MONSTER gibi anahtarlarÄ± Ã§evir
                self.inp_type.setItemText(i, tr(f"CAT_{cat.upper().replace(' ', '_').replace('(', '').replace(')', '')}"))

        # 2. Buton ve Etiket Metinleri
        self.btn_show_player.setText(tr("BTN_SHOW_PLAYER"))
        self.btn_add_img.setText(tr("BTN_ADD"))
        self.btn_remove_img.setToolTip(tr("BTN_REMOVE"))
        self.lbl_location.setText(tr("LBL_LOCATION"))
        self.lbl_residents.setText(tr("LBL_RESIDENTS"))
        self.inp_desc.setPlaceholderText(tr("LBL_DESC"))
        
        # 3. Dinamik Ã–zellikler AlanÄ± (Grup BaÅŸlÄ±ÄŸÄ± ve Ä°Ã§erik)
        cat_key = self.inp_type.currentData()
        if cat_key: 
            cat_trans = tr(f"CAT_{cat_key.upper()}") if cat_key in ENTITY_SCHEMAS else cat_key
            self.grp_dynamic.setTitle(f"{cat_trans} {tr('LBL_PROPERTIES')}")
        else: 
            self.grp_dynamic.setTitle(tr("LBL_PROPERTIES"))

        # --- KRÄ°TÄ°K KISIM: Dinamik Form ElemanlarÄ±nÄ± GÃ¼ncelleme ---
        # self.dynamic_inputs sÃ¶zlÃ¼ÄŸÃ¼ { "LBL_RACE": widget_objesi } ÅŸeklindedir.
        for label_key, widget in self.dynamic_inputs.items():
            # A) Sol taraftaki Etiketi (Label) GÃ¼ncelle
            # QFormLayout, bir widget'a baÄŸlÄ± olan etiketi bulmamÄ±zÄ± saÄŸlar.
            label_widget = self.layout_dynamic.labelForField(widget)
            if label_widget:
                label_widget.setText(f"{tr(label_key)}:")
            
            # B) EÄŸer Widget bir ComboBox ise, seÃ§enekleri (Items) GÃ¼ncelle
            if isinstance(widget, QComboBox):
                for i in range(widget.count()):
                    # build_dynamic_form fonksiyonunda kaydettiÄŸimiz orijinal anahtarÄ± (key) alÄ±yoruz.
                    original_key = widget.itemData(i)
                    if original_key:
                        # EÄŸer anahtar "LBL_" ile baÅŸlÄ±yorsa Ã§evirisini al, yoksa olduÄŸu gibi bÄ±rak
                        new_text = tr(original_key) if str(original_key).startswith("LBL_") else original_key
                        widget.setItemText(i, new_text)

        # 4. Sekme BaÅŸlÄ±klarÄ±
        self.tabs.setTabText(0, tr("TAB_STATS"))
        self.tabs.setTabText(1, tr("TAB_SPELLS"))
        self.tabs.setTabText(2, tr("TAB_ACTIONS"))
        self.tabs.setTabText(3, tr("TAB_INV"))
        self.tabs.setTabText(4, tr("TAB_DOCS"))
        
        # 5. Alt Butonlar
        self.btn_delete.setText(tr("BTN_DELETE"))
        self.btn_save.setText(tr("BTN_SAVE"))
        
        # 6. Alt Grup BaÅŸlÄ±klarÄ± (Varsa)
        if hasattr(self, "grp_base_stats"): self.grp_base_stats.setTitle(tr("GRP_STATS"))
        if hasattr(self, "grp_combat_stats"): self.grp_combat_stats.setTitle(tr("GRP_COMBAT"))
        if hasattr(self, "grp_defense"): self.grp_defense.setTitle(tr("GRP_DEFENSE"))
        if hasattr(self, "grp_spells"): self.grp_spells.setTitle(tr("GRP_SPELLS"))
        if hasattr(self, "grp_inventory"): self.grp_inventory.setTitle(tr("GRP_INVENTORY"))
        if hasattr(self, "grp_pdf"): self.grp_pdf.setTitle(tr("GRP_PDF"))
        if hasattr(self, "grp_db_items"): self.grp_db_items.setTitle(tr("LBL_DB_ITEMS"))
        
        # 7. Kart AlanÄ± BaÅŸlÄ±klarÄ±
        self.trait_container.setTitle(tr("LBL_TRAITS"))
        self.action_container.setTitle(tr("LBL_ACTIONS"))
        self.reaction_container.setTitle(tr("LBL_REACTIONS"))
        self.legendary_container.setTitle(tr("LBL_LEGENDARY_ACTIONS"))
        self.custom_spell_container.setTitle(tr("LBL_MANUAL_SPELLS"))
        self.inventory_container.setTitle(tr("GRP_INVENTORY"))

        # 8. Statik Placeholder GÃ¼ncellemeleri
        self.inp_tags.setPlaceholderText(tr("LBL_TAGS_PH"))
        self.inp_hp.setPlaceholderText(tr("LBL_HP"))
        self.inp_max_hp.setPlaceholderText(tr("LBL_MAX_HP"))
        self.inp_ac.setPlaceholderText(tr("HEADER_AC"))
        self.inp_init.setPlaceholderText(tr("LBL_INIT"))
        self.combo_all_spells.setPlaceholderText(tr("LBL_SEARCH"))

    def build_dynamic_form(self, category_name):
        """
        Entity tipine gÃ¶re (NPC, Monster vs.) dinamik form alanlarÄ±nÄ± oluÅŸturur.
        Ã–nemli: ComboBox'larda itemData olarak Ã§eviri anahtarÄ±nÄ± saklarÄ±z.
        BÃ¶ylece dil deÄŸiÅŸtiÄŸinde orijinal anahtarÄ± bulup tekrar Ã§evirebiliriz.
        """
        # 1. Mevcut satÄ±rlarÄ± temizle
        while self.layout_dynamic.rowCount() > 0: 
            self.layout_dynamic.removeRow(0)
        
        # Referans sÃ¶zlÃ¼ÄŸÃ¼nÃ¼ sÄ±fÄ±rla
        self.dynamic_inputs = {} 
        
        # Ä°lgili ÅŸemayÄ± al
        schema = ENTITY_SCHEMAS.get(category_name, [])
        
        # Grup baÅŸlÄ±ÄŸÄ±nÄ± ayarla (Ã–rn: NPC Ã–zellikler)
        cat_trans = tr(f"CAT_{category_name.upper()}") if category_name in ENTITY_SCHEMAS else category_name
        self.grp_dynamic.setTitle(f"{cat_trans} {tr('LBL_PROPERTIES')}")
        
        # 2. Åžemadaki her alan iÃ§in widget oluÅŸtur
        for label_key, dtype, options in schema:
            if dtype == "combo":
                widget = QComboBox()
                widget.setEditable(True) # KullanÄ±cÄ± manuel de yazabilsin
                if options:
                    for opt in options:
                        # GÃ¶rÃ¼nen Metin: tr(opt) -> "Dost"
                        # Arka Plan Verisi: opt -> "LBL_ATTR_FRIENDLY"
                        display_text = tr(opt) if str(opt).startswith("LBL_") else opt
                        widget.addItem(display_text, opt) 
            else:
                widget = QLineEdit()
            
            # 3. Form satÄ±rÄ±nÄ± ekle
            # label_key (Ã–rn: "LBL_RACE") kullanarak Ã§eviriyi alÄ±yoruz
            self.layout_dynamic.addRow(f"{tr(label_key)}:", widget)
            
            # 4. Widget'Ä± sÃ¶zlÃ¼ÄŸe kaydet
            # Anahtar olarak label_key kullanÄ±yoruz ki retranslate sÄ±rasÄ±nda etiketi bulabilelim.
            self.dynamic_inputs[label_key] = widget

    # --- RESÄ°M YÃ–NETÄ°MÄ° ---
    def add_image_dialog(self):
        fname, _ = QFileDialog.getOpenFileName(self, tr("BTN_SELECT_IMG"), "", "Images (*.png *.jpg *.jpeg *.bmp)")
        if fname:
            self.image_list.append(fname)
            self.current_img_index = len(self.image_list) - 1
            self.update_image_display()

    def remove_current_image(self):
        if not self.image_list: return
        del self.image_list[self.current_img_index]
        if self.current_img_index >= len(self.image_list):
            self.current_img_index = max(0, len(self.image_list) - 1)
        self.update_image_display()

    def show_prev_image(self):
        if not self.image_list: return
        self.current_img_index = (self.current_img_index - 1) % len(self.image_list)
        self.update_image_display()

    def show_next_image(self):
        if not self.image_list: return
        self.current_img_index = (self.current_img_index + 1) % len(self.image_list)
        self.update_image_display()

    def update_image_display(self):
        if not self.image_list:
            self.lbl_image.setPixmap(None)
            self.lbl_img_counter.setText("0/0")
            return
        
        path = self.image_list[self.current_img_index]
        if os.path.exists(path):
            self.lbl_image.setPixmap(QPixmap(path))
        else:
            self.lbl_image.setPixmap(None)
            
        self.lbl_img_counter.setText(f"{self.current_img_index + 1}/{len(self.image_list)}")

    # --- TAB KURULUMLARI ---
    def setup_stats_tab(self):
        layout = QVBoxLayout(self.tab_stats)
        self.grp_base_stats = QGroupBox(tr("GRP_STATS")); l = QHBoxLayout(self.grp_base_stats)
        self.stats_inputs = {}; self.stats_modifiers = {}
        for s in ["STR", "DEX", "CON", "INT", "WIS", "CHA"]:
            v = QVBoxLayout()
            lbl_title = QLabel(s); lbl_title.setAlignment(Qt.AlignmentFlag.AlignCenter); lbl_title.setStyleSheet("font-weight: bold;")
            inp = QLineEdit("10"); inp.setAlignment(Qt.AlignmentFlag.AlignCenter); inp.setMaximumWidth(50)
            inp.textChanged.connect(lambda text, key=s: self._update_modifier(key, text))
            lbl_mod = QLabel("+0"); lbl_mod.setAlignment(Qt.AlignmentFlag.AlignCenter); lbl_mod.setProperty("class", "statModifier")
            self.stats_inputs[s] = inp; self.stats_modifiers[s] = lbl_mod
            v.addWidget(lbl_title); v.addWidget(inp); v.addWidget(lbl_mod); l.addLayout(v)
        layout.addWidget(self.grp_base_stats)
        self.grp_combat_stats = self._create_combat_stats_group()
        layout.addWidget(self.grp_combat_stats)
        self.grp_defense = QGroupBox(tr("GRP_DEFENSE")); form3 = QFormLayout(self.grp_defense)
        self.inp_saves = QLineEdit(); self.inp_skills = QLineEdit()
        self.inp_vuln = QLineEdit(); self.inp_resist = QLineEdit()
        self.inp_dmg_immune = QLineEdit(); self.inp_cond_immune = QLineEdit()
        form3.addRow(tr("LBL_SAVES"), self.inp_saves); form3.addRow(tr("LBL_SKILLS"), self.inp_skills)
        form3.addRow(tr("LBL_VULN"), self.inp_vuln); form3.addRow(tr("LBL_RESIST"), self.inp_resist)
        form3.addRow(tr("LBL_DMG_IMMUNE"), self.inp_dmg_immune); form3.addRow(tr("LBL_COND_IMMUNE"), self.inp_cond_immune)
        layout.addWidget(self.grp_defense); layout.addStretch()
        
    def _create_combat_stats_group(self):
        grp = QGroupBox(tr("GRP_COMBAT"))
        v_comb = QVBoxLayout(grp)
        self.inp_hp = QLineEdit(); self.inp_hp.setPlaceholderText(tr("LBL_HP"))
        self.inp_max_hp = QLineEdit(); self.inp_max_hp.setPlaceholderText(tr("LBL_MAX_HP"))
        self.inp_ac = QLineEdit(); self.inp_ac.setPlaceholderText(tr("HEADER_AC"))
        self.inp_speed = QLineEdit(); self.inp_prof = QLineEdit(); self.inp_pp = QLineEdit()
        self.inp_init = QLineEdit(); self.inp_init.setPlaceholderText(tr("LBL_INIT"))
        row1 = QHBoxLayout()
        for t, w in [(tr("LBL_MAX_HP"), self.inp_max_hp), (tr("LBL_HP"), self.inp_hp), (tr("HEADER_AC"), self.inp_ac), (tr("LBL_SPEED"), self.inp_speed)]:
             v = QVBoxLayout(); v.addWidget(QLabel(t)); v.addWidget(w); row1.addLayout(v)
        row2 = QHBoxLayout()
        for t, w in [(tr("LBL_PROF_BONUS"), self.inp_prof), (tr("LBL_PASSIVE_PERC"), self.inp_pp), (tr("LBL_INIT_BONUS"), self.inp_init)]:
             v = QVBoxLayout(); v.addWidget(QLabel(t)); v.addWidget(w); row2.addLayout(v)
        v_comb.addLayout(row1); v_comb.addLayout(row2)
        return grp

    def _update_modifier(self, stat_key, text_value):
        try:
            val = int(text_value); mod = (val - 10) // 2; sign = "+" if mod >= 0 else ""
            self.stats_modifiers[stat_key].setText(f"{sign}{mod}")
            state = "positive" if mod > 0 else "neutral"
            self.stats_modifiers[stat_key].setProperty("state", state)
            self.stats_modifiers[stat_key].style().unpolish(self.stats_modifiers[stat_key])
            self.stats_modifiers[stat_key].style().polish(self.stats_modifiers[stat_key])
            if mod > 0: self.stats_modifiers[stat_key].setStyleSheet("color: #4caf50; font-weight: bold;")
            else: self.stats_modifiers[stat_key].setStyleSheet("color: #aaa; font-weight: normal;")
        except ValueError:
            self.stats_modifiers[stat_key].setText("-")

    def setup_spells_tab(self):
        layout = QVBoxLayout(self.tab_spells)
        self.grp_spells = QGroupBox(tr("GRP_SPELLS"))
        l_linked = QVBoxLayout(self.grp_spells)
        h = QHBoxLayout()
        self.combo_all_spells = QComboBox(); self.combo_all_spells.setEditable(True); self.combo_all_spells.setPlaceholderText(tr("LBL_SEARCH"))
        self.btn_add_spell = QPushButton(tr("BTN_ADD")); self.btn_add_spell.setObjectName("successBtn")
        h.addWidget(self.combo_all_spells, 3); h.addWidget(self.btn_add_spell, 1)
        self.list_assigned_spells = QListWidget(); self.list_assigned_spells.setAlternatingRowColors(True); self.list_assigned_spells.setMinimumHeight(300)
        self.btn_remove_spell = QPushButton(tr("BTN_REMOVE")); self.btn_remove_spell.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon)); self.btn_remove_spell.setObjectName("dangerBtn")
        l_linked.addLayout(h); l_linked.addWidget(self.list_assigned_spells); l_linked.addWidget(self.btn_remove_spell)
        layout.addWidget(self.grp_spells)
        self.custom_spell_container = self._create_section(tr("LBL_MANUAL_SPELLS"))
        self.add_btn_to_section(self.custom_spell_container, tr("BTN_ADD"))
        layout.addWidget(self.custom_spell_container); layout.addStretch()

    def setup_features_tab(self):
        layout = QVBoxLayout(self.tab_features)
        self.trait_container = self._create_section(tr("LBL_TRAITS")); self.add_btn_to_section(self.trait_container, tr("BTN_ADD"))
        self.action_container = self._create_section(tr("LBL_ACTIONS")); self.add_btn_to_section(self.action_container, tr("BTN_ADD"))
        self.reaction_container = self._create_section(tr("LBL_REACTIONS")); self.add_btn_to_section(self.reaction_container, tr("BTN_ADD"))
        self.legendary_container = self._create_section(tr("LBL_LEGENDARY_ACTIONS")); self.add_btn_to_section(self.legendary_container, tr("BTN_ADD"))
        layout.addWidget(self.trait_container); layout.addWidget(self.action_container); layout.addWidget(self.reaction_container); layout.addWidget(self.legendary_container); layout.addStretch()

    def setup_inventory_tab(self):
        layout = QVBoxLayout(self.tab_inventory)
        self.grp_db_items = QGroupBox(tr("LBL_DB_ITEMS")); l_linked = QVBoxLayout(self.grp_db_items); h = QHBoxLayout()
        self.combo_all_items = QComboBox(); self.combo_all_items.setEditable(True)
        self.btn_add_item_link = QPushButton(tr("BTN_ADD")); self.btn_add_item_link.setObjectName("successBtn")
        h.addWidget(self.combo_all_items, 3); h.addWidget(self.btn_add_item_link, 1)
        self.list_assigned_items = QListWidget(); self.list_assigned_items.setAlternatingRowColors(True)
        self.btn_remove_item_link = QPushButton(tr("BTN_REMOVE")); self.btn_remove_item_link.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon)); self.btn_remove_item_link.setObjectName("dangerBtn")
        l_linked.addLayout(h); l_linked.addWidget(self.list_assigned_items); l_linked.addWidget(self.btn_remove_item_link)
        layout.addWidget(self.grp_db_items)
        self.inventory_container = self._create_section(tr("GRP_INVENTORY"))
        self.add_btn_to_section(self.inventory_container, tr("BTN_ADD"))
        layout.addWidget(self.inventory_container); layout.addStretch()

    def setup_docs_tab(self):
        layout = QVBoxLayout(self.tab_docs)
        self.grp_pdf = QGroupBox(tr("GRP_PDF")); v = QVBoxLayout(self.grp_pdf)
        h_btn = QHBoxLayout()
        self.btn_add_pdf = QPushButton(tr("BTN_ADD")); self.btn_add_pdf.setObjectName("successBtn")
        self.btn_open_pdf_folder = QPushButton(); self.btn_open_pdf_folder.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_DirIcon))
        h_btn.addWidget(self.btn_add_pdf, 3); h_btn.addWidget(self.btn_open_pdf_folder, 1)
        v.addLayout(h_btn)
        self.list_pdfs = QListWidget(); self.list_pdfs.setAlternatingRowColors(True)
        v.addWidget(self.list_pdfs)
        h_action = QHBoxLayout()
        self.btn_open_pdf = QPushButton(tr("BTN_OPEN_PDF")); self.btn_open_pdf.setObjectName("primaryBtn")
        self.btn_project_pdf = QPushButton(tr("BTN_PROJECT_PDF")); self.btn_project_pdf.setObjectName("actionBtn")
        self.btn_remove_pdf = QPushButton(tr("BTN_REMOVE")); self.btn_remove_pdf.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_TrashIcon)); self.btn_remove_pdf.setObjectName("dangerBtn")
        h_action.addWidget(self.btn_open_pdf); h_action.addWidget(self.btn_project_pdf); h_action.addWidget(self.btn_remove_pdf)
        v.addLayout(h_action); layout.addWidget(self.grp_pdf); layout.addStretch()

    # --- YARDIMCILAR ---
    def _create_section(self, title):
        group = QGroupBox(title); v = QVBoxLayout(group); group.dynamic_area = QVBoxLayout(); v.addLayout(group.dynamic_area); return group

    def add_btn_to_section(self, container, label):
        btn = QPushButton(label); btn.clicked.connect(lambda: self.add_feature_card(container)); btn.setObjectName("successBtn")
        container.layout().insertWidget(0, btn)

    def add_feature_card(self, group, name="", desc="", ph_title=None, ph_desc=None):
        if ph_title is None: ph_title = tr("LBL_TITLE_PH")
        if ph_desc is None: ph_desc = tr("LBL_DETAILS_PH")
        card = QFrame(); card.setProperty("class", "featureCard")
        l = QVBoxLayout(card); h = QHBoxLayout()
        t = QLineEdit(name); t.setPlaceholderText(ph_title); t.setStyleSheet("font-weight: bold; border:none; font-size: 14px; background: transparent;")
        btn = QPushButton(); btn.setFixedSize(24,24); btn.setIcon(self.style().standardIcon(QStyle.StandardPixmap.SP_TitleBarCloseButton)); btn.setCursor(Qt.CursorShape.PointingHandCursor); btn.setToolTip(tr("BTN_REMOVE")); btn.setStyleSheet("background: transparent; border: none;")
        btn.clicked.connect(lambda: [group.dynamic_area.removeWidget(card), card.deleteLater()])
        h.addWidget(t); h.addWidget(btn); l.addLayout(h)
        d = QTextEdit(desc); d.setPlaceholderText(ph_desc); d.setMinimumHeight(80); d.setMaximumHeight(300); d.setStyleSheet("border:none; background: transparent;")
        l.addWidget(d); group.dynamic_area.addWidget(card); card.inp_title = t; card.inp_desc = d

    # --- DÃœZELTÄ°LMÄ°Åž FONKSÄ°YON ---
    def clear_all_cards(self):
        containers = [self.trait_container, self.action_container, self.reaction_container, self.legendary_container, self.inventory_container, self.custom_spell_container]
        for g in containers:
            while g.dynamic_area.count(): 
                c = g.dynamic_area.takeAt(0)
                if c.widget(): c.widget().deleteLater()
    
    def _on_type_index_changed(self, index):
        cat_key = self.inp_type.itemData(index)
        if cat_key: self.update_ui_by_type(cat_key)

    def update_ui_by_type(self, category_name):
        self.build_dynamic_form(category_name)
        is_npc_like = category_name in ["NPC", "Monster"]
        is_player = category_name == "Player"
        is_lore = category_name == "Lore"
        is_status = category_name == "Status Effect"
        
        self.lbl_location.setVisible(is_npc_like or is_player); self.combo_location.setVisible(is_npc_like or is_player)
        self.lbl_residents.setVisible(category_name == "Location"); self.list_residents.setVisible(category_name == "Location")
        
        self.tabs.setTabVisible(0, is_npc_like) # Stats
        self.tabs.setTabVisible(1, is_npc_like) # Spells
        self.tabs.setTabVisible(2, is_npc_like) # Actions
        self.tabs.setTabVisible(3, is_npc_like) # Inv
        self.tabs.setTabVisible(4, is_lore or is_player or is_status)
        
        if is_player:
            if self.grp_combat_stats.parent() == self.tab_stats:
                self.tab_stats.layout().removeWidget(self.grp_combat_stats); idx = self.content_layout.indexOf(self.tabs); self.content_layout.insertWidget(idx, self.grp_combat_stats)
            self.grp_combat_stats.setVisible(True)
        elif is_status:
            self.grp_combat_stats.setVisible(False)
        else:
            if self.grp_combat_stats.parent() != self.tab_stats:
                self.content_layout.removeWidget(self.grp_combat_stats); self.tab_stats.layout().insertWidget(1, self.grp_combat_stats)
            self.grp_combat_stats.setVisible(is_npc_like)
        
        if is_status: self.lbl_image.setText("Icon")

    def prepare_new_entity(self):
        self.inp_name.clear(); self.inp_desc.clear(); self.inp_tags.clear(); self.lbl_image.setPixmap(None)
        self.image_list = []; self.current_img_index = 0; self.lbl_img_counter.setText("0/0") 
        self.clear_all_cards(); self.inp_type.setCurrentIndex(0)
        for i in self.stats_inputs.values(): i.setText("10")
        self.inp_hp.clear(); self.inp_max_hp.clear(); self.inp_ac.clear(); self.list_assigned_spells.clear(); self.list_assigned_items.clear()
        self.inp_prof.clear(); self.inp_pp.clear(); self.inp_skills.clear(); self.inp_init.clear()
        self.inp_saves.clear(); self.inp_vuln.clear(); self.inp_resist.clear(); self.inp_dmg_immune.clear(); self.inp_cond_immune.clear()
        self.combo_location.clear(); self.list_residents.clear(); self.list_pdfs.clear()

===== FILE PATH =====
./ui\windows\battle_map_window.py
===== FILE CONTENT =====
from PyQt6.QtWidgets import (QMainWindow, QWidget, QVBoxLayout, QHBoxLayout, 
                             QLabel, QScrollArea, QFrame, QGraphicsView, 
                             QGraphicsScene, QGraphicsEllipseItem, QSlider, QGraphicsPixmapItem)
from PyQt6.QtGui import QPixmap, QColor, QFont, QBrush, QPen, QPainter, QPainterPath

from PyQt6.QtCore import Qt, QRectF, pyqtSignal, QPointF, QTimer, QRect # QRect de eklendi
from core.locales import tr

class SidebarConditionIcon(QWidget):
    def __init__(self, name, icon_path, duration):
        super().__init__()
        self.name = name
        self.icon_path = icon_path
        self.duration = duration
        self.setFixedSize(20, 20) # Sidebar iÃ§in biraz daha kÃ¼Ã§Ã¼k (20px)
        self.setToolTip(f"{name} ({duration} Turns)" if duration > 0 else name)

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.RenderHint.Antialiasing)
        
        path = QPainterPath()
        path.addEllipse(1, 1, 18, 18)
        painter.setClipPath(path)
        
        if self.icon_path and os.path.exists(self.icon_path):
            painter.drawPixmap(0, 0, 20, 20, QPixmap(self.icon_path))
        else:
            painter.setBrush(QBrush(QColor("#5c6bc0")))
            painter.drawRect(0, 0, 20, 20)
            painter.setPen(Qt.GlobalColor.white)
            font = painter.font()
            font.setPointSize(7)
            font.setBold(True)
            painter.setFont(font)
            painter.drawText(QRect(0, 0, 20, 20), Qt.AlignmentFlag.AlignCenter, self.name[:2].upper())
            
        if self.duration > 0:
            painter.setClipping(False)
            painter.setBrush(QBrush(QColor(0, 0, 0, 200)))
            painter.setPen(Qt.PenStyle.NoPen)
            painter.drawRoundedRect(0, 12, 20, 8, 2, 2)
            
            painter.setPen(Qt.GlobalColor.white)
            font = painter.font()
            font.setPointSize(5)
            painter.setFont(font)
            painter.drawText(QRect(0, 12, 20, 8), Qt.AlignmentFlag.AlignCenter, str(self.duration))

# --- TOKEN (PUL) SINIFI ---
class BattleTokenItem(QGraphicsEllipseItem):
    def __init__(self, size, pixmap, border_color, name, tid, eid, on_move_callback):
        super().__init__(0, 0, size, size)
        
        self.tid = tid # Takip ID'si (Benzersiz)
        self.eid = eid # VarlÄ±k ID'si (Library)
        self.name = name
        self.on_move_callback = on_move_callback 
        self.original_pixmap = pixmap 
        self.border_color = border_color
        
        # Hareket ve SeÃ§im BayraklarÄ±
        self.setFlag(QGraphicsEllipseItem.GraphicsItemFlag.ItemIsMovable)
        self.setFlag(QGraphicsEllipseItem.GraphicsItemFlag.ItemIsSelectable)
        self.setFlag(QGraphicsEllipseItem.GraphicsItemFlag.ItemSendsGeometryChanges)
        
        self.setToolTip(name)
        self.update_appearance(size)

    def update_appearance(self, size):
        self.setRect(0, 0, size, size)
        
        # SÄ±nÄ±r Rengi (Border)
        pen = QPen(QColor(self.border_color))
        pen.setWidth(3)
        self.setPen(pen)
        
        if self.original_pixmap and not self.original_pixmap.isNull():
            # Resmi token iÃ§ine sÄ±ÄŸdÄ±r (Yuvarlak kesim maskesi QBrush ile yapÄ±lÄ±r)
            scaled = self.original_pixmap.scaled(int(size), int(size), 
                                               Qt.AspectRatioMode.KeepAspectRatioByExpanding, 
                                               Qt.TransformationMode.SmoothTransformation)
            brush = QBrush(scaled)
            self.setBrush(brush)
        else:
            # Resim yoksa koyu gri dolgu
            self.setBrush(QBrush(QColor("#444")))

    def mouseReleaseEvent(self, event):
        super().mouseReleaseEvent(event)
        if self.on_move_callback:
            self.on_move_callback(self.tid, self.pos().x(), self.pos().y())

# --- ANA PENCERE ---
class BattleMapWindow(QMainWindow):
    token_moved_signal = pyqtSignal(str, float, float)

    def __init__(self, data_manager):
        super().__init__()
        self.dm = data_manager
        self.tokens = {} 
        self.token_size = 50 
        self.map_item = None
        
        self.setWindowTitle(tr("TITLE_BATTLE_MAP"))
        self.resize(1200, 800)
        
        # Hardcoded stil kaldÄ±rÄ±ldÄ±, QMainWindow stili QSS'den gelecek.
        
        central = QWidget()
        self.setCentralWidget(central)
        main_layout = QHBoxLayout(central)
        main_layout.setContentsMargins(0, 0, 0, 0)
        
        # --- SOL: HARÄ°TA ALANI ---
        map_layout = QVBoxLayout()
        
        # Toolbar
        toolbar = QHBoxLayout()
        toolbar.setContentsMargins(10, 5, 10, 5)
        
        self.lbl_size = QLabel(tr("LBL_TOKEN_SIZE"))
        self.lbl_size.setObjectName("toolbarLabel")
        
        self.slider_size = QSlider(Qt.Orientation.Horizontal)
        self.slider_size.setMinimum(20); self.slider_size.setMaximum(300)
        self.slider_size.setValue(self.token_size)
        self.slider_size.valueChanged.connect(self.change_token_size)
        self.slider_size.setFixedWidth(200)
        
        toolbar.addWidget(self.lbl_size)
        toolbar.addWidget(self.slider_size)
        toolbar.addStretch()
        map_layout.addLayout(toolbar)
        
        # Grafik Sahnesi ve GÃ¶rÃ¼nÃ¼mÃ¼
        self.scene = QGraphicsScene()
        # Sahne arka planÄ± (Canvas) her zaman koyu olmasÄ± harita iÃ§in iyidir, 
        # ancak tema uyumu istenirse bu satÄ±r kaldÄ±rÄ±labilir.
        self.scene.setBackgroundBrush(QBrush(QColor("#111")))
        
        self.view = QGraphicsView(self.scene)
        self.view.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.view.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)
        self.view.setDragMode(QGraphicsView.DragMode.ScrollHandDrag)
        self.view.setStyleSheet("border: none;") # View Ã§erÃ§evesini kaldÄ±r
        
        # Scroll barlarÄ± kapat
        self.view.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        self.view.setVerticalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        map_layout.addWidget(self.view)
        
        # --- SAÄž: SIDEBAR ---
        self.sidebar = QWidget()
        self.sidebar.setFixedWidth(300)
        # Sidebar'Ä± QSS ile stillendirmek iÃ§in objectName atÄ±yoruz
        self.sidebar.setObjectName("sidebarFrame") 
        
        sidebar_layout = QVBoxLayout(self.sidebar)
        
        self.lbl_title = QLabel(tr("TITLE_TURN_ORDER"))
        self.lbl_title.setObjectName("headerLabel") # QSS iÃ§in ID
        self.lbl_title.setAlignment(Qt.AlignmentFlag.AlignCenter)
        sidebar_layout.addWidget(self.lbl_title)
        
        scroll = QScrollArea()
        scroll.setWidgetResizable(True)
        scroll.setFrameShape(QFrame.Shape.NoFrame)
        scroll.setObjectName("sidebarScroll")
        
        self.list_container = QWidget()
        self.list_container.setObjectName("sheetContainer")
        self.list_container.setAttribute(Qt.WidgetAttribute.WA_StyledBackground, True)
        
        self.list_layout = QVBoxLayout(self.list_container)
        self.list_layout.setAlignment(Qt.AlignmentFlag.AlignTop)
        self.list_layout.setSpacing(5)
        scroll.setWidget(self.list_container)
        sidebar_layout.addWidget(scroll)
        
        main_layout.addLayout(map_layout, 1)
        main_layout.addWidget(self.sidebar, 0)

    def retranslate_ui(self):
        self.setWindowTitle(tr("TITLE_BATTLE_MAP"))
        self.lbl_size.setText(tr("LBL_TOKEN_SIZE"))
        self.lbl_title.setText(tr("TITLE_TURN_ORDER"))

    # --- EKRAN BOYUTLANDIRMA OLAYI ---
    def resizeEvent(self, event):
        """Pencere boyutu deÄŸiÅŸtiÄŸinde haritayÄ± tekrar sÄ±ÄŸdÄ±r"""
        if self.map_item:
            self.fit_map_in_view()
        super().resizeEvent(event)

    def showEvent(self, event):
        """Pencere ilk aÃ§Ä±ldÄ±ÄŸÄ±nda haritayÄ± sÄ±ÄŸdÄ±r"""
        if self.map_item:
            self.fit_map_in_view()
        super().showEvent(event)

    def fit_map_in_view(self):
        """HaritayÄ± gÃ¶rÃ¼ntÃ¼ alanÄ±na (bozulmadan) sÄ±ÄŸdÄ±rÄ±r"""
        if self.map_item:
            self.view.fitInView(self.map_item, Qt.AspectRatioMode.KeepAspectRatio)

    def set_map_image(self, pixmap):
        if pixmap:
            if self.map_item: self.scene.removeItem(self.map_item)
            
            self.map_item = QGraphicsPixmapItem(pixmap)
            self.map_item.setZValue(-100)
            self.map_item.setTransformationMode(Qt.TransformationMode.SmoothTransformation)
            self.scene.addItem(self.map_item)
            self.scene.setSceneRect(self.map_item.boundingRect())
            
            # Resmi yÃ¼kler yÃ¼klemez sÄ±ÄŸdÄ±r (Layout'un oturmasÄ± iÃ§in kÄ±sa bir bekleme)
            QTimer.singleShot(100, self.fit_map_in_view)
        else:
            if self.map_item: self.scene.removeItem(self.map_item)
            self.map_item = None

    def change_token_size(self, val):
        self.token_size = val
        for token in self.tokens.values():
            token.update_appearance(self.token_size)

    def on_token_moved(self, tid, x, y):
        self.token_moved_signal.emit(tid, x, y)

    def update_combat_data(self, combatants, current_index, map_path=None, saved_token_size=None):
        if saved_token_size:
            self.token_size = saved_token_size
            self.slider_size.blockSignals(True)
            self.slider_size.setValue(saved_token_size)
            self.slider_size.blockSignals(False)

        if map_path:
            self.set_map_image(QPixmap(map_path))

        # Sidebar Temizle
        while self.list_layout.count():
            item = self.list_layout.takeAt(0)
            if item.widget(): item.widget().deleteLater()
            
        active_tids = []
        for c in combatants:
            key = c.get("tid") or c.get("eid")
            if key: active_tids.append(key)
            
        # Token Temizle (ArtÄ±k listede olmayanlarÄ± kaldÄ±r)
        to_remove = [tid for tid in self.tokens if tid not in active_tids]
        for tid in to_remove:
            self.scene.removeItem(self.tokens[tid])
            del self.tokens[tid]

        # Listeyi GÃ¼ncelle
        for i, c in enumerate(combatants):
            eid = c.get("eid")
            name = c.get("name", "???")
            hp = c.get("hp", "?")
            x, y = c.get("x"), c.get("y")
            conditions = c.get("conditions", []) # DurumlarÄ± al
            
            ent_type = c.get("type", "NPC")
            attitude = c.get("attitude", "LBL_ATTR_NEUTRAL")
            is_player = (ent_type == "Player")
            is_active = (i == current_index)
            
            attitude_clean = "neutral"
            if attitude == "LBL_ATTR_HOSTILE": attitude_clean = "hostile"
            elif attitude == "LBL_ATTR_FRIENDLY": attitude_clean = "friendly"
            
            img_path = None
            if eid and eid in self.dm.data["entities"]:
                ent = self.dm.data["entities"][eid]
                rel_path = ent.get("image_path")
                if not rel_path and ent.get("images"): rel_path = ent.get("images")[0]
                if rel_path: img_path = self.dm.get_full_path(rel_path)

            # --- SIDEBAR KARTI ---
            card = QFrame()
            card.setProperty("class", "combatCard")
            card.setProperty("active", str(is_active).lower())
            card.setProperty("type", ent_type)
            card.setProperty("attitude", attitude_clean)
            
            # ANA DÃœZEN: Dikey (Ãœstte Ä°sim/Can, Altta Ä°konlar)
            card_main_layout = QVBoxLayout(card)
            card_main_layout.setContentsMargins(5, 5, 5, 5)
            card_main_layout.setSpacing(2)
            
            # 1. SATIR: Ä°sim ve Can
            row_header = QWidget()
            row_header_layout = QHBoxLayout(row_header)
            row_header_layout.setContentsMargins(0, 0, 0, 0)
            row_header_layout.setSpacing(5)
            
            lbl_name = QLabel(name)
            lbl_name.setStyleSheet("font-weight: bold; border: none; background: transparent;")
            
            hp_txt = tr("LBL_HP_SIDEBAR", hp=hp) if is_player else tr("LBL_HP_UNKNOWN")
            lbl_hp = QLabel(hp_txt)
            lbl_hp.setStyleSheet("border: none; background: transparent; font-style: italic;")
            
            row_header_layout.addWidget(lbl_name, 1)
            row_header_layout.addWidget(lbl_hp, 0)
            
            card_main_layout.addWidget(row_header)

            # 2. SATIR: Durum Ä°konlarÄ± (EÄŸer varsa)
            if conditions:
                row_conditions = QWidget()
                row_cond_layout = QHBoxLayout(row_conditions)
                row_cond_layout.setContentsMargins(0, 2, 0, 0)
                row_cond_layout.setSpacing(4)
                row_cond_layout.addStretch() # Ä°konlarÄ± saÄŸa yasla (veya sola iÃ§in baÅŸa koy)
                
                for cond in conditions:
                    # SidebarConditionIcon sÄ±nÄ±fÄ±nÄ± kullan
                    icon_widget = SidebarConditionIcon(
                        cond.get("name", "?"), 
                        cond.get("icon"), 
                        cond.get("duration", 0)
                    )
                    row_cond_layout.addWidget(icon_widget)
                
                # Ä°konlarÄ± sola yaslamak isterseniz addStretch'i buraya koyun:
                # row_cond_layout.addStretch() 
                
                card_main_layout.addWidget(row_conditions)

            self.list_layout.addWidget(card)

            # --- TOKEN GÃœNCELLEME ---
            # Tokenlar QGraphicsItem olduÄŸu iÃ§in QSS kullanamaz. 
            # Rengi burada manuel belirleyip token nesnesine veriyoruz.
            
            token_border_color = "#bdbdbd" # VarsayÄ±lan: Gri
            if is_active:
                token_border_color = "#ffb74d" # Turuncu (Aktif)
            elif is_player:
                token_border_color = "#4caf50" # YeÅŸil (Oyuncu)
            elif attitude_clean == "hostile":
                token_border_color = "#ef5350" # KÄ±rmÄ±zÄ± (DÃ¼ÅŸman)
            elif attitude_clean == "friendly":
                token_border_color = "#42a5f5" # Mavi (Dost)

            token_key = c.get("tid")
            if not token_key: token_key = c.get("eid")
            
            if token_key:
                if token_key in self.tokens:
                    token = self.tokens[token_key]
                    token.border_color = token_border_color
                    token.update_appearance(self.token_size)
                    token.setZValue(100 if is_active else 10)
                    
                    if x is not None and y is not None:
                         # SÃ¼rÃ¼klerken titremesin diye kÃ¼Ã§Ã¼k tolerans
                         if abs(token.x() - x) > 1 or abs(token.y() - y) > 1:
                             token.setPos(x, y)
                else:
                    pixmap = QPixmap(img_path) if img_path else None
                    token = BattleTokenItem(self.token_size, pixmap, token_border_color, name, token_key, eid, self.on_token_moved)
                    
                    if x is not None and y is not None:
                        token.setPos(x, y)
                    else:
                        # Haritada pozisyonu yoksa sÄ±rayla diz
                        offset = len(self.tokens) * (self.token_size + 10)
                        token.setPos(50 + offset, 50)
                    
                    self.scene.addItem(token)
                    self.tokens[token_key] = token

